

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>smote_variants._smote_variants &mdash; smote_variants 0.1.0 documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> smote_variants
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Getting Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
</ul>
<p class="caption"><span class="caption-text">API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../oversamplers.html">Oversamplers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../noise_filters.html">Noise filters and prototype selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../model_selection.html">Model selection, evaluation and validation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../multiclass_oversampling.html">Multiclass oversampling</a></li>
</ul>
<p class="caption"><span class="caption-text">Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../add_new_oversampler.html">Adding a new oversampler</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery.html">Gallery</a></li>
</ul>
<p class="caption"><span class="caption-text">Interfaces</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../use_in_r.html">Using <code class="docutils literal notranslate"><span class="pre">smote_variants</span></code> in R</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../use_in_julia.html">Using <code class="docutils literal notranslate"><span class="pre">smote_variants</span></code> in Julia</a></li>
</ul>
<p class="caption"><span class="caption-text">The competition</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../competition.html">About the competition</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../ranking.html">Ranking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../downloads.html">Downloads</a></li>
</ul>
<p class="caption"><span class="caption-text">Additional Information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contribute</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release_history.html">Release History</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">smote_variants</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>smote_variants._smote_variants</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for smote_variants._smote_variants</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Sat Sep 15 11:15:24 2018</span>

<span class="sd">@author: gykovacs</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># import system packages</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">inspect</span>

<span class="c1"># used to parallelize evaluation</span>
<span class="kn">from</span> <span class="nn">joblib</span> <span class="k">import</span> <span class="n">Parallel</span><span class="p">,</span> <span class="n">delayed</span>

<span class="c1"># numerical methods and arrays</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>

<span class="c1"># import packages used for the implementation of sampling methods</span>
<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="n">RepeatedStratifiedKFold</span><span class="p">,</span> <span class="n">KFold</span><span class="p">,</span> <span class="n">cross_val_score</span><span class="p">,</span> <span class="n">StratifiedKFold</span>
<span class="kn">from</span> <span class="nn">sklearn.neighbors</span> <span class="k">import</span> <span class="n">NearestNeighbors</span><span class="p">,</span> <span class="n">KNeighborsClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="k">import</span> <span class="n">LogisticRegression</span><span class="p">,</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">log_loss</span><span class="p">,</span> <span class="n">roc_auc_score</span><span class="p">,</span> <span class="n">accuracy_score</span><span class="p">,</span> <span class="n">confusion_matrix</span><span class="p">,</span> <span class="n">f1_score</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics.pairwise</span> <span class="k">import</span> <span class="n">pairwise_distances</span>
<span class="kn">from</span> <span class="nn">sklearn.preprocessing</span> <span class="k">import</span> <span class="n">StandardScaler</span><span class="p">,</span> <span class="n">MinMaxScaler</span>
<span class="kn">from</span> <span class="nn">sklearn.cluster</span> <span class="k">import</span> <span class="n">KMeans</span><span class="p">,</span> <span class="n">AgglomerativeClustering</span><span class="p">,</span> <span class="n">DBSCAN</span>
<span class="kn">from</span> <span class="nn">sklearn.manifold</span> <span class="k">import</span> <span class="n">LocallyLinearEmbedding</span><span class="p">,</span> <span class="n">TSNE</span><span class="p">,</span> <span class="n">Isomap</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="k">import</span> <span class="n">PCA</span>
<span class="kn">from</span> <span class="nn">sklearn.svm</span> <span class="k">import</span> <span class="n">SVC</span>
<span class="kn">from</span> <span class="nn">sklearn.tree</span> <span class="k">import</span> <span class="n">DecisionTreeClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.naive_bayes</span> <span class="k">import</span> <span class="n">GaussianNB</span>
<span class="kn">from</span> <span class="nn">sklearn.discriminant_analysis</span> <span class="k">import</span> <span class="n">QuadraticDiscriminantAnalysis</span>
<span class="kn">from</span> <span class="nn">sklearn.mixture</span> <span class="k">import</span> <span class="n">GaussianMixture</span>
<span class="kn">from</span> <span class="nn">sklearn.discriminant_analysis</span> <span class="k">import</span> <span class="n">LinearDiscriminantAnalysis</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">RandomForestClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.neural_network</span> <span class="k">import</span> <span class="n">MLPClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.calibration</span> <span class="k">import</span> <span class="n">CalibratedClassifierCV</span>
<span class="c1">#from sklearn.calibration import CalibratedClassifierCV</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="k">import</span> <span class="n">clone</span><span class="p">,</span> <span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">ClassifierMixin</span>

<span class="c1"># some statistical methods</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="k">import</span> <span class="n">skew</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">ssignal</span>
<span class="kn">import</span> <span class="nn">scipy.spatial</span> <span class="k">as</span> <span class="nn">sspatial</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">soptimize</span>
<span class="kn">import</span> <span class="nn">scipy.special</span> <span class="k">as</span> <span class="nn">sspecial</span>
<span class="kn">from</span> <span class="nn">scipy.stats.mstats</span> <span class="k">import</span> <span class="n">gmean</span>

<span class="c1"># self-organizing map implementation</span>
<span class="kn">import</span> <span class="nn">minisom</span>

<span class="kn">from</span> <span class="nn">._version</span> <span class="k">import</span> <span class="n">__version__</span>

<span class="n">__author__</span><span class="o">=</span> <span class="s2">&quot;György Kovács&quot;</span>
<span class="n">__license__</span><span class="o">=</span> <span class="s2">&quot;MIT&quot;</span>
<span class="n">__email__</span><span class="o">=</span> <span class="s2">&quot;gyuriofkovacs@gmail.com&quot;</span>

<span class="c1">#for handler in _logger.root.handlers[:]:</span>
<span class="c1">#    _logger.root.removeHandler(handler)</span>

<span class="c1"># setting the _logger format</span>
<span class="c1">#_logger.basicConfig(filename= &#39;/home/gykovacs/workspaces/sampling2.log&#39;, level= logging.DEBUG, format=&quot;%(asctime)s:%(levelname)s:%(message)s&quot;)</span>
<span class="n">_logger</span><span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;smote_variants&#39;</span><span class="p">)</span>
<span class="n">_logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
<span class="n">_logger_ch</span><span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">StreamHandler</span><span class="p">()</span>
<span class="n">_logger_ch</span><span class="o">.</span><span class="n">setFormatter</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">Formatter</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2">:</span><span class="si">%(levelname)s</span><span class="s2">:</span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">))</span>
<span class="n">_logger</span><span class="o">.</span><span class="n">addHandler</span><span class="p">(</span><span class="n">_logger_ch</span><span class="p">)</span>

<span class="c1"># exported names</span>
<span class="n">__all__</span><span class="o">=</span> <span class="p">[</span><span class="s1">&#39;__author__&#39;</span><span class="p">,</span>
<span class="s1">&#39;__license__&#39;</span><span class="p">,</span>
<span class="s1">&#39;__version__&#39;</span><span class="p">,</span>
<span class="s1">&#39;__email__&#39;</span><span class="p">,</span>
<span class="s1">&#39;get_all_oversamplers&#39;</span><span class="p">,</span>
<span class="s1">&#39;get_all_noisefilters&#39;</span><span class="p">,</span>
<span class="s1">&#39;get_n_quickest_oversamplers&#39;</span><span class="p">,</span>
<span class="s1">&#39;get_all_oversamplers_multiclass&#39;</span><span class="p">,</span>
<span class="s1">&#39;get_n_quickest_oversamplers_multiclass&#39;</span><span class="p">,</span>
<span class="s1">&#39;evaluate_oversamplers&#39;</span><span class="p">,</span>
<span class="s1">&#39;read_oversampling_results&#39;</span><span class="p">,</span>
<span class="s1">&#39;model_selection&#39;</span><span class="p">,</span>
<span class="s1">&#39;cross_validate&#39;</span><span class="p">,</span>
<span class="s1">&#39;MLPClassifierWrapper&#39;</span><span class="p">,</span>
<span class="s1">&#39;OverSampling&#39;</span><span class="p">,</span>
<span class="s1">&#39;NoiseFilter&#39;</span><span class="p">,</span>
<span class="s1">&#39;TomekLinkRemoval&#39;</span><span class="p">,</span>
<span class="s1">&#39;CondensedNearestNeighbors&#39;</span><span class="p">,</span>
<span class="s1">&#39;OneSidedSelection&#39;</span><span class="p">,</span>
<span class="s1">&#39;CNNTomekLinks&#39;</span><span class="p">,</span>
<span class="s1">&#39;NeighborhoodCleaningRule&#39;</span><span class="p">,</span>
<span class="s1">&#39;EditedNearestNeighbors&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE_TomekLinks&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE_ENN&#39;</span><span class="p">,</span>
<span class="s1">&#39;Borderline_SMOTE1&#39;</span><span class="p">,</span>
<span class="s1">&#39;Borderline_SMOTE2&#39;</span><span class="p">,</span>
<span class="s1">&#39;ADASYN&#39;</span><span class="p">,</span>
<span class="s1">&#39;AHC&#39;</span><span class="p">,</span>
<span class="s1">&#39;LLE_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;distance_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMMO&#39;</span><span class="p">,</span>
<span class="s1">&#39;polynom_fit_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;Stefanowski&#39;</span><span class="p">,</span>
<span class="s1">&#39;ADOMS&#39;</span><span class="p">,</span>
<span class="s1">&#39;Safe_Level_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;MSMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;DE_oversampling&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOBD&#39;</span><span class="p">,</span>
<span class="s1">&#39;SUNDO&#39;</span><span class="p">,</span>
<span class="s1">&#39;MSYN&#39;</span><span class="p">,</span>
<span class="s1">&#39;SVM_balance&#39;</span><span class="p">,</span>
<span class="s1">&#39;TRIM_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE_RSB&#39;</span><span class="p">,</span>
<span class="s1">&#39;ProWSyn&#39;</span><span class="p">,</span>
<span class="s1">&#39;SL_graph_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;NRSBoundary_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;LVQ_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;SOI_CJ&#39;</span><span class="p">,</span>
<span class="s1">&#39;ROSE&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE_OUT&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE_Cosine&#39;</span><span class="p">,</span>
<span class="s1">&#39;Selected_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;LN_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;MWMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;PDFOS&#39;</span><span class="p">,</span>
<span class="s1">&#39;IPADE_ID&#39;</span><span class="p">,</span>
<span class="s1">&#39;RWO_sampling&#39;</span><span class="p">,</span>
<span class="s1">&#39;NEATER&#39;</span><span class="p">,</span>
<span class="s1">&#39;DEAGO&#39;</span><span class="p">,</span>
<span class="s1">&#39;Gazzah&#39;</span><span class="p">,</span>
<span class="s1">&#39;MCT&#39;</span><span class="p">,</span>
<span class="s1">&#39;ADG&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE_IPF&#39;</span><span class="p">,</span>
<span class="s1">&#39;KernelADASYN&#39;</span><span class="p">,</span>
<span class="s1">&#39;MOT2LD&#39;</span><span class="p">,</span>
<span class="s1">&#39;V_SYNTH&#39;</span><span class="p">,</span>
<span class="s1">&#39;OUPS&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE_D&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE_PSO&#39;</span><span class="p">,</span>
<span class="s1">&#39;CURE_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;SOMO&#39;</span><span class="p">,</span>
<span class="s1">&#39;ISOMAP_Hybrid&#39;</span><span class="p">,</span>
<span class="s1">&#39;CE_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;Edge_Det_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;CBSO&#39;</span><span class="p">,</span>
<span class="s1">&#39;E_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;DBSMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;ASMOBD&#39;</span><span class="p">,</span>
<span class="s1">&#39;Assembled_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;SDSMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;DSMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;G_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;NT_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;Lee&#39;</span><span class="p">,</span>
<span class="s1">&#39;SPY&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE_PSOBAT&#39;</span><span class="p">,</span>
<span class="s1">&#39;MDO&#39;</span><span class="p">,</span>
<span class="s1">&#39;Random_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;ISMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;VIS_RST&#39;</span><span class="p">,</span>
<span class="s1">&#39;GASMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;A_SUWO&#39;</span><span class="p">,</span>
<span class="s1">&#39;SMOTE_FRST_2T&#39;</span><span class="p">,</span>
<span class="s1">&#39;AND_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;NRAS&#39;</span><span class="p">,</span>
<span class="s1">&#39;AMSCO&#39;</span><span class="p">,</span>
<span class="s1">&#39;SSO&#39;</span><span class="p">,</span>
<span class="s1">&#39;NDO_sampling&#39;</span><span class="p">,</span>
<span class="s1">&#39;DSRBF&#39;</span><span class="p">,</span>
<span class="s1">&#39;Gaussian_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;kmeans_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;Supervised_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;SN_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;CCR&#39;</span><span class="p">,</span>
<span class="s1">&#39;ANS&#39;</span><span class="p">,</span>
<span class="s1">&#39;cluster_SMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;NoSMOTE&#39;</span><span class="p">,</span>
<span class="s1">&#39;MulticlassOversampling&#39;</span><span class="p">,</span>
<span class="s1">&#39;OversamplingClassifier&#39;</span><span class="p">]</span>

<div class="viewcode-block" id="get_all_oversamplers"><a class="viewcode-back" href="../../model_selection.html#smote_variants.get_all_oversamplers">[docs]</a><span class="k">def</span> <span class="nf">get_all_oversamplers</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns all oversampling classes</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        list(OverSampling): list of all oversampling classes</span>
<span class="sd">        </span>
<span class="sd">    Example::</span>
<span class="sd">        </span>
<span class="sd">        import smote_variants as sv</span>
<span class="sd">        </span>
<span class="sd">        oversamplers= sv.get_all_oversamplers()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">globals</span><span class="p">()[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">__all__</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span> <span class="ow">and</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="nb">globals</span><span class="p">()[</span><span class="n">s</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">globals</span><span class="p">()[</span><span class="n">s</span><span class="p">],</span> <span class="n">OverSampling</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="n">OverSampling</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_n_quickest_oversamplers"><a class="viewcode-back" href="../../model_selection.html#smote_variants.get_n_quickest_oversamplers">[docs]</a><span class="k">def</span> <span class="nf">get_n_quickest_oversamplers</span><span class="p">(</span><span class="n">n</span><span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the n quickest oversamplers based on testing on the datasets of</span>
<span class="sd">    the imbalanced_databases package.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        n (int): number of oversamplers to return</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        list(OverSampling): list of the n quickest oversampling classes</span>
<span class="sd">        </span>
<span class="sd">    Example::</span>
<span class="sd">        </span>
<span class="sd">        import smote_variants as sv</span>
<span class="sd">        </span>
<span class="sd">        oversamplers= sv.get_n_quickest_oversamplers(10)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">runtimes</span><span class="o">=</span> <span class="p">{</span><span class="s1">&#39;SPY&#39;</span><span class="p">:</span> <span class="mf">0.11</span><span class="p">,</span> <span class="s1">&#39;OUPS&#39;</span><span class="p">:</span> <span class="mf">0.16</span><span class="p">,</span> <span class="s1">&#39;SMOTE_D&#39;</span><span class="p">:</span> <span class="mf">0.20</span><span class="p">,</span> <span class="s1">&#39;NT_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.20</span><span class="p">,</span> <span class="s1">&#39;Gazzah&#39;</span><span class="p">:</span> <span class="mf">0.21</span><span class="p">,</span>
     <span class="s1">&#39;ROSE&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">,</span> <span class="s1">&#39;NDO_sampling&#39;</span><span class="p">:</span> <span class="mf">0.27</span><span class="p">,</span> <span class="s1">&#39;Borderline_SMOTE1&#39;</span><span class="p">:</span> <span class="mf">0.28</span><span class="p">,</span> <span class="s1">&#39;SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.28</span><span class="p">,</span>
     <span class="s1">&#39;Borderline_SMOTE2&#39;</span><span class="p">:</span> <span class="mf">0.29</span><span class="p">,</span> <span class="s1">&#39;ISMOTE&#39;</span><span class="p">:</span> <span class="mf">0.30</span><span class="p">,</span> <span class="s1">&#39;SMMO&#39;</span><span class="p">:</span> <span class="mf">0.31</span><span class="p">,</span> <span class="s1">&#39;SMOTE_OUT&#39;</span><span class="p">:</span> <span class="mf">0.37</span><span class="p">,</span>
     <span class="s1">&#39;SN_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.44</span><span class="p">,</span> <span class="s1">&#39;Selected_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.47</span><span class="p">,</span> <span class="s1">&#39;distance_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.47</span><span class="p">,</span> <span class="s1">&#39;Gaussian_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.48</span><span class="p">,</span>
     <span class="s1">&#39;MCT&#39;</span><span class="p">:</span> <span class="mf">0.51</span><span class="p">,</span> <span class="s1">&#39;Random_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.57</span><span class="p">,</span> <span class="s1">&#39;ADASYN&#39;</span><span class="p">:</span> <span class="mf">0.58</span><span class="p">,</span> <span class="s1">&#39;SL_graph_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.58</span><span class="p">,</span>
     <span class="s1">&#39;CURE_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.59</span><span class="p">,</span> <span class="s1">&#39;ANS&#39;</span><span class="p">:</span> <span class="mf">0.63</span><span class="p">,</span> <span class="s1">&#39;MSMOTE&#39;</span><span class="p">:</span> <span class="mf">0.72</span><span class="p">,</span> <span class="s1">&#39;Safe_Level_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.79</span><span class="p">,</span>
     <span class="s1">&#39;SMOBD&#39;</span><span class="p">:</span> <span class="mf">0.80</span><span class="p">,</span> <span class="s1">&#39;CBSO&#39;</span><span class="p">:</span> <span class="mf">0.81</span><span class="p">,</span> <span class="s1">&#39;Assembled_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.82</span><span class="p">,</span> <span class="s1">&#39;SDSMOTE&#39;</span><span class="p">:</span> <span class="mf">0.88</span><span class="p">,</span>
     <span class="s1">&#39;SMOTE_TomekLinks&#39;</span><span class="p">:</span> <span class="mf">0.91</span><span class="p">,</span> <span class="s1">&#39;Edge_Det_SMOTE&#39;</span><span class="p">:</span> <span class="mf">0.94</span><span class="p">,</span> <span class="s1">&#39;ProWSyn&#39;</span><span class="p">:</span> <span class="mf">1.00</span><span class="p">,</span> <span class="s1">&#39;Stefanowski&#39;</span><span class="p">:</span> <span class="mf">1.04</span><span class="p">,</span>
     <span class="s1">&#39;NRAS&#39;</span><span class="p">:</span> <span class="mf">1.06</span><span class="p">,</span> <span class="s1">&#39;AND_SMOTE&#39;</span><span class="p">:</span> <span class="mf">1.13</span><span class="p">,</span> <span class="s1">&#39;DBSMOTE&#39;</span><span class="p">:</span> <span class="mf">1.17</span><span class="p">,</span> <span class="s1">&#39;polynom_fit_SMOTE&#39;</span><span class="p">:</span> <span class="mf">1.18</span><span class="p">,</span>
     <span class="s1">&#39;ASMOBD&#39;</span><span class="p">:</span> <span class="mf">1.18</span><span class="p">,</span> <span class="s1">&#39;MDO&#39;</span><span class="p">:</span> <span class="mf">1.18</span><span class="p">,</span> <span class="s1">&#39;SOI_CJ&#39;</span><span class="p">:</span> <span class="mf">1.24</span><span class="p">,</span> <span class="s1">&#39;LN_SMOTE&#39;</span><span class="p">:</span> <span class="mf">1.26</span><span class="p">,</span> <span class="s1">&#39;VIS_RST&#39;</span><span class="p">:</span> <span class="mf">1.34</span><span class="p">,</span>
     <span class="s1">&#39;TRIM_SMOTE&#39;</span><span class="p">:</span> <span class="mf">1.36</span><span class="p">,</span> <span class="s1">&#39;LLE_SMOTE&#39;</span><span class="p">:</span> <span class="mf">1.62</span><span class="p">,</span> <span class="s1">&#39;SMOTE_ENN&#39;</span><span class="p">:</span> <span class="mf">1.86</span><span class="p">,</span> <span class="s1">&#39;SMOTE_Cosine&#39;</span><span class="p">:</span> <span class="mf">2.00</span><span class="p">,</span>
     <span class="s1">&#39;kmeans_SMOTE&#39;</span><span class="p">:</span> <span class="mf">2.43</span><span class="p">,</span> <span class="s1">&#39;MWMOTE&#39;</span><span class="p">:</span> <span class="mf">2.45</span><span class="p">,</span> <span class="s1">&#39;V_SYNTH&#39;</span><span class="p">:</span> <span class="mf">2.59</span><span class="p">,</span> <span class="s1">&#39;A_SUWO&#39;</span><span class="p">:</span> <span class="mf">2.81</span><span class="p">,</span>
     <span class="s1">&#39;RWO_sampling&#39;</span><span class="p">:</span> <span class="mf">2.91</span><span class="p">,</span> <span class="s1">&#39;SMOTE_RSB&#39;</span><span class="p">:</span> <span class="mf">3.88</span><span class="p">,</span> <span class="s1">&#39;ADOMS&#39;</span><span class="p">:</span> <span class="mf">3.89</span><span class="p">,</span> <span class="s1">&#39;SMOTE_IPF&#39;</span><span class="p">:</span> <span class="mf">4.10</span><span class="p">,</span>
     <span class="s1">&#39;Lee&#39;</span><span class="p">:</span> <span class="mf">4.16</span><span class="p">,</span> <span class="s1">&#39;SMOTE_FRST_2T&#39;</span><span class="p">:</span> <span class="mf">4.18</span><span class="p">,</span> <span class="s1">&#39;cluster_SMOTE&#39;</span><span class="p">:</span> <span class="mf">4.19</span><span class="p">,</span> <span class="s1">&#39;SOMO&#39;</span><span class="p">:</span> <span class="mf">4.30</span><span class="p">,</span>
     <span class="s1">&#39;DE_oversampling&#39;</span><span class="p">:</span> <span class="mf">4.67</span><span class="p">,</span> <span class="s1">&#39;CCR&#39;</span><span class="p">:</span> <span class="mf">4.72</span><span class="p">,</span> <span class="s1">&#39;NRSBoundary_SMOTE&#39;</span><span class="p">:</span> <span class="mf">5.26</span><span class="p">,</span> <span class="s1">&#39;AHC&#39;</span><span class="p">:</span> <span class="mf">5.27</span><span class="p">,</span>
     <span class="s1">&#39;ISOMAP_Hybrid&#39;</span><span class="p">:</span> <span class="mf">6.11</span><span class="p">,</span> <span class="s1">&#39;LVQ_SMOTE&#39;</span><span class="p">:</span> <span class="mf">6.99</span><span class="p">,</span> <span class="s1">&#39;CE_SMOTE&#39;</span><span class="p">:</span> <span class="mf">7.45</span><span class="p">,</span> <span class="s1">&#39;MSYN&#39;</span><span class="p">:</span> <span class="mf">11.92</span><span class="p">,</span>
     <span class="s1">&#39;PDFOS&#39;</span><span class="p">:</span> <span class="mf">15.14</span><span class="p">,</span> <span class="s1">&#39;KernelADASYN&#39;</span><span class="p">:</span> <span class="mf">17.87</span><span class="p">,</span> <span class="s1">&#39;G_SMOTE&#39;</span><span class="p">:</span> <span class="mf">19.23</span><span class="p">,</span> <span class="s1">&#39;E_SMOTE&#39;</span><span class="p">:</span> <span class="mf">19.50</span><span class="p">,</span>
     <span class="s1">&#39;SVM_balance&#39;</span><span class="p">:</span> <span class="mf">24.05</span><span class="p">,</span> <span class="s1">&#39;SUNDO&#39;</span><span class="p">:</span> <span class="mf">26.21</span><span class="p">,</span> <span class="s1">&#39;GASMOTE&#39;</span><span class="p">:</span> <span class="mf">31.38</span><span class="p">,</span> <span class="s1">&#39;DEAGO&#39;</span><span class="p">:</span> <span class="mf">33.39</span><span class="p">,</span>
     <span class="s1">&#39;NEATER&#39;</span><span class="p">:</span> <span class="mf">41.39</span><span class="p">,</span> <span class="s1">&#39;SMOTE_PSO&#39;</span><span class="p">:</span> <span class="mf">45.12</span><span class="p">,</span> <span class="s1">&#39;IPADE_ID&#39;</span><span class="p">:</span> <span class="mf">90.01</span><span class="p">,</span> <span class="s1">&#39;DSMOTE&#39;</span><span class="p">:</span> <span class="mf">146.73</span><span class="p">,</span>
     <span class="s1">&#39;MOT2LD&#39;</span><span class="p">:</span> <span class="mf">149.42</span><span class="p">,</span> <span class="s1">&#39;Supervised_SMOTE&#39;</span><span class="p">:</span> <span class="mf">195.74</span><span class="p">,</span> <span class="s1">&#39;SSO&#39;</span><span class="p">:</span> <span class="mf">215.27</span><span class="p">,</span> <span class="s1">&#39;DSRBF&#39;</span><span class="p">:</span> <span class="mf">272.11</span><span class="p">,</span>
     <span class="s1">&#39;SMOTE_PSOBAT&#39;</span><span class="p">:</span> <span class="mf">324.31</span><span class="p">,</span> <span class="s1">&#39;ADG&#39;</span><span class="p">:</span> <span class="mf">493.64</span><span class="p">,</span> <span class="s1">&#39;AMSCO&#39;</span><span class="p">:</span> <span class="mf">1502.36</span><span class="p">}</span>
    
    <span class="n">samplers</span><span class="o">=</span> <span class="n">get_all_oversamplers</span><span class="p">()</span>
    <span class="n">samplers</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">samplers</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">runtimes</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="vm">__name__</span> <span class="ow">in</span> <span class="n">runtimes</span> <span class="k">else</span> <span class="mf">1e8</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">samplers</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span></div>

<div class="viewcode-block" id="get_all_oversamplers_multiclass"><a class="viewcode-back" href="../../multiclass_oversampling.html#smote_variants.get_all_oversamplers_multiclass">[docs]</a><span class="k">def</span> <span class="nf">get_all_oversamplers_multiclass</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span> <span class="s2">&quot;equalize_1_vs_many_successive&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns all oversampling classes which can be used with the multiclass strategy specified</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        strategy (str): the multiclass oversampling strategy - &#39;equalize_1_vs_many_successive&#39;/&#39;equalize_1_vs_many&#39;</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        list(OverSampling): list of all oversampling classes which can be used with the multiclass strategy specified</span>
<span class="sd">        </span>
<span class="sd">    Example::</span>
<span class="sd">        </span>
<span class="sd">        import smote_variants as sv</span>
<span class="sd">        </span>
<span class="sd">        oversamplers= sv.get_all_oversamplers_multiclass()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">oversamplers</span><span class="o">=</span> <span class="n">get_all_oversamplers</span><span class="p">()</span>
    
    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;equalize_1_vs_many_successive&#39;</span> <span class="ow">or</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;equalize_1_vs_many&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">oversamplers</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">categories</span> <span class="ow">and</span> <span class="s1">&#39;proportion&#39;</span> <span class="ow">in</span> <span class="n">o</span><span class="p">()</span><span class="o">.</span><span class="n">get_params</span><span class="p">()]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;It is not known which oversamplers work with the strategy </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">strategy</span><span class="p">)</span></div>

<div class="viewcode-block" id="get_n_quickest_oversamplers_multiclass"><a class="viewcode-back" href="../../multiclass_oversampling.html#smote_variants.get_n_quickest_oversamplers_multiclass">[docs]</a><span class="k">def</span> <span class="nf">get_n_quickest_oversamplers_multiclass</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span> <span class="s2">&quot;equalize_1_vs_many_successive&quot;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the n quickest oversamplers based on testing on the datasets of</span>
<span class="sd">    the imbalanced_databases package, and suitable for using the multiclass strategy specified.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        n (int): number of oversamplers to return</span>
<span class="sd">        strategy (str): the multiclass oversampling strategy - &#39;equalize_1_vs_many_successive&#39;/&#39;equalize_1_vs_many&#39;</span>
<span class="sd">    </span>
<span class="sd">    Returns:</span>
<span class="sd">        list(OverSampling): list of n quickest oversampling classes which can be used with the multiclass strategy specified</span>
<span class="sd">        </span>
<span class="sd">    Example::</span>
<span class="sd">        </span>
<span class="sd">        import smote_variants as sv</span>
<span class="sd">        </span>
<span class="sd">        oversamplers= sv.get_n_quickest_oversamplers_multiclass()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">oversamplers</span><span class="o">=</span> <span class="n">get_all_oversamplers</span><span class="p">()</span>
    <span class="n">quickest_oversamplers</span><span class="o">=</span> <span class="n">get_n_quickest_oversamplers</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">oversamplers</span><span class="p">))</span>
    
    <span class="k">if</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;equalize_1_vs_many_successive&#39;</span> <span class="ow">or</span> <span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;equalize_1_vs_many&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">quickest_oversamplers</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">categories</span> <span class="ow">and</span> <span class="s1">&#39;proportion&#39;</span> <span class="ow">in</span> <span class="n">o</span><span class="p">()</span><span class="o">.</span><span class="n">get_params</span><span class="p">()][:</span><span class="n">n</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;It is not known which oversamplers work with the strategy </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">strategy</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">get_all_noisefilters</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns all noise filters</span>
<span class="sd">    Returns:</span>
<span class="sd">        list(NoiseFilter): list of all noise filter classes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">globals</span><span class="p">()[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">__all__</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">globals</span><span class="p">()</span> <span class="ow">and</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="nb">globals</span><span class="p">()[</span><span class="n">s</span><span class="p">])</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="nb">globals</span><span class="p">()[</span><span class="n">s</span><span class="p">],</span> <span class="n">NoiseFilter</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">globals</span><span class="p">()[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="n">NoiseFilter</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">mode</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="n">values</span><span class="p">,</span> <span class="n">counts</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">values</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">counts</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="n">counts</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>

<span class="k">class</span> <span class="nc">StatisticsMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin to compute class statistics and determine minority/majority labels</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">class_label_statistics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        determines class sizes and minority and majority labels</span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.array): features</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">unique</span><span class="p">,</span> <span class="n">counts</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">unique</span><span class="p">,</span> <span class="n">counts</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="o">=</span> <span class="n">unique</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">unique</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="o">=</span> <span class="n">unique</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">else</span> <span class="n">unique</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">RandomStateMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin to set random state</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">set_random_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sets the random_state member of the object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            random_state (int/np.random.RandomState/None): the random state initializer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="o">=</span> <span class="n">random_state</span>
        
        <span class="k">if</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">=</span> <span class="n">random_state</span>
        <span class="k">elif</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">=</span> <span class="n">random_state</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;random state cannot be initialized by &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">random_state</span><span class="p">))</span>
        

<span class="k">class</span> <span class="nc">ParameterCheckingMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin to check if parameters come from a valid range</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">check_in_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is in range</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name (str): the parameter name</span>
<span class="sd">            r (list-like(2)): the lower and upper bound of a range</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> outside the range [</span><span class="si">%f</span><span class="s2">,</span><span class="si">%f</span><span class="s2">] is not allowed: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">check_out_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is outside of range</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name (str): the parameter name</span>
<span class="sd">            r (list-like(2)): the lower and upper bound of a range</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> outside the range [</span><span class="si">%f</span><span class="s2">,</span><span class="si">%f</span><span class="s2">] is not allowed: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">x</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">check_less_or_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is less than or equal to value</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name (str): the parameter name</span>
<span class="sd">            val (numeric): value to compare to</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> greater than </span><span class="si">%f</span><span class="s2"> is not allowed: </span><span class="si">%f</span><span class="s2"> &gt; </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">check_less_or_equal_par</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name_x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">name_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is less than or equal to another parameter</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name_x (str): the parameter name</span>
<span class="sd">            y (numeric): the other parameter value</span>
<span class="sd">            name_y (str): the other parameter name</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> greater than parameter </span><span class="si">%s</span><span class="s2"> is not allowed: </span><span class="si">%f</span><span class="s2"> &gt; </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name_x</span><span class="p">,</span> <span class="n">name_y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">check_less</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is less than value</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name (str): the parameter name</span>
<span class="sd">            val (numeric): value to compare to</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> greater than or equal to </span><span class="si">%f</span><span class="s2"> is not allowed: </span><span class="si">%f</span><span class="s2"> &gt;= </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="nf">check_less_par</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name_x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">name_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is less than another parameter</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name_x (str): the parameter name</span>
<span class="sd">            y (numeric): the other parameter value</span>
<span class="sd">            name_y (str): the other parameter name</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> greater than or equal to parameter </span><span class="si">%s</span><span class="s2"> is not allowed: </span><span class="si">%f</span><span class="s2"> &gt;= </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name_x</span><span class="p">,</span> <span class="n">name_y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">check_greater_or_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is greater than or equal to value</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name (str): the parameter name</span>
<span class="sd">            val (numeric): value to compare to</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> less than </span><span class="si">%f</span><span class="s2"> is not allowed: </span><span class="si">%f</span><span class="s2"> &lt; </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="nf">check_greater_or_equal_par</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name_x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">name_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is less than or equal to another parameter</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name_x (str): the parameter name</span>
<span class="sd">            y (numeric): the other parameter value</span>
<span class="sd">            name_y (str): the other parameter name</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> less than parameter </span><span class="si">%s</span><span class="s2"> is not allowed: </span><span class="si">%f</span><span class="s2"> &lt; </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name_x</span><span class="p">,</span> <span class="n">name_y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">check_greater</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is greater than value</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name (str): the parameter name</span>
<span class="sd">            val (numeric): value to compare to</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> less than or equal to </span><span class="si">%f</span><span class="s2"> is not allowed: </span><span class="si">%f</span><span class="s2"> &lt; </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="nf">check_greater_par</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name_x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">name_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is greater than or equal to another parameter</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name_x (str): the parameter name</span>
<span class="sd">            y (numeric): the other parameter value</span>
<span class="sd">            name_y (str): the other parameter name</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> less than or equal to parameter </span><span class="si">%s</span><span class="s2"> is not allowed: </span><span class="si">%f</span><span class="s2"> &lt;= </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name_x</span><span class="p">,</span> <span class="n">name_y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">check_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is equal to value</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name (str): the parameter name</span>
<span class="sd">            val (numeric): value to compare to</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">val</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> equal to parameter </span><span class="si">%f</span><span class="s2"> is not allowed: </span><span class="si">%f</span><span class="s2"> == </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="nf">check_equal_par</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name_x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">name_y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is equal to another parameter</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name_x (str): the parameter name</span>
<span class="sd">            y (numeric): the other parameter value</span>
<span class="sd">            name_y (str): the other parameter name</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> equal to parameter </span><span class="si">%s</span><span class="s2"> is not allowed: </span><span class="si">%f</span><span class="s2"> == </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name_x</span><span class="p">,</span> <span class="n">name_y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">check_isin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if parameter is in list</span>
<span class="sd">        Args:</span>
<span class="sd">            x (numeric): the parameter value</span>
<span class="sd">            name (str): the parameter name</span>
<span class="sd">            l (list): list to check if parameter is in it</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter </span><span class="si">%s</span><span class="s2"> not in list </span><span class="si">%s</span><span class="s2"> is not allowed: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
    
    <span class="k">def</span> <span class="nf">check_n_jobs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check n_jobs parameter</span>
<span class="sd">        Args:</span>
<span class="sd">            x (int/None): number of jobs</span>
<span class="sd">            name (str): the parameter name</span>
<span class="sd">        Throws:</span>
<span class="sd">            ValueError</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value for parameter n_jobs is not allowed: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="k">class</span> <span class="nc">ParameterCombinationsMixin</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mixin to generate parameter combinations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">generate_parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dictionary</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations</span>
<span class="sd">        Args:</span>
<span class="sd">            dictionary (dict): dictionary of paramter ranges</span>
<span class="sd">            num (int): maximum number of combinations to generate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">combinations</span><span class="o">=</span> <span class="p">[</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dictionary</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span> <span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">list</span><span class="p">(</span><span class="n">dictionary</span><span class="o">.</span><span class="n">values</span><span class="p">())))]</span>
        <span class="k">if</span> <span class="n">num</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">combinations</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s1">&#39;random_state&#39;</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">combinations</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">combinations</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">NoiseFilter</span><span class="p">(</span><span class="n">StatisticsMixin</span><span class="p">,</span> <span class="n">ParameterCheckingMixin</span><span class="p">,</span> <span class="n">ParameterCombinationsMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parent class of noise filtering methods</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
        
    <span class="k">def</span> <span class="nf">remove_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes noise</span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.array): features</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return parameters</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: dictionary of parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="p">{}</span>
    
    <span class="k">def</span> <span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set parameters</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            params (dict): dictionary of parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span>
    
<div class="viewcode-block" id="TomekLinkRemoval"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.TomekLinkRemoval">[docs]</a><span class="k">class</span> <span class="nc">TomekLinkRemoval</span><span class="p">(</span><span class="n">NoiseFilter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tomek link removal</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smoteNoise0,</span>
<span class="sd">                     author = {Batista, Gustavo E. A. P. A. and Prati, Ronaldo C. and Monard, Maria Carolina},</span>
<span class="sd">                     title = {A Study of the Behavior of Several Methods for Balancing Machine Learning Training Data},</span>
<span class="sd">                     journal = {SIGKDD Explor. Newsl.},</span>
<span class="sd">                     issue_date = {June 2004},</span>
<span class="sd">                     volume = {6},</span>
<span class="sd">                     number = {1},</span>
<span class="sd">                     month = jun,</span>
<span class="sd">                     year = {2004},</span>
<span class="sd">                     issn = {1931-0145},</span>
<span class="sd">                     pages = {20--29},</span>
<span class="sd">                     numpages = {10},</span>
<span class="sd">                     url = {http://doi.acm.org/10.1145/1007730.1007735},</span>
<span class="sd">                     doi = {10.1145/1007730.1007735},</span>
<span class="sd">                     acmid = {1007735},</span>
<span class="sd">                     publisher = {ACM},</span>
<span class="sd">                     address = {New York, NY, USA}</span>
<span class="sd">                    } </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="TomekLinkRemoval.__init__"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.TomekLinkRemoval.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span> <span class="s1">&#39;remove_majority&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the noise filter.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            strategy (str): noise removal strategy: &#39;remove_majority&#39;/&#39;remove_both&#39;</span>
<span class="sd">            n_jobs (int): number of jobs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_isin</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="s1">&#39;strategy&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;remove_majority&#39;</span><span class="p">,</span> <span class="s1">&#39;remove_both&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">=</span> <span class="n">strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span></div>
    
<div class="viewcode-block" id="TomekLinkRemoval.remove_noise"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.TomekLinkRemoval.remove_noise">[docs]</a>    <span class="k">def</span> <span class="nf">remove_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes noise from dataset</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): features</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix, np.array: dataset after noise removal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running noise removal via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># using 2 neighbors because the first neighbor is the point itself</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># identify links</span>
        <span class="n">links</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]][</span><span class="mi">1</span><span class="p">]]:</span>
                    <span class="n">links</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                    
        <span class="c1"># determine links to be removed</span>
        <span class="n">to_remove</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;remove_majority&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;remove_both&#39;</span><span class="p">:</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s1">&#39;No Tomek link removal strategy </span><span class="si">%s</span><span class="s1"> implemented&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">)</span>
        
        <span class="n">to_remove</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">to_remove</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="CondensedNearestNeighbors"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.CondensedNearestNeighbors">[docs]</a><span class="k">class</span> <span class="nc">CondensedNearestNeighbors</span><span class="p">(</span><span class="n">NoiseFilter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Condensed nearest neighbors</span>
<span class="sd">    </span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @ARTICLE{condensed_nn, </span>
<span class="sd">                        author={Hart, P.}, </span>
<span class="sd">                        journal={IEEE Transactions on Information Theory}, </span>
<span class="sd">                        title={The condensed nearest neighbor rule (Corresp.)}, </span>
<span class="sd">                        year={1968}, </span>
<span class="sd">                        volume={14}, </span>
<span class="sd">                        number={3}, </span>
<span class="sd">                        pages={515-516}, </span>
<span class="sd">                        keywords={Pattern classification}, </span>
<span class="sd">                        doi={10.1109/TIT.1968.1054155}, </span>
<span class="sd">                        ISSN={0018-9448}, </span>
<span class="sd">                        month={May}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CondensedNearestNeighbors.__init__"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.CondensedNearestNeighbors.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the noise removing object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_jobs (int): number of jobs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span></div>
        
<div class="viewcode-block" id="CondensedNearestNeighbors.remove_noise"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.CondensedNearestNeighbors.remove_noise">[docs]</a>    <span class="k">def</span> <span class="nf">remove_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes noise from dataset</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): features</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix, np.array: dataset after noise removal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running noise removal via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># Initial result set consists of all minority samples and 1 majority sample</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        <span class="n">X_hat</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">],</span> <span class="n">X_maj</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">y_hat</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_hat</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]])</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X_maj</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        
        <span class="c1"># Adding misclassified majority elements repeatedly        </span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">knn</span><span class="o">=</span> <span class="n">KNeighborsClassifier</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">knn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_hat</span><span class="p">,</span> <span class="n">y_hat</span><span class="p">)</span>
            <span class="n">pred</span><span class="o">=</span> <span class="n">knn</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">pred</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">):</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">X_hat</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_hat</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">[</span><span class="n">pred</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]])</span>
                <span class="n">y_hat</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y_hat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_hat</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_hat</span><span class="p">))])</span>
                <span class="n">X_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pred</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">break</span>
        
        <span class="k">return</span> <span class="n">X_hat</span><span class="p">,</span> <span class="n">y_hat</span></div></div>

<div class="viewcode-block" id="OneSidedSelection"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.OneSidedSelection">[docs]</a><span class="k">class</span> <span class="nc">OneSidedSelection</span><span class="p">(</span><span class="n">NoiseFilter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smoteNoise0,</span>
<span class="sd">                     author = {Batista, Gustavo E. A. P. A. and Prati, Ronaldo C. and Monard, Maria Carolina},</span>
<span class="sd">                     title = {A Study of the Behavior of Several Methods for Balancing Machine Learning Training Data},</span>
<span class="sd">                     journal = {SIGKDD Explor. Newsl.},</span>
<span class="sd">                     issue_date = {June 2004},</span>
<span class="sd">                     volume = {6},</span>
<span class="sd">                     number = {1},</span>
<span class="sd">                     month = jun,</span>
<span class="sd">                     year = {2004},</span>
<span class="sd">                     issn = {1931-0145},</span>
<span class="sd">                     pages = {20--29},</span>
<span class="sd">                     numpages = {10},</span>
<span class="sd">                     url = {http://doi.acm.org/10.1145/1007730.1007735},</span>
<span class="sd">                     doi = {10.1145/1007730.1007735},</span>
<span class="sd">                     acmid = {1007735},</span>
<span class="sd">                     publisher = {ACM},</span>
<span class="sd">                     address = {New York, NY, USA}</span>
<span class="sd">                    } </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="OneSidedSelection.__init__"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.OneSidedSelection.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the noise removal object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_jobs (int): number of jobs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span></div>
        
<div class="viewcode-block" id="OneSidedSelection.remove_noise"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.OneSidedSelection.remove_noise">[docs]</a>    <span class="k">def</span> <span class="nf">remove_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes noise</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): features</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix, np.array: cleaned features and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running noise removal via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">t</span><span class="o">=</span> <span class="n">TomekLinkRemoval</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">X0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">cnn</span><span class="o">=</span> <span class="n">CondensedNearestNeighbors</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">cnn</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">X0</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="CNNTomekLinks"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.CNNTomekLinks">[docs]</a><span class="k">class</span> <span class="nc">CNNTomekLinks</span><span class="p">(</span><span class="n">NoiseFilter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smoteNoise0,</span>
<span class="sd">                     author = {Batista, Gustavo E. A. P. A. and Prati, Ronaldo C. and Monard, Maria Carolina},</span>
<span class="sd">                     title = {A Study of the Behavior of Several Methods for Balancing Machine Learning Training Data},</span>
<span class="sd">                     journal = {SIGKDD Explor. Newsl.},</span>
<span class="sd">                     issue_date = {June 2004},</span>
<span class="sd">                     volume = {6},</span>
<span class="sd">                     number = {1},</span>
<span class="sd">                     month = jun,</span>
<span class="sd">                     year = {2004},</span>
<span class="sd">                     issn = {1931-0145},</span>
<span class="sd">                     pages = {20--29},</span>
<span class="sd">                     numpages = {10},</span>
<span class="sd">                     url = {http://doi.acm.org/10.1145/1007730.1007735},</span>
<span class="sd">                     doi = {10.1145/1007730.1007735},</span>
<span class="sd">                     acmid = {1007735},</span>
<span class="sd">                     publisher = {ACM},</span>
<span class="sd">                     address = {New York, NY, USA}</span>
<span class="sd">                    } </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="CNNTomekLinks.__init__"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.CNNTomekLinks.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the noise removal object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span></div>
        
<div class="viewcode-block" id="CNNTomekLinks.remove_noise"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.CNNTomekLinks.remove_noise">[docs]</a>    <span class="k">def</span> <span class="nf">remove_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes noise</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): features</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix, np.array: cleaned features and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running noise removal via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">c</span><span class="o">=</span> <span class="n">CondensedNearestNeighbors</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">X0</span><span class="p">,</span> <span class="n">y0</span><span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">t</span><span class="o">=</span> <span class="n">TomekLinkRemoval</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">X0</span><span class="p">,</span> <span class="n">y0</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="NeighborhoodCleaningRule"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.NeighborhoodCleaningRule">[docs]</a><span class="k">class</span> <span class="nc">NeighborhoodCleaningRule</span><span class="p">(</span><span class="n">NoiseFilter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smoteNoise0,</span>
<span class="sd">                     author = {Batista, Gustavo E. A. P. A. and Prati, Ronaldo C. and Monard, Maria Carolina},</span>
<span class="sd">                     title = {A Study of the Behavior of Several Methods for Balancing Machine Learning Training Data},</span>
<span class="sd">                     journal = {SIGKDD Explor. Newsl.},</span>
<span class="sd">                     issue_date = {June 2004},</span>
<span class="sd">                     volume = {6},</span>
<span class="sd">                     number = {1},</span>
<span class="sd">                     month = jun,</span>
<span class="sd">                     year = {2004},</span>
<span class="sd">                     issn = {1931-0145},</span>
<span class="sd">                     pages = {20--29},</span>
<span class="sd">                     numpages = {10},</span>
<span class="sd">                     url = {http://doi.acm.org/10.1145/1007730.1007735},</span>
<span class="sd">                     doi = {10.1145/1007730.1007735},</span>
<span class="sd">                     acmid = {1007735},</span>
<span class="sd">                     publisher = {ACM},</span>
<span class="sd">                     address = {New York, NY, USA}</span>
<span class="sd">                    } </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="NeighborhoodCleaningRule.__init__"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.NeighborhoodCleaningRule.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the noise removal object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span></div>
        
<div class="viewcode-block" id="NeighborhoodCleaningRule.remove_noise"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.NeighborhoodCleaningRule.remove_noise">[docs]</a>    <span class="k">def</span> <span class="nf">remove_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes noise</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): features</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix, np.array: cleaned features and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running noise removal via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># fitting nearest neighbors with proposed parameter</span>
        <span class="c1"># using 4 neighbors because the first neighbor is the point itself</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># identifying the samples to be removed</span>
        <span class="n">to_remove</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span> <span class="ow">and</span> <span class="n">mode</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]])</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                <span class="c1"># if sample i is majority and the decision based on neighbors is minority</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span> <span class="ow">and</span> <span class="n">mode</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]])</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">:</span>
                <span class="c1"># if sample i is minority and the decision based on neighbors is majority</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">:</span>
                        <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        
        <span class="c1"># removing the noisy samples and returning the results</span>
        <span class="n">to_remove</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">to_remove</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="EditedNearestNeighbors"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.EditedNearestNeighbors">[docs]</a><span class="k">class</span> <span class="nc">EditedNearestNeighbors</span><span class="p">(</span><span class="n">NoiseFilter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smoteNoise0,</span>
<span class="sd">                     author = {Batista, Gustavo E. A. P. A. and Prati, Ronaldo C. and Monard, Maria Carolina},</span>
<span class="sd">                     title = {A Study of the Behavior of Several Methods for Balancing Machine Learning Training Data},</span>
<span class="sd">                     journal = {SIGKDD Explor. Newsl.},</span>
<span class="sd">                     issue_date = {June 2004},</span>
<span class="sd">                     volume = {6},</span>
<span class="sd">                     number = {1},</span>
<span class="sd">                     month = jun,</span>
<span class="sd">                     year = {2004},</span>
<span class="sd">                     issn = {1931-0145},</span>
<span class="sd">                     pages = {20--29},</span>
<span class="sd">                     numpages = {10},</span>
<span class="sd">                     url = {http://doi.acm.org/10.1145/1007730.1007735},</span>
<span class="sd">                     doi = {10.1145/1007730.1007735},</span>
<span class="sd">                     acmid = {1007735},</span>
<span class="sd">                     publisher = {ACM},</span>
<span class="sd">                     address = {New York, NY, USA}</span>
<span class="sd">                    } </span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="EditedNearestNeighbors.__init__"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.EditedNearestNeighbors.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove</span><span class="o">=</span> <span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the noise removal object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            remove (str): class to remove from &#39;both&#39;/&#39;min&#39;/&#39;maj&#39;</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_isin</span><span class="p">(</span><span class="n">remove</span><span class="p">,</span> <span class="s1">&#39;remove&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;maj&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="o">=</span> <span class="n">remove</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span></div>

<div class="viewcode-block" id="EditedNearestNeighbors.remove_noise"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.EditedNearestNeighbors.remove_noise">[docs]</a>    <span class="k">def</span> <span class="nf">remove_noise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes noise</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): features</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix, np.array: cleaned features and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running noise removal via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">to_remove</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">mode</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span> <span class="o">==</span> <span class="s1">&#39;both&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remove</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span> <span class="ow">and</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">remove</span> <span class="o">==</span> <span class="s1">&#39;maj&#39;</span> <span class="ow">and</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">):</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="EditedNearestNeighbors.get_params"><a class="viewcode-back" href="../../noise_filters.html#smote_variants.EditedNearestNeighbors.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get noise removal parameters</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: dictionary of parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;remove&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">}</span></div></div>

<span class="k">class</span> <span class="nc">OverSampling</span><span class="p">(</span><span class="n">StatisticsMixin</span><span class="p">,</span> <span class="n">ParameterCheckingMixin</span><span class="p">,</span> <span class="n">ParameterCombinationsMixin</span><span class="p">,</span> <span class="n">RandomStateMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of oversampling methods</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[]</span>
        
    <span class="n">cat_noise_removal</span><span class="o">=</span> <span class="s1">&#39;NR&#39;</span>
    <span class="n">cat_dim_reduction</span><span class="o">=</span> <span class="s1">&#39;DR&#39;</span>
    <span class="n">cat_uses_classifier</span><span class="o">=</span> <span class="s1">&#39;Clas&#39;</span>
    <span class="n">cat_sample_componentwise</span><span class="o">=</span> <span class="s1">&#39;SCmp&#39;</span>
    <span class="n">cat_sample_ordinary</span><span class="o">=</span> <span class="s1">&#39;SO&#39;</span>
    <span class="n">cat_sample_copy</span><span class="o">=</span> <span class="s1">&#39;SCpy&#39;</span>
    <span class="n">cat_memetic</span><span class="o">=</span> <span class="s1">&#39;M&#39;</span>
    <span class="n">cat_density_estimation</span><span class="o">=</span> <span class="s1">&#39;DE&#39;</span>
    <span class="n">cat_density_based</span><span class="o">=</span> <span class="s1">&#39;DB&#39;</span>
    <span class="n">cat_extensive</span><span class="o">=</span> <span class="s1">&#39;Ex&#39;</span>
    <span class="n">cat_changes_majority</span><span class="o">=</span> <span class="s1">&#39;CM&#39;</span>
    <span class="n">cat_uses_clustering</span><span class="o">=</span> <span class="s1">&#39;Clus&#39;</span>
    <span class="n">cat_borderline</span><span class="o">=</span> <span class="s1">&#39;BL&#39;</span>
    <span class="n">cat_application</span><span class="o">=</span> <span class="s1">&#39;A&#39;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="p">,</span> <span class="n">n_maj</span><span class="p">,</span> <span class="n">n_min</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the number of samples to generate</span>
<span class="sd">        Args:</span>
<span class="sd">            strategy (str/float): if float, the fraction of the difference of</span>
<span class="sd">                                    the minority and majority numbers to generate, like</span>
<span class="sd">                                    0.1 means that 10% of the difference will be generated</span>
<span class="sd">                                    if str, like &#39;min2maj&#39;, the minority class will be upsampled</span>
<span class="sd">                                    to match the cardinality of the majority class</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">max</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">((</span><span class="n">n_maj</span> <span class="o">-</span> <span class="n">n_min</span><span class="p">)</span><span class="o">*</span><span class="n">strategy</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Value </span><span class="si">%s</span><span class="s2"> for parameter strategy is not supported&quot;</span> <span class="o">%</span> <span class="n">strategy</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">sample_between_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample randomly along the line between two points.</span>
<span class="sd">        Args:</span>
<span class="sd">            x (np.array): point 1</span>
<span class="sd">            y (np.array): point 2</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.array: the new sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">sample_between_points_componentwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample each dimension separately between the two points.</span>
<span class="sd">        Args:</span>
<span class="sd">            x (np.array): point 1</span>
<span class="sd">            y (np.array): point 2</span>
<span class="sd">            mask (np.array): array of 0,1s - specifies which dimensions to sample</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.array: the new sample being generated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="n">mask</span>
    
    <span class="k">def</span> <span class="nf">sample_by_jittering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">std</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample by jittering.</span>
<span class="sd">        Args:</span>
<span class="sd">            x (np.array): base point</span>
<span class="sd">            std (float): standard deviation</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.array: the new sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="mf">2.0</span><span class="o">*</span><span class="n">std</span>
    
    <span class="k">def</span> <span class="nf">sample_by_jittering_componentwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">std</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample by jittering componentwise.</span>
<span class="sd">        Args:</span>
<span class="sd">            x (np.array): base point</span>
<span class="sd">            std (np.array): standard deviation</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.array: the new sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="mf">2.0</span> <span class="o">*</span> <span class="n">std</span>
    
    <span class="k">def</span> <span class="nf">sample_by_gaussian_jittering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">std</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample by Gaussian jittering</span>
<span class="sd">        Args:</span>
<span class="sd">            x (np.array): base point</span>
<span class="sd">            std (np.array): standard deviation</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.array: the new sample</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">std</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The samplig function reimplemented in child classes</span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): features</span>
<span class="sd">            y (np.array): labels</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix, np.array: sampled X and y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span>
    
    <span class="k">def</span> <span class="nf">sample_with_timing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">begin</span><span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;runtime: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span>
    
    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms new data according to the possible transformation implemented</span>
<span class="sd">        by the function &quot;sample&quot;.</span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): features</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix: transformed features</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">X</span>
    
    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the parameters of the object as a dictionary.</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set parameters</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            params (dict): dictionary of parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span>
    
    <span class="k">def</span> <span class="nf">descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            str: JSON description of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">())))</span>
    
    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">UnderSampling</span><span class="p">(</span><span class="n">StatisticsMixin</span><span class="p">,</span> <span class="n">ParameterCheckingMixin</span><span class="p">,</span> <span class="n">ParameterCombinationsMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of undersampling approaches.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructorm</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Carry out undersampling</span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): features</span>
<span class="sd">            y (np.array): labels</span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix, np.array: sampled X and y</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the parameters of the object as a dictionary.</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>
    
    <span class="k">def</span> <span class="nf">descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            str: JSON description of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">())))</span>

<div class="viewcode-block" id="NoSMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NoSMOTE">[docs]</a><span class="k">class</span> <span class="nc">NoSMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The goal of this class is to provide a functionality to send data through</span>
<span class="sd">    on any model selection/evaluation pipeline with no oversampling carried</span>
<span class="sd">    out. It can be used to get baseline estimates on preformance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[]</span>
    
<div class="viewcode-block" id="NoSMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NoSMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the NoSMOTE object.</span>
<span class="sd">        </span>
<span class="sd">        random_state (int/np.random.RandomState/None): dummy parameter for the</span>
<span class="sd">                        compatibility of interfaces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="NoSMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NoSMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({})</span></div>
                
<div class="viewcode-block" id="NoSMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NoSMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="NoSMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NoSMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span></div></div>


<div class="viewcode-block" id="SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE">[docs]</a><span class="k">class</span> <span class="nc">SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smote,</span>
<span class="sd">                author={Chawla, N. V. and Bowyer, K. W. and Hall, L. O. and Kegelmeyer, W. P.},</span>
<span class="sd">                title={{SMOTE}: synthetic minority over-sampling technique},</span>
<span class="sd">                journal={Journal of Artificial Intelligence Research},</span>
<span class="sd">                volume={16},</span>
<span class="sd">                year={2002},</span>
<span class="sd">                pages={321--357}</span>
<span class="sd">              }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the SMOTE object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample e.g. 1.0 \</span>
<span class="sd">            means that after sampling the number of minority samples will be equal to the number of \</span>
<span class="sd">            majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor technique</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
                
<div class="viewcode-block" id="SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># determining the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting the model</span>
        <span class="n">n_neigh</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neigh</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">base_indices</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))),</span> <span class="n">num_to_sample</span><span class="p">)</span>
        <span class="n">neighbor_indices</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_neigh</span><span class="p">)),</span> <span class="n">num_to_sample</span><span class="p">)</span>
        
        <span class="n">X_base</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">base_indices</span><span class="p">]</span>
        <span class="n">X_neighbor</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">base_indices</span><span class="p">,</span> <span class="n">neighbor_indices</span><span class="p">]]</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="n">X_base</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">X_neighbor</span> <span class="o">-</span> <span class="n">X_base</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span><span class="o">*</span><span class="n">num_to_sample</span><span class="p">)])</span></div>
    
<div class="viewcode-block" id="SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SMOTE_TomekLinks"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_TomekLinks">[docs]</a><span class="k">class</span> <span class="nc">SMOTE_TomekLinks</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smote_tomeklinks_enn,</span>
<span class="sd">                     author = {Batista, Gustavo E. A. P. A. and Prati, Ronaldo C. and Monard, Maria Carolina},</span>
<span class="sd">                     title = {A Study of the Behavior of Several Methods for Balancing Machine Learning Training Data},</span>
<span class="sd">                     journal = {SIGKDD Explor. Newsl.},</span>
<span class="sd">                     issue_date = {June 2004},</span>
<span class="sd">                     volume = {6},</span>
<span class="sd">                     number = {1},</span>
<span class="sd">                     month = jun,</span>
<span class="sd">                     year = {2004},</span>
<span class="sd">                     issn = {1931-0145},</span>
<span class="sd">                     pages = {20--29},</span>
<span class="sd">                     numpages = {10},</span>
<span class="sd">                     url = {http://doi.acm.org/10.1145/1007730.1007735},</span>
<span class="sd">                     doi = {10.1145/1007730.1007735},</span>
<span class="sd">                     acmid = {1007735},</span>
<span class="sd">                     publisher = {ACM},</span>
<span class="sd">                     address = {New York, NY, USA},</span>
<span class="sd">                    } </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE_TomekLinks.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_TomekLinks.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the SMOTE object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to \</span>
<span class="sd">            sample e.g. 1.0 means that after sampling the number of minority samples \</span>
<span class="sd">            will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor technique</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>

<div class="viewcode-block" id="SMOTE_TomekLinks.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_TomekLinks.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SMOTE</span><span class="o">.</span><span class="n">parameter_combinations</span><span class="p">()</span></div>

<div class="viewcode-block" id="SMOTE_TomekLinks.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_TomekLinks.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">smote</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">X_new</span><span class="p">,</span> <span class="n">y_new</span><span class="o">=</span> <span class="n">smote</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">t</span><span class="o">=</span> <span class="n">TomekLinkRemoval</span><span class="p">(</span><span class="n">strategy</span><span class="o">=</span> <span class="s1">&#39;remove_both&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        
        <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">y_new</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_samp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;All samples have been removed, returning original dataset.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span></div>
    
<div class="viewcode-block" id="SMOTE_TomekLinks.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_TomekLinks.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>
    
<div class="viewcode-block" id="SMOTE_ENN"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_ENN">[docs]</a><span class="k">class</span> <span class="nc">SMOTE_ENN</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smote_tomeklinks_enn,</span>
<span class="sd">                     author = {Batista, Gustavo E. A. P. A. and Prati, Ronaldo C. and Monard, Maria Carolina},</span>
<span class="sd">                     title = {A Study of the Behavior of Several Methods for Balancing Machine Learning Training Data},</span>
<span class="sd">                     journal = {SIGKDD Explor. Newsl.},</span>
<span class="sd">                     issue_date = {June 2004},</span>
<span class="sd">                     volume = {6},</span>
<span class="sd">                     number = {1},</span>
<span class="sd">                     month = jun,</span>
<span class="sd">                     year = {2004},</span>
<span class="sd">                     issn = {1931-0145},</span>
<span class="sd">                     pages = {20--29},</span>
<span class="sd">                     numpages = {10},</span>
<span class="sd">                     url = {http://doi.acm.org/10.1145/1007730.1007735},</span>
<span class="sd">                     doi = {10.1145/1007730.1007735},</span>
<span class="sd">                     acmid = {1007735},</span>
<span class="sd">                     publisher = {ACM},</span>
<span class="sd">                     address = {New York, NY, USA},</span>
<span class="sd">                    } </span>

<span class="sd">    Notes:</span>
<span class="sd">        * Can remove too many of minority samples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE_ENN.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_ENN.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the SMOTE object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor technique</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SMOTE_ENN.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_ENN.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SMOTE</span><span class="o">.</span><span class="n">parameter_combinations</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="SMOTE_ENN.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_ENN.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">smote</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">X_new</span><span class="p">,</span> <span class="n">y_new</span><span class="o">=</span> <span class="n">smote</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">enn</span><span class="o">=</span> <span class="n">EditedNearestNeighbors</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">enn</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">X_new</span><span class="p">,</span> <span class="n">y_new</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SMOTE_ENN.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_ENN.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="Borderline_SMOTE1"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Borderline_SMOTE1">[docs]</a><span class="k">class</span> <span class="nc">Borderline_SMOTE1</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{borderlineSMOTE,</span>
<span class="sd">                            author=&quot;Han, Hui</span>
<span class="sd">                            and Wang, Wen-Yuan</span>
<span class="sd">                            and Mao, Bing-Huan&quot;,</span>
<span class="sd">                            editor=&quot;Huang, De-Shuang</span>
<span class="sd">                            and Zhang, Xiao-Ping</span>
<span class="sd">                            and Huang, Guang-Bin&quot;,</span>
<span class="sd">                            title=&quot;Borderline-SMOTE: A New Over-Sampling Method in Imbalanced Data Sets Learning&quot;,</span>
<span class="sd">                            booktitle=&quot;Advances in Intelligent Computing&quot;,</span>
<span class="sd">                            year=&quot;2005&quot;,</span>
<span class="sd">                            publisher=&quot;Springer Berlin Heidelberg&quot;,</span>
<span class="sd">                            address=&quot;Berlin, Heidelberg&quot;,</span>
<span class="sd">                            pages=&quot;878--887&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-540-31902-3&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">]</span>
    
<div class="viewcode-block" id="Borderline_SMOTE1.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Borderline_SMOTE1.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">k_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor technique for determining the borderline</span>
<span class="sd">            k_neighbors (int): control parameter of the nearest neighbor technique for sampling</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k_neighbors</span><span class="p">,</span> <span class="s1">&#39;k_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_neighbors</span><span class="o">=</span> <span class="n">k_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Borderline_SMOTE1.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Borderline_SMOTE1.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="Borderline_SMOTE1.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Borderline_SMOTE1.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># determining number of samples to be generated</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># fitting model</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># determining minority samples in danger</span>
        <span class="n">noise</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">danger</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">):</span>
                <span class="n">noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]])</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">:</span>
                <span class="n">danger</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">X_danger</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">danger</span><span class="p">]</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">noise</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_danger</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;No samples in danger&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># fitting nearest neighbors model to minority samples</span>
        <span class="n">k_neigh</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">k_neigh</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="c1"># extracting neighbors of samples in danger</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_danger</span><span class="p">)</span>
        
        <span class="c1"># generating samples near points in danger</span>
        <span class="n">base_indices</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_danger</span><span class="p">))),</span> <span class="n">num_to_sample</span><span class="p">)</span>
        <span class="n">neighbor_indices</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k_neigh</span><span class="p">)),</span> <span class="n">num_to_sample</span><span class="p">)</span>
        
        <span class="n">X_base</span><span class="o">=</span> <span class="n">X_danger</span><span class="p">[</span><span class="n">base_indices</span><span class="p">]</span>
        <span class="n">X_neighbor</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">base_indices</span><span class="p">,</span> <span class="n">neighbor_indices</span><span class="p">]]</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="n">X_base</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">X_neighbor</span> <span class="o">-</span> <span class="n">X_base</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span><span class="o">*</span><span class="n">num_to_sample</span><span class="p">)])</span></div>
    
<div class="viewcode-block" id="Borderline_SMOTE1.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Borderline_SMOTE1.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;k_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>
    
<div class="viewcode-block" id="Borderline_SMOTE2"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Borderline_SMOTE2">[docs]</a><span class="k">class</span> <span class="nc">Borderline_SMOTE2</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{borderlineSMOTE,</span>
<span class="sd">                            author=&quot;Han, Hui</span>
<span class="sd">                            and Wang, Wen-Yuan</span>
<span class="sd">                            and Mao, Bing-Huan&quot;,</span>
<span class="sd">                            editor=&quot;Huang, De-Shuang</span>
<span class="sd">                            and Zhang, Xiao-Ping</span>
<span class="sd">                            and Huang, Guang-Bin&quot;,</span>
<span class="sd">                            title=&quot;Borderline-SMOTE: A New Over-Sampling Method in Imbalanced Data Sets Learning&quot;,</span>
<span class="sd">                            booktitle=&quot;Advances in Intelligent Computing&quot;,</span>
<span class="sd">                            year=&quot;2005&quot;,</span>
<span class="sd">                            publisher=&quot;Springer Berlin Heidelberg&quot;,</span>
<span class="sd">                            address=&quot;Berlin, Heidelberg&quot;,</span>
<span class="sd">                            pages=&quot;878--887&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-540-31902-3&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">]</span>
    
<div class="viewcode-block" id="Borderline_SMOTE2.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Borderline_SMOTE2.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">k_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor technique for determining the borderline</span>
<span class="sd">            k_neighbors (int): control parameter of the nearest neighbor technique for sampling</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k_neighbors</span><span class="p">,</span> <span class="s1">&#39;k_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k_neighbors</span><span class="o">=</span> <span class="n">k_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Borderline_SMOTE2.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Borderline_SMOTE2.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="Borderline_SMOTE2.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Borderline_SMOTE2.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># determining number of samples to be generated</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># fitting nearest neighbors model</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># determining minority samples in danger</span>
        <span class="n">noise</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">danger</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">==</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">):</span>
                <span class="n">noise</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mode</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]])</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">:</span>
                <span class="n">danger</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">X_danger</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">danger</span><span class="p">]</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">noise</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_danger</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;No samples in danger&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># fitting nearest neighbors model to minority samples</span>
        <span class="n">k_neigh</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_neighbors</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">k_neigh</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_danger</span><span class="p">)</span>
        
        <span class="c1"># generating the samples</span>
        <span class="n">base_indices</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_danger</span><span class="p">))),</span> <span class="n">num_to_sample</span><span class="p">)</span>
        <span class="n">neighbor_indices</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k_neigh</span><span class="p">)),</span> <span class="n">num_to_sample</span><span class="p">)</span>
        
        <span class="n">X_base</span><span class="o">=</span> <span class="n">X_danger</span><span class="p">[</span><span class="n">base_indices</span><span class="p">]</span>
        <span class="n">X_neighbor</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">base_indices</span><span class="p">,</span> <span class="n">neighbor_indices</span><span class="p">]]</span>
        <span class="n">diff</span><span class="o">=</span> <span class="n">X_neighbor</span> <span class="o">-</span> <span class="n">X_base</span>
        <span class="n">r</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">r</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="n">neighbor_indices</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span><span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="n">neighbor_indices</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span><span class="o">*</span><span class="mf">0.5</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="n">X_base</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span><span class="o">*</span><span class="n">num_to_sample</span><span class="p">)])</span></div>
    
<div class="viewcode-block" id="Borderline_SMOTE2.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Borderline_SMOTE2.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;k_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="ADASYN"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADASYN">[docs]</a><span class="k">class</span> <span class="nc">ADASYN</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @inproceedings{adasyn,</span>
<span class="sd">                          author={He, H. and Bai, Y. and Garcia, E. A. and Li, S.},</span>
<span class="sd">                          title={{ADASYN}: adaptive synthetic sampling approach for imbalanced learning},</span>
<span class="sd">                          booktitle={Proceedings of IJCNN},</span>
<span class="sd">                          year={2008},</span>
<span class="sd">                          pages={1322--1328}</span>
<span class="sd">                        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_based</span><span class="p">]</span>
    
<div class="viewcode-block" id="ADASYN.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADASYN.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">d_th</span><span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor component</span>
<span class="sd">            d_th (float): tolerated deviation level from balancedness</span>
<span class="sd">            beta (float): target level of balancedness, same as proportion in other techniques</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">d_th</span><span class="p">,</span> <span class="s1">&#39;d_th&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">beta</span><span class="p">,</span> <span class="s1">&#39;beta&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_th</span><span class="o">=</span> <span class="n">d_th</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">=</span> <span class="n">beta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="ADASYN.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADASYN.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> 
                                                    <span class="s1">&#39;d_th&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.9</span><span class="p">],</span> 
                                                    <span class="s1">&#39;beta&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="ADASYN.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADASYN.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># extracting minority samples</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># checking if sampling is needed</span>
        <span class="n">m_min</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">m_maj</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">m_min</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="p">(</span><span class="n">m_maj</span> <span class="o">-</span> <span class="n">m_min</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">d</span><span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">m_min</span><span class="p">)</span><span class="o">/</span><span class="n">m_maj</span>
        <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_th</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># fitting nearest neighbors model to all samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># determining the distribution of points to be generated</span>
        <span class="n">r</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
            <span class="n">r</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">)</span>
        <span class="n">r</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">r</span><span class="o">=</span> <span class="n">r</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">r</span><span class="p">)):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;not enough non-noise samples for oversampling&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># fitting nearest neighbors models to minority samples</span>
        <span class="n">n_neigh</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neigh</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># sampling points</span>
        <span class="n">base_indices</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))),</span> <span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span><span class="n">r</span><span class="p">)</span>
        <span class="n">neighbor_indices</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_neigh</span><span class="p">)),</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">))</span>
        
        <span class="n">X_base</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">base_indices</span><span class="p">]</span>
        <span class="n">X_neighbor</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">base_indices</span><span class="p">,</span> <span class="n">neighbor_indices</span><span class="p">]]</span>
        <span class="n">diff</span><span class="o">=</span> <span class="n">X_neighbor</span> <span class="o">-</span> <span class="n">X_base</span>
        <span class="n">r</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="n">X_base</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">diff</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span><span class="o">*</span><span class="nb">int</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="ADASYN.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADASYN.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;d_th&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_th</span><span class="p">,</span> 
                <span class="s1">&#39;beta&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>
    
<div class="viewcode-block" id="AHC"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AHC">[docs]</a><span class="k">class</span> <span class="nc">AHC</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{AHC,</span>
<span class="sd">                    title = &quot;Learning from imbalanced data in surveillance of nosocomial infection&quot;,</span>
<span class="sd">                    journal = &quot;Artificial Intelligence in Medicine&quot;,</span>
<span class="sd">                    volume = &quot;37&quot;,</span>
<span class="sd">                    number = &quot;1&quot;,</span>
<span class="sd">                    pages = &quot;7 - 18&quot;,</span>
<span class="sd">                    year = &quot;2006&quot;,</span>
<span class="sd">                    note = &quot;Intelligent Data Analysis in Medicine&quot;,</span>
<span class="sd">                    issn = &quot;0933-3657&quot;,</span>
<span class="sd">                    doi = &quot;https://doi.org/10.1016/j.artmed.2005.03.002&quot;,</span>
<span class="sd">                    url = &quot;http://www.sciencedirect.com/science/article/pii/S0933365705000850&quot;,</span>
<span class="sd">                    author = &quot;Gilles Cohen and Mélanie Hilario and Hugo Sax and Stéphane Hugonnet and Antoine Geissbuhler&quot;,</span>
<span class="sd">                    keywords = &quot;Nosocomial infection, Machine learning, Support vector machines, Data imbalance&quot;</span>
<span class="sd">                    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_application</span><span class="p">]</span>
    
<div class="viewcode-block" id="AHC.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AHC.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            strategy (str): which class to sample (min/maj/minmaj)</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_isin</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="s1">&#39;strategy&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;maj&#39;</span><span class="p">,</span> <span class="s1">&#39;minmaj&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">=</span> <span class="n">strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="AHC.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AHC.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;maj&#39;</span><span class="p">,</span> <span class="s1">&#39;minmaj&#39;</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="AHC.sample_majority"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AHC.sample_majority">[docs]</a>    <span class="k">def</span> <span class="nf">sample_majority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">n_clusters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample the majority class</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): majority samples</span>
<span class="sd">            n_clusters (int): number of clusters to find</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: downsampled vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kmeans</span><span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span></div>
    
<div class="viewcode-block" id="AHC.sample_minority"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AHC.sample_minority">[docs]</a>    <span class="k">def</span> <span class="nf">sample_minority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sampling the minority class</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): minority samples</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: the oversampled set of vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ac</span><span class="o">=</span> <span class="n">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ac</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">n_samples</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">cc</span><span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ac</span><span class="o">.</span><span class="n">children_</span><span class="p">)</span>
        <span class="n">weights</span><span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">ac</span><span class="o">.</span><span class="n">children_</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">cluster_centers</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Extract cluster centers</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                children (np.array): indices of children</span>
<span class="sd">                i (int): index to process</span>
<span class="sd">                cc (np.array): cluster centers</span>
<span class="sd">                weights (np.array): cluster weights</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                int, float: new cluster center, new weight</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n_samples</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mf">1.0</span>
            
            <span class="k">if</span> <span class="n">cc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">n_samples</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span><span class="p">,</span> <span class="n">w_a</span><span class="o">=</span> <span class="n">cluster_centers</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">children</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">n_samples</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cc</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">w_b</span><span class="o">=</span> <span class="n">cluster_centers</span><span class="p">(</span><span class="n">children</span><span class="p">,</span> <span class="n">children</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">n_samples</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">cc</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
                <span class="n">cc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">n_samples</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">w_a</span><span class="o">*</span><span class="n">a</span> <span class="o">+</span> <span class="n">w_b</span><span class="o">*</span><span class="n">b</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">w_a</span> <span class="o">+</span> <span class="n">w_b</span><span class="p">)</span>
                <span class="n">weights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">n_samples</span><span class="p">]</span><span class="o">=</span> <span class="n">w_a</span> <span class="o">+</span> <span class="n">w_b</span>
                
            <span class="k">return</span> <span class="n">cc</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">n_samples</span><span class="p">],</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">n_samples</span><span class="p">]</span>
        
        <span class="n">cluster_centers</span><span class="p">(</span><span class="n">ac</span><span class="o">.</span><span class="n">children_</span><span class="p">,</span> <span class="n">ac</span><span class="o">.</span><span class="n">children_</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">cc</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">cc</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="AHC.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AHC.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># extracting minority samples</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;maj&#39;</span><span class="p">:</span>
            <span class="n">X_maj_resampled</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_majority</span><span class="p">(</span><span class="n">X_maj</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj_resampled</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj_resampled</span><span class="p">))])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
            <span class="n">X_min_resampled</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_minority</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_min_resampled</span><span class="p">,</span> <span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min_resampled</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">))])</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;minmaj&#39;</span><span class="p">:</span>
            <span class="n">X_min_resampled</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_minority</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
            <span class="n">X_maj_resampled</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_majority</span><span class="p">(</span><span class="n">X_maj</span><span class="p">,</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min_resampled</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)]))</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_min_resampled</span><span class="p">,</span> <span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj_resampled</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min_resampled</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj_resampled</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="AHC.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AHC.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="LLE_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LLE_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">LLE_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{lle_smote, </span>
<span class="sd">                            author={Wang, J. and Xu, M. and Wang, H. and Zhang, J.}, </span>
<span class="sd">                            booktitle={2006 8th international Conference on Signal Processing}, </span>
<span class="sd">                            title={Classification of Imbalanced Data by Using the SMOTE Algorithm and Locally Linear Embedding}, </span>
<span class="sd">                            year={2006}, </span>
<span class="sd">                            volume={3}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={}, </span>
<span class="sd">                            keywords={artificial intelligence;biomedical imaging;medical computing;imbalanced data classification;SMOTE algorithm;locally linear embedding;medical imaging intelligence;synthetic minority oversampling technique;high-dimensional data;low-dimensional space;Biomedical imaging;Back;Training data;Data mining;Biomedical engineering;Research and development;Electronic mail;Pattern recognition;Performance analysis;Classification algorithms}, </span>
<span class="sd">                            doi={10.1109/ICOSP.2006.345752}, </span>
<span class="sd">                            ISSN={2164-5221}, </span>
<span class="sd">                            month={Nov}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * There might be numerical issues if the nearest neighbors contain some element multiple times.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_dim_reduction</span><span class="p">]</span>
    
<div class="viewcode-block" id="LLE_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LLE_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor component</span>
<span class="sd">            n_components (int): dimensionality of the embedding space</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_components</span><span class="p">,</span> <span class="s1">&#39;n_components&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="LLE_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LLE_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="LLE_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LLE_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># determine the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># extracting minority samples</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># do the locally linear embedding</span>
        <span class="n">lle</span><span class="o">=</span> <span class="n">LocallyLinearEmbedding</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">lle</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">X_min_transformed</span><span class="o">=</span> <span class="n">lle</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># fitting the nearest neighbors model for sampling</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min_transformed</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min_transformed</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">solve_for_weights</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">Z</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Solve for locally linear embedding weights</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                xi (np.array): vector</span>
<span class="sd">                Z (np.matrix): matrix of neighbors in rows</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                np.array: reconstruction weights</span>
<span class="sd">                </span>
<span class="sd">            Following https://cs.nyu.edu/~roweis/lle/algorithm.html</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">Z</span><span class="o">=</span> <span class="n">Z</span> <span class="o">-</span> <span class="n">xi</span>
            <span class="n">Z</span><span class="o">=</span> <span class="n">Z</span><span class="o">.</span><span class="n">T</span>
            <span class="n">C</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Z</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">w</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">)))</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e8</span><span class="p">:</span>
                    <span class="n">w</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">w</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">C</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">w</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">xi</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min_transformed</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min_transformed</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])])</span>
            <span class="n">Z</span><span class="o">=</span> <span class="n">X_min_transformed</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span>
            <span class="n">w</span><span class="o">=</span> <span class="n">solve_for_weights</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">Z</span><span class="p">)</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]))</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="LLE_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LLE_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="distance_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.distance_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">distance_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{distance_smote, </span>
<span class="sd">                            author={de la Calleja, J. and Fuentes, O.}, </span>
<span class="sd">                            booktitle={Proceedings of the Twentieth International Florida Artificial Intelligence}, </span>
<span class="sd">                            title={A distance-based over-sampling method for learning from imbalanced data sets}, </span>
<span class="sd">                            year={2007}, </span>
<span class="sd">                            volume={3}, </span>
<span class="sd">                            pages={634--635}</span>
<span class="sd">                            }</span>
<span class="sd">        </span>
<span class="sd">    Notes:</span>
<span class="sd">        * It is not clear what the authors mean by &quot;weighted distance&quot;.</span>
<span class="sd">    &quot;&quot;&quot;</span> 
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="distance_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.distance_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor component</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="distance_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.distance_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="distance_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.distance_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># determine the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># extracting minority samples</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting the model</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">mean_vector</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">mean_vector</span><span class="p">))</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="distance_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.distance_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SMMO"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMMO">[docs]</a><span class="k">class</span> <span class="nc">SMMO</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{smmo,</span>
<span class="sd">                            author = {de la Calleja, Jorge and Fuentes, Olac and González, Jesús},</span>
<span class="sd">                            booktitle= {Proceedings of the Twenty-First International Florida Artificial Intelligence Research Society Conference},</span>
<span class="sd">                            year = {2008},</span>
<span class="sd">                            month = {01},</span>
<span class="sd">                            pages = {276-281},</span>
<span class="sd">                            title = {Selecting Minority Examples from Misclassified Data for Over-Sampling.}</span>
<span class="sd">                            }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * In this implementation the ensemble is not specified. I have selected some very fast, basic classifiers.</span>
<span class="sd">        * Also, it is not clear what the authors mean by &quot;weighted distance&quot;.</span>
<span class="sd">        * The original technique is not prepared for the case when no minority samples are classified correctly be the ensemble.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_classifier</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMMO.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMMO.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">ensemble</span><span class="o">=</span> <span class="p">[</span><span class="n">QuadraticDiscriminantAnalysis</span><span class="p">(),</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">),</span> <span class="n">GaussianNB</span><span class="p">()],</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor component</span>
<span class="sd">            ensemble (list): list of classifiers, if None, default list of classifiers is used</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">len_ens</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ensemble</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The ensemble needs to be a list-like object&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">len_ens</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least 1 classifier needs to be specified&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ensemble</span><span class="o">=</span> <span class="n">ensemble</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMMO.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMMO.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;ensemble&#39;</span><span class="p">:</span> <span class="p">[[</span><span class="n">QuadraticDiscriminantAnalysis</span><span class="p">(),</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">),</span> <span class="n">GaussianNB</span><span class="p">()]]})</span></div>
    
<div class="viewcode-block" id="SMMO.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMMO.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># determine the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># training and in-sample prediction (out-of-sample by k-fold cross validation might be better)</span>
        <span class="n">predictions</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble</span><span class="p">:</span>
            <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        
        <span class="c1"># constructing ensemble prediction</span>
        <span class="n">pred</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">predictions</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ensemble</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># create mask of minority samples to sample</span>
        <span class="n">mask_to_sample</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">pred</span><span class="p">,</span> <span class="n">y</span><span class="p">)),</span> <span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask_to_sample</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Not enough minority samples selected </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask_to_sample</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_min_to_sample</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">mask_to_sample</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model for sampling</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min_to_sample</span><span class="p">)</span>
        
        <span class="c1"># doing the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min_to_sample</span><span class="p">))</span>
            <span class="n">mean</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min_to_sample</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">mean</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">samples</span><span class="p">])]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="SMMO.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMMO.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;ensemble&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">ensemble</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="polynom_fit_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.polynom_fit_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">polynom_fit_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{polynomial_fit_smote, </span>
<span class="sd">                            author={Gazzah, S. and Amara, N. E. B.}, </span>
<span class="sd">                            booktitle={2008 The Eighth IAPR International Workshop on Document Analysis Systems}, </span>
<span class="sd">                            title={New Oversampling Approaches Based on Polynomial Fitting for Imbalanced Data Sets}, </span>
<span class="sd">                            year={2008}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={677-684}, </span>
<span class="sd">                            keywords={curve fitting;learning (artificial intelligence);mesh generation;pattern classification;polynomials;sampling methods;support vector machines;oversampling approach;polynomial fitting function;imbalanced data set;pattern classification task;class-modular strategy;support vector machine;true negative rate;true positive rate;star topology;bus topology;polynomial curve topology;mesh topology;Polynomials;Topology;Support vector machines;Support vector machine classification;Pattern classification;Performance evaluation;Training data;Text analysis;Data engineering;Convergence;writer identification system;majority class;minority class;imbalanced data sets;polynomial fitting functions;class-modular strategy}, </span>
<span class="sd">                            doi={10.1109/DAS.2008.74}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={Sept},}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="polynom_fit_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.polynom_fit_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">topology</span><span class="o">=</span> <span class="s1">&#39;star&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            topoplogy (str): &#39;star&#39;/&#39;bus&#39;/&#39;mesh&#39;</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">topology</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;poly&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">topology</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="s1">&#39;topology&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_isin</span><span class="p">(</span><span class="n">topology</span><span class="p">,</span> <span class="s2">&quot;topology&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;star&#39;</span><span class="p">,</span> <span class="s1">&#39;bus&#39;</span><span class="p">,</span> <span class="s1">&#39;mesh&#39;</span><span class="p">])</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">=</span> <span class="n">topology</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="polynom_fit_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.polynom_fit_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;topology&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;star&#39;</span><span class="p">,</span> <span class="s1">&#39;bus&#39;</span><span class="p">,</span> <span class="s1">&#39;mesh&#39;</span><span class="p">,</span> <span class="s1">&#39;poly_1&#39;</span><span class="p">,</span> <span class="s1">&#39;poly_2&#39;</span><span class="p">,</span> <span class="s1">&#39;poly_3&#39;</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="polynom_fit_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.polynom_fit_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># extracting minority samples</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># determine the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">==</span> <span class="s1">&#39;star&#39;</span><span class="p">:</span>
            <span class="c1"># Implementation of the star topology</span>
            <span class="n">X_mean</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">k</span><span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">num_to_sample</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)))])</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_min</span><span class="p">:</span>
                <span class="n">diff</span><span class="o">=</span> <span class="n">X_mean</span> <span class="o">-</span> <span class="n">x</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">==</span> <span class="s1">&#39;bus&#39;</span><span class="p">:</span>
            <span class="c1"># Implementation of the bus topology</span>
            <span class="n">k</span><span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">num_to_sample</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)))])</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)):</span>
                <span class="n">diff</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">j</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span> <span class="o">==</span> <span class="s1">&#39;mesh&#39;</span><span class="p">:</span>
            <span class="c1"># Implementation of the mesh topology</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">&gt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
                <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
                    <span class="n">random_i</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
                    <span class="n">random_j</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
                    <span class="n">diff</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_i</span><span class="p">]</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_j</span><span class="p">]</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">random_i</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">diff</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span><span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">num_to_sample</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)))])</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)):</span>
                        <span class="n">diff</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;poly&#39;</span><span class="p">):</span>
            <span class="c1"># Implementation of the polynomial topology</span>
            <span class="n">deg</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">dim</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">polys</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="n">X_min</span><span class="p">[:,</span><span class="n">d</span><span class="p">],</span> <span class="n">deg</span><span class="p">))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">polys</span><span class="p">[</span><span class="n">d</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">)]))</span>
            <span class="n">samples</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="polynom_fit_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.polynom_fit_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;topology&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">topology</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>
    
<div class="viewcode-block" id="Stefanowski"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Stefanowski">[docs]</a><span class="k">class</span> <span class="nc">Stefanowski</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @inproceedings{stefanowski,</span>
<span class="sd">                 author = {Stefanowski, Jerzy and Wilk, Szymon},</span>
<span class="sd">                 title = {Selective Pre-processing of Imbalanced Data for Improving Classification Performance},</span>
<span class="sd">                 booktitle = {Proceedings of the 10th International Conference on Data Warehousing and Knowledge Discovery},</span>
<span class="sd">                 series = {DaWaK &#39;08},</span>
<span class="sd">                 year = {2008},</span>
<span class="sd">                 isbn = {978-3-540-85835-5},</span>
<span class="sd">                 location = {Turin, Italy},</span>
<span class="sd">                 pages = {283--292},</span>
<span class="sd">                 numpages = {10},</span>
<span class="sd">                 url = {http://dx.doi.org/10.1007/978-3-540-85836-2_27},</span>
<span class="sd">                 doi = {10.1007/978-3-540-85836-2_27},</span>
<span class="sd">                 acmid = {1430591},</span>
<span class="sd">                 publisher = {Springer-Verlag},</span>
<span class="sd">                 address = {Berlin, Heidelberg},</span>
<span class="sd">                } </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_copy</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">]</span>
    
<div class="viewcode-block" id="Stefanowski.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Stefanowski.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">strategy</span><span class="o">=</span> <span class="s1">&#39;weak_amp&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            strategy (str): &#39;weak_amp&#39;/&#39;weak_amp_relabel&#39;/&#39;strong_amp&#39;</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_isin</span><span class="p">(</span><span class="n">strategy</span><span class="p">,</span> <span class="s1">&#39;strategy&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;weak_amp&#39;</span><span class="p">,</span> <span class="s1">&#39;weak_amp_relabel&#39;</span><span class="p">,</span> <span class="s1">&#39;strong_amp&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">=</span> <span class="n">strategy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="c1"># this method does not maintain randomness, the parameter is introduced for</span>
        <span class="c1"># the compatibility of interfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Stefanowski.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Stefanowski.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[{</span><span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="s1">&#39;weak_amp&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="s1">&#39;weak_amp_relabel&#39;</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="s1">&#39;strong_amp&#39;</span><span class="p">},]</span></div>
    
<div class="viewcode-block" id="Stefanowski.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Stefanowski.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># copying y as its values will change</span>
        <span class="n">y</span><span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># fitting the nearest neighbors model for noise filtering, 4 neighbors </span>
        <span class="c1"># instead of 3 as the closest neighbor to a point is itself</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distance</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># fitting the nearest neighbors model for sample generation, 6 neighbors </span>
        <span class="c1"># instead of 5 for the same reason</span>
        <span class="n">nn5</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn5</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distance5</span><span class="p">,</span> <span class="n">indices5</span><span class="o">=</span> <span class="n">nn5</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a0&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        
        <span class="c1"># determining noisy and safe flags</span>
        <span class="n">flags</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">mode</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]])</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">flags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;safe&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">flags</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;noisy&#39;</span><span class="p">)</span>
        <span class="n">flags</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a1&#39;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">flags</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="s1">&#39;noisy&#39;</span><span class="p">))</span>
        
        <span class="n">D</span><span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">==</span> <span class="s1">&#39;noisy&#39;</span><span class="p">)</span>
        <span class="n">minority_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;weak_amp&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;weak_amp_relabel&#39;</span><span class="p">:</span>
            <span class="c1"># weak mplification - the number of copies is the number of </span>
            <span class="c1"># majority nearest neighbors </span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">minority_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;noisy&#39;</span><span class="p">:</span>
                    <span class="n">k</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="s1">&#39;safe&#39;</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;weak_amp_relabel&#39;</span><span class="p">:</span>
            <span class="c1"># relabling - noisy majority neighbors are relabelled to minority</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">minority_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;noisy&#39;</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span> <span class="ow">and</span> <span class="n">flags</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;noisy&#39;</span><span class="p">:</span>
                            <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span>
                            <span class="n">D</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;strong_amp&#39;</span><span class="p">:</span>
            <span class="c1"># safe minority samples are copied as many times as many safe majority</span>
            <span class="c1"># samples are among the nearest neighbors</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">minority_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;safe&#39;</span><span class="p">:</span>
                    <span class="n">k</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="s1">&#39;safe&#39;</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="c1"># if classified correctly by knn(5), noisy minority samples are amplified </span>
            <span class="c1"># by creating as many copies as many save majority samples in its neighborhood </span>
            <span class="c1"># are present otherwise amplify based on the 5 neighborhood</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">minority_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">flags</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;noisy&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mode</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices5</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]])</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">k</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="s1">&#39;safe&#39;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">k</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices5</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="n">flags</span><span class="p">[</span><span class="n">indices5</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="s1">&#39;safe&#39;</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                        <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>


        <span class="n">to_remove</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">D</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">)</span>
        
        <span class="n">X_noise_removed</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">y_noise_removed</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;no samples added&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X_noise_removed</span><span class="p">,</span> <span class="n">y_noise_removed</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_noise_removed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y_noise_removed</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="Stefanowski.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Stefanowski.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="ADOMS"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADOMS">[docs]</a><span class="k">class</span> <span class="nc">ADOMS</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{adoms, </span>
<span class="sd">                            author={Tang, S. and Chen, S.}, </span>
<span class="sd">                            booktitle={2008 International Conference on Information Technology and Applications in Biomedicine}, </span>
<span class="sd">                            title={The generation mechanism of synthetic minority class examples}, </span>
<span class="sd">                            year={2008}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={444-447}, </span>
<span class="sd">                            keywords={medical image processing;generation mechanism;synthetic minority class examples;class imbalance problem;medical image analysis;oversampling algorithm;Principal component analysis;Biomedical imaging;Medical diagnostic imaging;Information technology;Biomedical engineering;Noise generators;Concrete;Nearest neighbor searches;Data analysis;Image analysis}, </span>
<span class="sd">                            doi={10.1109/ITAB.2008.4570642}, </span>
<span class="sd">                            ISSN={2168-2194}, </span>
<span class="sd">                            month={May}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_dim_reduction</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="ADOMS.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADOMS.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): parameter of the nearest neighbor component</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
       
<div class="viewcode-block" id="ADOMS.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADOMS.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="ADOMS.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADOMS.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># determine the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">distance</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">index</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">neighbors</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>
            
            <span class="c1"># fitting the PCA</span>
            <span class="n">pca</span><span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span>
            
            <span class="c1"># extracting the principal direction</span>
            <span class="n">principal_direction</span><span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># do the sampling according to the description in the paper</span>
            <span class="n">random_neighbor</span><span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">))]</span>
            <span class="n">d</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">random_neighbor</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
            <span class="n">r</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
            <span class="n">sign</span><span class="o">=</span> <span class="mf">1.0</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">random_neighbor</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">principal_direction</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="o">-</span><span class="mf">1.0</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="n">sign</span><span class="o">*</span><span class="n">r</span><span class="o">*</span><span class="n">d</span><span class="o">*</span><span class="n">principal_direction</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="ADOMS.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADOMS.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="Safe_Level_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Safe_Level_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">Safe_Level_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @inproceedings{safe_level_smote,</span>
<span class="sd">                         author = {Bunkhumpornpat, Chumphol and Sinapiromsaran, Krung and Lursinsap, Chidchanok},</span>
<span class="sd">                         title = {Safe-Level-SMOTE: Safe-Level-Synthetic Minority Over-Sampling TEchnique for Handling the Class Imbalanced Problem},</span>
<span class="sd">                         booktitle = {Proceedings of the 13th Pacific-Asia Conference on Advances in Knowledge Discovery and Data Mining},</span>
<span class="sd">                         series = {PAKDD &#39;09},</span>
<span class="sd">                         year = {2009},</span>
<span class="sd">                         isbn = {978-3-642-01306-5},</span>
<span class="sd">                         location = {Bangkok, Thailand},</span>
<span class="sd">                         pages = {475--482},</span>
<span class="sd">                         numpages = {8},</span>
<span class="sd">                         url = {http://dx.doi.org/10.1007/978-3-642-01307-2_43},</span>
<span class="sd">                         doi = {10.1007/978-3-642-01307-2_43},</span>
<span class="sd">                         acmid = {1533904},</span>
<span class="sd">                         publisher = {Springer-Verlag},</span>
<span class="sd">                         address = {Berlin, Heidelberg},</span>
<span class="sd">                         keywords = {Class Imbalanced Problem, Over-sampling, SMOTE, Safe Level},</span>
<span class="sd">                        } </span>
<span class="sd">        </span>
<span class="sd">    Notes:</span>
<span class="sd">        * The original method was not prepared for the case when no minority sample has minority neighbors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_componentwise</span><span class="p">]</span>
    
<div class="viewcode-block" id="Safe_Level_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Safe_Level_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor component</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Safe_Level_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Safe_Level_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
        
<div class="viewcode-block" id="Safe_Level_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Safe_Level_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># determine the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># fitting nearest neighbors model</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distance</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">minority_labels</span><span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span>
        <span class="n">minority_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">minority_labels</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">numattrs</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">index</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minority_indices</span><span class="p">))</span>
            <span class="n">neighbor_index</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            
            <span class="n">p</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="n">n</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">neighbor_index</span><span class="p">]</span>
            
            <span class="c1"># find safe levels</span>
            <span class="n">sl_p</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span>
            <span class="n">sl_n</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">neighbor_index</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">sl_n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sl_ratio</span><span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">sl_p</span><span class="p">)</span><span class="o">/</span><span class="n">sl_n</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sl_ratio</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            
            <span class="k">if</span> <span class="n">sl_ratio</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">and</span> <span class="n">sl_p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">s</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">numattrs</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">atti</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numattrs</span><span class="p">):</span>
                    <span class="c1"># iterate through attributes and do sampling according to </span>
                    <span class="c1"># safe level</span>
                    <span class="k">if</span> <span class="n">sl_ratio</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span> <span class="ow">and</span> <span class="n">sl_p</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">gap</span><span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">elif</span> <span class="n">sl_ratio</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">gap</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">sl_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">gap</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="mf">1.0</span><span class="o">/</span><span class="n">sl_ratio</span>
                    <span class="k">elif</span> <span class="n">sl_ratio</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">gap</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">sl_ratio</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="n">sl_ratio</span>
                    <span class="n">dif</span><span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">atti</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">atti</span><span class="p">]</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">atti</span><span class="p">]</span><span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">atti</span><span class="p">]</span> <span class="o">+</span> <span class="n">gap</span><span class="o">*</span><span class="n">dif</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;No samples generated&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="Safe_Level_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Safe_Level_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="MSMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MSMOTE">[docs]</a><span class="k">class</span> <span class="nc">MSMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @inproceedings{msmote,</span>
<span class="sd">                             author = {Hu, Shengguo and Liang, Yanfeng and Ma, Lintao and He, Ying},</span>
<span class="sd">                             title = {MSMOTE: Improving Classification Performance When Training Data is Imbalanced},</span>
<span class="sd">                             booktitle = {Proceedings of the 2009 Second International Workshop on Computer Science and Engineering - Volume 02},</span>
<span class="sd">                             series = {IWCSE &#39;09},</span>
<span class="sd">                             year = {2009},</span>
<span class="sd">                             isbn = {978-0-7695-3881-5},</span>
<span class="sd">                             pages = {13--17},</span>
<span class="sd">                             numpages = {5},</span>
<span class="sd">                             url = {https://doi.org/10.1109/WCSE.2009.756},</span>
<span class="sd">                             doi = {10.1109/WCSE.2009.756},</span>
<span class="sd">                             acmid = {1682710},</span>
<span class="sd">                             publisher = {IEEE Computer Society},</span>
<span class="sd">                             address = {Washington, DC, USA},</span>
<span class="sd">                             keywords = {imbalanced data, over-sampling, SMOTE, AdaBoost, samples groups, SMOTEBoost},</span>
<span class="sd">                            } </span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * The original method was not prepared for the case when all minority samples are noise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">]</span>
    
<div class="viewcode-block" id="MSMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MSMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor component</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
       
<div class="viewcode-block" id="MSMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MSMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
        
<div class="viewcode-block" id="MSMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MSMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># determine the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting the nearest neighbors model</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distance</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="n">noise_mask</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
        
        <span class="c1"># generating samples        </span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">index</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            
            <span class="n">n_p</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="n">n_p</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">:</span>
                <span class="n">sample_type</span><span class="o">=</span> <span class="s1">&#39;security&#39;</span>
            <span class="k">elif</span> <span class="n">n_p</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sample_type</span><span class="o">=</span> <span class="s1">&#39;noise&#39;</span>
                <span class="n">noise_mask</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">=</span> <span class="kc">True</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">noise_mask</span><span class="p">):</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;All minority samples are noise&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sample_type</span><span class="o">=</span> <span class="s1">&#39;border&#39;</span>
                
            <span class="k">if</span> <span class="n">sample_type</span> <span class="o">==</span> <span class="s1">&#39;security&#39;</span><span class="p">:</span>
                <span class="n">neighbor_index</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">elif</span> <span class="n">sample_type</span> <span class="o">==</span> <span class="s1">&#39;border&#39;</span><span class="p">:</span>
                <span class="n">neighbor_index</span><span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">index</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points_componentwise</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">neighbor_index</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="MSMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MSMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="DE_oversampling"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DE_oversampling">[docs]</a><span class="k">class</span> <span class="nc">DE_oversampling</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{de_oversampling, </span>
<span class="sd">                            author={Chen, L. and Cai, Z. and Chen, L. and Gu, Q.}, </span>
<span class="sd">                            booktitle={2010 Third International Conference on Knowledge Discovery and Data Mining}, </span>
<span class="sd">                            title={A Novel Differential Evolution-Clustering Hybrid Resampling Algorithm on Imbalanced Datasets}, </span>
<span class="sd">                            year={2010}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={81-85}, </span>
<span class="sd">                            keywords={pattern clustering;sampling methods;support vector machines;differential evolution;clustering algorithm;hybrid resampling algorithm;imbalanced datasets;support vector machine;minority class;mutation operators;crossover operators;data cleaning method;F-measure criterion;ROC area criterion;Support vector machines;Intrusion detection;Support vector machine classification;Cleaning;Electronic mail;Clustering algorithms;Signal to noise ratio;Learning systems;Data mining;Geology;imbalanced datasets;hybrid resampling;clustering;differential evolution;support vector machine}, </span>
<span class="sd">                            doi={10.1109/WKDD.2010.48}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={Jan},}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">]</span>
    
<div class="viewcode-block" id="DE_oversampling.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DE_oversampling.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">crossover_rate</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">similarity_threshold</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): control parameter of the nearest neighbor component</span>
<span class="sd">            crossover_rate (float): cross over rate of evoluation</span>
<span class="sd">            similarity_threshold (float): similarity threshold paramter</span>
<span class="sd">            n_clusters (int): number of clusters for cleansing</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">crossover_rate</span><span class="p">,</span> <span class="s1">&#39;crossover_rate&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">similarity_threshold</span><span class="p">,</span> <span class="s1">&#39;similarity_threshold&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="s1">&#39;n_clusters&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crossover_rate</span><span class="o">=</span> <span class="n">crossover_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">similarity_threshold</span><span class="o">=</span> <span class="n">similarity_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>

<div class="viewcode-block" id="DE_oversampling.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DE_oversampling.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span>
                                                    <span class="s1">&#39;crossover_rate&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span>
                                                    <span class="s1">&#39;similarity_threshold&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span>
                                                    <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="DE_oversampling.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DE_oversampling.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># determine the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">d</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">distance</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># generating samples        </span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="c1"># mutation according to the description in the paper</span>
            <span class="n">random_index</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">random_point</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_index</span><span class="p">]</span>
            <span class="n">random_neighbor_indices</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">random_index</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">random_neighbor_1</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_neighbor_indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">random_neighbor_2</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_neighbor_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            
            <span class="n">mutated</span><span class="o">=</span> <span class="n">random_point</span> <span class="o">+</span> <span class="p">(</span><span class="n">random_neighbor_1</span> <span class="o">-</span> <span class="n">random_neighbor_2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
            
            <span class="c1"># crossover - updates the vector &#39;mutated&#39;</span>
            <span class="n">rand_s</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">random_value</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">random_value</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossover_rate</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">==</span> <span class="n">rand_s</span><span class="p">:</span>
                    <span class="n">mutated</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">random_point</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">random_value</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossover_rate</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="n">rand_s</span><span class="p">:</span>
                    <span class="k">pass</span>
            
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mutated</span><span class="p">)</span>
        
        <span class="c1"># assembling all data for clearning</span>
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># cleansing based on clustering</span>
        <span class="n">kmeans</span><span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">unique_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
        <span class="n">one_label_clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">unique_labels</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">l</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">to_remove</span><span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># going through the clusters having one label only</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">one_label_clusters</span><span class="p">:</span>
            <span class="n">cluster_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">l</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">mean_of_cluster</span><span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[</span><span class="n">l</span><span class="p">]</span>
            
            <span class="c1"># finding center-like sample</span>
            <span class="n">center_like_index</span><span class="o">=</span> <span class="kc">None</span>
            <span class="n">center_like_dist</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster_indices</span><span class="p">:</span>
                <span class="n">dist</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">mean_of_cluster</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;</span> <span class="n">center_like_dist</span><span class="p">:</span>
                    <span class="n">center_like_dist</span><span class="o">=</span> <span class="n">dist</span>
                    <span class="n">center_like_index</span><span class="o">=</span> <span class="n">i</span>
            
            <span class="c1"># removing the samples similar to the center-like sample</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cluster_indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">center_like_index</span><span class="p">:</span>
                    <span class="n">d</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">center_like_index</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">center_like_index</span><span class="p">]))</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">similarity_threshold</span><span class="p">:</span>
                        <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="DE_oversampling.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DE_oversampling.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;crossover_rate&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">crossover_rate</span><span class="p">,</span> 
                <span class="s1">&#39;similarity_threshold&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">similarity_threshold</span><span class="p">,</span> 
                <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<span class="c1"># Borrowed from sklearn-dev, will be removed once the sklearn implementation</span>
<span class="c1"># becomes stable</span>
<span class="k">class</span> <span class="nc">OPTICS</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">max_eps</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">,</span>
                 <span class="n">p</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metric_params</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">maxima_ratio</span><span class="o">=.</span><span class="mi">75</span><span class="p">,</span>
                 <span class="n">rejection_ratio</span><span class="o">=.</span><span class="mi">7</span><span class="p">,</span> <span class="n">similarity_threshold</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span>
                 <span class="n">significant_min</span><span class="o">=.</span><span class="mi">003</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="o">=.</span><span class="mi">005</span><span class="p">,</span>
                 <span class="n">min_maxima_ratio</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">algorithm</span><span class="o">=</span><span class="s1">&#39;ball_tree&#39;</span><span class="p">,</span>
                 <span class="n">leaf_size</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_eps</span> <span class="o">=</span> <span class="n">max_eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span> <span class="o">=</span> <span class="n">min_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxima_ratio</span> <span class="o">=</span> <span class="n">maxima_ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rejection_ratio</span> <span class="o">=</span> <span class="n">rejection_ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">similarity_threshold</span> <span class="o">=</span> <span class="n">similarity_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">significant_min</span> <span class="o">=</span> <span class="n">significant_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_cluster_size</span> <span class="o">=</span> <span class="n">min_cluster_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_maxima_ratio</span> <span class="o">=</span> <span class="n">min_maxima_ratio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span> <span class="o">=</span> <span class="n">algorithm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric</span> <span class="o">=</span> <span class="n">metric</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metric_params</span> <span class="o">=</span> <span class="n">metric_params</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span> <span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">leaf_size</span> <span class="o">=</span> <span class="n">leaf_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span> <span class="o">=</span> <span class="n">n_jobs</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform OPTICS clustering</span>
<span class="sd">        Extracts an ordered list of points and reachability distances, and</span>
<span class="sd">        performs initial clustering using `max_eps` distance specified at</span>
<span class="sd">        OPTICS object instantiation.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        X : array, shape (n_samples, n_features)</span>
<span class="sd">            The data.</span>
<span class="sd">        y : ignored</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        self : instance of OPTICS</span>
<span class="sd">            The instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span> <span class="o">&gt;</span> <span class="n">n_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Number of training samples (n_samples=</span><span class="si">%d</span><span class="s2">) must &quot;</span>
                             <span class="s2">&quot;be greater than min_samples (min_samples=</span><span class="si">%d</span><span class="s2">) &quot;</span>
                             <span class="s2">&quot;used for clustering.&quot;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">))</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cluster_size</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_cluster_size</span> <span class="o">!=</span>
                                          <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_cluster_size</span><span class="p">)</span>
                                          <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cluster_size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s1">&#39;min_cluster_size must be a positive integer or &#39;</span>
                             <span class="s1">&#39;a float between 0 and 1. Got </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">min_cluster_size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cluster_size</span> <span class="o">&gt;</span> <span class="n">n_samples</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s1">&#39;min_cluster_size must be no greater than the &#39;</span>
                             <span class="s1">&#39;number of samples (</span><span class="si">%d</span><span class="s1">). Got </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_cluster_size</span><span class="p">))</span>

        <span class="c1"># Start all points as &#39;unprocessed&#39; ##</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reachability_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reachability_</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_distances_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_distances_</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="c1"># Start all points as noise ##</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="n">nbrs</span> <span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">,</span>
                                <span class="n">algorithm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">algorithm</span><span class="p">,</span>
                                <span class="n">leaf_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">leaf_size</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span>
                                <span class="n">metric_params</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metric_params</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span>
                                <span class="n">n_jobs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>

        <span class="n">nbrs</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">core_distances_</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">,</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ordering_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_optics_order</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">nbrs</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># OPTICS helper functions</span>

    <span class="k">def</span> <span class="nf">_calculate_optics_order</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">nbrs</span><span class="p">):</span>
        <span class="c1"># Main OPTICS loop. Not parallelizable. The order that entries are</span>
        <span class="c1"># written to the &#39;ordering_&#39; list is important!</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">ordering</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ordering_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">processed</span><span class="p">[</span><span class="n">point</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_distances_</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_eps</span><span class="p">:</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="n">processed</span><span class="p">[</span><span class="n">point</span><span class="p">]:</span>
                    <span class="n">processed</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">ordering</span><span class="p">[</span><span class="n">ordering_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span>
                    <span class="n">ordering_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">point</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_set_reach_dist</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">processed</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">nbrs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># For very noisy points</span>
                <span class="n">ordering</span><span class="p">[</span><span class="n">ordering_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">point</span>
                <span class="n">ordering_idx</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">processed</span><span class="p">[</span><span class="n">point</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">ordering</span>

    <span class="k">def</span> <span class="nf">_set_reach_dist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point_index</span><span class="p">,</span> <span class="n">processed</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">nbrs</span><span class="p">):</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">point_index</span><span class="p">:</span><span class="n">point_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">nbrs</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_eps</span><span class="p">,</span>
                                        <span class="n">return_distance</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Getting indices of neighbors that have not been processed</span>
        <span class="n">unproc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">compress</span><span class="p">((</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">processed</span><span class="p">,</span> <span class="n">indices</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                             <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Keep n_jobs = 1 in the following lines...please</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">unproc</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="c1"># Everything is already processed. Return to main loop</span>
            <span class="k">return</span> <span class="n">point_index</span>

        <span class="n">dists</span> <span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">unproc</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                                   <span class="bp">self</span><span class="o">.</span><span class="n">metric</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">rdists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">dists</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">core_distances_</span><span class="p">[</span><span class="n">point_index</span><span class="p">])</span>
        <span class="n">new_reach</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reachability_</span><span class="p">,</span> <span class="n">unproc</span><span class="p">),</span> <span class="n">rdists</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reachability_</span><span class="p">[</span><span class="n">unproc</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_reach</span>

        <span class="c1"># Define return order based on reachability distance</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">unproc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">quick_scan</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reachability_</span><span class="p">,</span> <span class="n">unproc</span><span class="p">),</span>
                                  <span class="n">dists</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">isclose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rel_tol</span><span class="o">=</span> <span class="mf">1e-09</span><span class="p">,</span> <span class="n">abs_tol</span><span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">max</span><span class="p">([</span><span class="n">rel_tol</span><span class="o">*</span><span class="nb">max</span><span class="p">([</span><span class="nb">abs</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b</span><span class="p">)]),</span> <span class="n">abs_tol</span><span class="p">])</span>
    
    <span class="k">def</span> <span class="nf">quick_scan</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rdists</span><span class="p">,</span> <span class="n">dists</span><span class="p">):</span>
        <span class="n">rdist</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">dist</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="n">n</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rdists</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rdists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rdist</span><span class="p">:</span>
                <span class="n">rdist</span><span class="o">=</span> <span class="n">rdists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">dist</span><span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">idx</span><span class="o">=</span> <span class="n">i</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">rdists</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">rdist</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">dist</span><span class="p">:</span>
                    <span class="n">dist</span><span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">idx</span><span class="o">=</span> <span class="n">i</span>
        <span class="k">return</span> <span class="n">idx</span>

<div class="viewcode-block" id="SMOBD"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOBD">[docs]</a><span class="k">class</span> <span class="nc">SMOBD</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{smobd, </span>
<span class="sd">                            author={Cao, Q. and Wang, S.}, </span>
<span class="sd">                            booktitle={2011 International Conference on Information Management, Innovation Management and Industrial Engineering}, </span>
<span class="sd">                            title={Applying Over-sampling Technique Based on Data Density and Cost-sensitive SVM to Imbalanced Learning}, </span>
<span class="sd">                            year={2011}, </span>
<span class="sd">                            volume={2}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={543-548}, </span>
<span class="sd">                            keywords={data handling;learning (artificial intelligence);support vector machines;oversampling technique application;data density;cost sensitive SVM;imbalanced learning;SMOTE algorithm;data distribution;density information;Support vector machines;Classification algorithms;Noise measurement;Arrays;Noise;Algorithm design and analysis;Training;imbalanced learning;cost-sensitive SVM;SMOTE;data density;SMOBD}, </span>
<span class="sd">                            doi={10.1109/ICIII.2011.276}, </span>
<span class="sd">                            ISSN={2155-1456}, </span>
<span class="sd">                            month={Nov},}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_based</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOBD.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOBD.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">eta1</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span> <span class="mf">1.8</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">max_eps</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            eta1 (float): control parameter of density estimation</span>
<span class="sd">            t (float): control parameter of noise filtering</span>
<span class="sd">            min_samples (int): minimum samples parameter for OPTICS</span>
<span class="sd">            max_eps (float): maximum environment radius paramter for OPTICS</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">eta1</span><span class="p">,</span> <span class="s1">&#39;eta1&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">min_samples</span><span class="p">,</span> <span class="s1">&#39;min_samples&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">max_eps</span><span class="p">,</span> <span class="s1">&#39;max_eps&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta1</span><span class="o">=</span> <span class="n">eta1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="o">=</span> <span class="n">min_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_eps</span><span class="o">=</span> <span class="n">max_eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMOBD.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOBD.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;eta1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> 
                                                    <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">],</span> 
                                                    <span class="s1">&#39;min_samples&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> 
                                                    <span class="s1">&#39;max_eps&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SMOBD.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOBD.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># determine the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># running the OPTICS technique based on the sklearn implementation</span>
        <span class="c1"># TODO: replace to sklearn call once it is stable</span>
        <span class="n">o</span><span class="o">=</span> <span class="n">OPTICS</span><span class="p">(</span><span class="n">min_samples</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">]),</span> <span class="n">max_eps</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_eps</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">o</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">cd</span><span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">core_distances_</span>
        <span class="n">rd</span><span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">reachability_</span>
        
        <span class="c1"># noise filtering</span>
        <span class="n">cd_average</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span>
        <span class="n">rd_average</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span>
        <span class="n">noise</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">cd</span> <span class="o">&gt;</span> <span class="n">cd_average</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">rd</span> <span class="o">&gt;</span> <span class="n">rd_average</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">)</span>
        
        <span class="c1"># fitting a nearest neighbor model to be able to find neighbors in radius</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># determining the density</span>
        <span class="n">factor_1</span><span class="o">=</span> <span class="n">cd</span>
        <span class="n">factor_2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">nn</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_eps</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span> <span class="kc">False</span><span class="p">)])</span>
        
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">factor_1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">factor_2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">factor_1</span><span class="o">=</span> <span class="n">factor_1</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">factor_1</span><span class="p">)</span>
        <span class="n">factor_2</span><span class="o">=</span> <span class="n">factor_2</span><span class="o">/</span><span class="nb">max</span><span class="p">(</span><span class="n">factor_2</span><span class="p">)</span>
        
        <span class="n">df</span><span class="o">=</span> <span class="n">factor_1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">eta1</span> <span class="o">+</span> <span class="n">factor_2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta1</span><span class="p">)</span>
        
        <span class="c1"># setting the density at noisy samples to zero</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">noise</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">noise</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">df</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
        
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">df</span><span class="p">))</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">df</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># normalizing the density</span>
        <span class="n">df_dens</span><span class="o">=</span> <span class="n">df</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">df_dens</span><span class="p">)</span>
            <span class="n">neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points_componentwise</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">neighbor_idx</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="SMOBD.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOBD.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;eta1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta1</span><span class="p">,</span> 
                <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> 
                <span class="s1">&#39;min_samples&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">,</span> 
                <span class="s1">&#39;max_eps&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_eps</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SUNDO"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SUNDO">[docs]</a><span class="k">class</span> <span class="nc">SUNDO</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{sundo, </span>
<span class="sd">                            author={Cateni, S. and Colla, V. and Vannucci, M.}, </span>
<span class="sd">                            booktitle={2011 11th International Conference on Intelligent Systems Design and Applications}, </span>
<span class="sd">                            title={Novel resampling method for the classification of imbalanced datasets for industrial and other real-world problems}, </span>
<span class="sd">                            year={2011}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={402-407}, </span>
<span class="sd">                            keywords={decision trees;pattern classification;sampling methods;support vector machines;resampling method;imbalanced dataset classification;industrial problem;real world problem;oversampling technique;undersampling technique;support vector machine;decision tree;binary classification;synthetic dataset;public dataset;industrial dataset;Support vector machines;Training;Accuracy;Databases;Intelligent systems;Breast cancer;Decision trees;oversampling;undersampling;imbalanced dataset}, </span>
<span class="sd">                            doi={10.1109/ISDA.2011.6121689}, </span>
<span class="sd">                            ISSN={2164-7151}, </span>
<span class="sd">                            month={Nov}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_application</span><span class="p">]</span>
    
<div class="viewcode-block" id="SUNDO.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SUNDO.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="SUNDO.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SUNDO.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[{}]</span></div>
    
<div class="viewcode-block" id="SUNDO.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SUNDO.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="n">n_1</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">n_0</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_1</span>
        <span class="n">N</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">n_0</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">n_1</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">N</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># generating minority samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        
        <span class="n">stds</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># At one point the algorithm says to keep those points which are</span>
        <span class="c1"># the most distant from majority samples, and not leaving any minority</span>
        <span class="c1"># sample isolated. This can be implemented by generating multiple samples</span>
        <span class="c1"># for each point and keep the one most distant from the majority samples.</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
            <span class="n">i</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">best_sample</span><span class="o">=</span> <span class="kc">None</span>
            <span class="n">best_sample_dist</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">s</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">stds</span><span class="p">)</span>
                <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">best_sample_dist</span><span class="p">:</span>
                    <span class="n">best_sample_dist</span><span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">best_sample</span><span class="o">=</span> <span class="n">s</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">best_sample</span><span class="p">)</span>
        
        <span class="c1"># Extending the minority dataset with the new samples</span>
        <span class="n">X_min_extended</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)])</span>
        
        <span class="c1"># Removing N elements from the majority dataset</span>
        
        <span class="c1"># normalize</span>
        <span class="n">mms</span><span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="n">X_maj_normalized</span><span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        
        <span class="c1"># computing the distance matrix</span>
        <span class="n">dm</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_maj_normalized</span><span class="p">,</span> <span class="n">X_maj_normalized</span><span class="p">)</span>
        
        <span class="c1"># len(X_maj) offsets for the diagonal 0 elements, 2N because every distances appears twice</span>
        <span class="n">threshold</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dm</span><span class="o">.</span><span class="n">flatten</span><span class="p">())[</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)):</span>
            <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
        <span class="c1"># extracting the coordinates of pairs closer than threshold</span>
        <span class="n">pairs_to_break</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dm</span> <span class="o">&lt;</span> <span class="n">threshold</span><span class="p">)</span>
        <span class="n">pairs_to_break</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">pairs_to_break</span><span class="p">)</span>
        
        <span class="c1"># sorting the pairs, otherwise both points would be removed</span>
        <span class="n">pairs_to_break</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># uniqueing the coordinates - the final number might be less than N</span>
        <span class="n">to_remove</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">pairs_to_break</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># removing the selected elements</span>
        <span class="n">X_maj_cleaned</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_min_extended</span><span class="p">,</span> <span class="n">X_maj_cleaned</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min_extended</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj_cleaned</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="SUNDO.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SUNDO.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="MSYN"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MSYN">[docs]</a><span class="k">class</span> <span class="nc">MSYN</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{msyn,</span>
<span class="sd">                            author=&quot;Fan, Xiannian</span>
<span class="sd">                            and Tang, Ke</span>
<span class="sd">                            and Weise, Thomas&quot;,</span>
<span class="sd">                            editor=&quot;Huang, Joshua Zhexue</span>
<span class="sd">                            and Cao, Longbing</span>
<span class="sd">                            and Srivastava, Jaideep&quot;,</span>
<span class="sd">                            title=&quot;Margin-Based Over-Sampling Method for Learning from Imbalanced Datasets&quot;,</span>
<span class="sd">                            booktitle=&quot;Advances in Knowledge Discovery and Data Mining&quot;,</span>
<span class="sd">                            year=&quot;2011&quot;,</span>
<span class="sd">                            publisher=&quot;Springer Berlin Heidelberg&quot;,</span>
<span class="sd">                            address=&quot;Berlin, Heidelberg&quot;,</span>
<span class="sd">                            pages=&quot;309--320&quot;,</span>
<span class="sd">                            abstract=&quot;Learning from imbalanced datasets has drawn more and more attentions from both theoretical and practical aspects. Over- sampling is a popular and simple method for imbalanced learning. In this paper, we show that there is an inherently potential risk associated with the over-sampling algorithms in terms of the large margin principle. Then we propose a new synthetic over sampling method, named Margin-guided Synthetic Over-sampling (MSYN), to reduce this risk. The MSYN improves learning with respect to the data distributions guided by the margin-based rule. Empirical study verities the efficacy of MSYN.&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-642-20847-8&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="MSYN.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MSYN.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pressure</span><span class="o">=</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            pressure (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in the SMOTE sampling</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">pressure</span><span class="p">,</span> <span class="s1">&#39;pressure&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span><span class="o">=</span> <span class="n">pressure</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="MSYN.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MSYN.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;pressure&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">2.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>

<div class="viewcode-block" id="MSYN.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MSYN.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="n">min_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">maj_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">smote</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">X_res</span><span class="p">,</span> <span class="n">y_res</span><span class="o">=</span> <span class="n">smote</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">X_new</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span> <span class="n">X_res</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):],</span> <span class="n">y_res</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
        <span class="c1"># Compute nearest hit and miss for both classes</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># computing nearest hit and miss distances, these will be used to compute thetas</span>
        <span class="n">nearest_hit_dist</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="nb">next</span><span class="p">(</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))])</span>
        <span class="n">nearest_miss_dist</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="nb">next</span><span class="p">(</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))])</span>
        
        <span class="c1"># computing the thetas without new samples being involved</span>
        <span class="n">theta_A_sub_alpha</span><span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">nearest_miss_dist</span> <span class="o">-</span> <span class="n">nearest_hit_dist</span><span class="p">)</span>
        <span class="n">theta_min</span><span class="o">=</span> <span class="n">theta_A_sub_alpha</span><span class="p">[</span><span class="n">min_indices</span><span class="p">]</span>
        <span class="n">theta_maj</span><span class="o">=</span> <span class="n">theta_A_sub_alpha</span><span class="p">[</span><span class="n">maj_indices</span><span class="p">]</span>
        
        <span class="c1"># computing the f_3 score for all new samples</span>
        <span class="n">f_3</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_new</span><span class="p">:</span>
            <span class="c1"># determining the distances of the new sample from the training set</span>
            <span class="n">distances</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span> <span class="o">-</span> <span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># computing nearest hit and miss distances involving the new elements</span>
            <span class="n">nearest_hit_dist_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nearest_hit_dist</span><span class="p">[</span><span class="n">min_indices</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">min_indices</span><span class="p">],</span> <span class="n">nearest_hit_dist</span><span class="p">[</span><span class="n">min_indices</span><span class="p">],</span> <span class="n">distances</span><span class="p">[</span><span class="n">min_indices</span><span class="p">])</span>
            <span class="n">nearest_miss_dist_min</span><span class="o">=</span> <span class="n">nearest_miss_dist</span><span class="p">[</span><span class="n">min_indices</span><span class="p">]</span>
            <span class="n">nearest_hit_dist_maj</span><span class="o">=</span> <span class="n">nearest_hit_dist</span><span class="p">[</span><span class="n">maj_indices</span><span class="p">]</span>
            <span class="n">nearest_miss_dist_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nearest_miss_dist</span><span class="p">[</span><span class="n">maj_indices</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distances</span><span class="p">[</span><span class="n">maj_indices</span><span class="p">],</span> <span class="n">nearest_miss_dist</span><span class="p">[</span><span class="n">maj_indices</span><span class="p">],</span> <span class="n">distances</span><span class="p">[</span><span class="n">maj_indices</span><span class="p">])</span>
            
            <span class="c1"># computing the thetas incorporating the new elements</span>
            <span class="n">theta_x_min</span><span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">nearest_miss_dist_min</span> <span class="o">-</span> <span class="n">nearest_hit_dist_min</span><span class="p">)</span>
            <span class="n">theta_x_maj</span><span class="o">=</span> <span class="mf">0.5</span><span class="o">*</span><span class="p">(</span><span class="n">nearest_miss_dist_maj</span> <span class="o">-</span> <span class="n">nearest_hit_dist_maj</span><span class="p">)</span>
            
            <span class="c1"># determining the delta scores and computing f_3</span>
            <span class="n">Delta_P</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">theta_x_min</span> <span class="o">-</span> <span class="n">theta_min</span><span class="p">)</span>
            <span class="n">Delta_N</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">theta_x_maj</span> <span class="o">-</span> <span class="n">theta_maj</span><span class="p">)</span>
            
            <span class="n">f_3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="n">Delta_N</span><span class="o">/</span><span class="p">(</span><span class="n">Delta_P</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">))</span>
        
        <span class="n">f_3</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f_3</span><span class="p">)</span>
        
        <span class="c1"># determining the elements with the minimum f_3 scores to add</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">new_ind</span><span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">f_3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">f_3</span><span class="p">))),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">new_ind</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_ind</span><span class="p">[:(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span>
       
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">X_new</span><span class="p">[</span><span class="n">new_ind</span><span class="p">]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_ind</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="MSYN.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MSYN.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;pressure&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pressure</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SVM_balance"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SVM_balance">[docs]</a><span class="k">class</span> <span class="nc">SVM_balance</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{svm_balance,</span>
<span class="sd">                     author = {Farquad, M.A.H. and Bose, Indranil},</span>
<span class="sd">                     title = {Preprocessing Unbalanced Data Using Support Vector Machine},</span>
<span class="sd">                     journal = {Decis. Support Syst.},</span>
<span class="sd">                     issue_date = {April, 2012},</span>
<span class="sd">                     volume = {53},</span>
<span class="sd">                     number = {1},</span>
<span class="sd">                     month = apr,</span>
<span class="sd">                     year = {2012},</span>
<span class="sd">                     issn = {0167-9236},</span>
<span class="sd">                     pages = {226--233},</span>
<span class="sd">                     numpages = {8},</span>
<span class="sd">                     url = {http://dx.doi.org/10.1016/j.dss.2012.01.016},</span>
<span class="sd">                     doi = {10.1016/j.dss.2012.01.016},</span>
<span class="sd">                     acmid = {2181554},</span>
<span class="sd">                     publisher = {Elsevier Science Publishers B. V.},</span>
<span class="sd">                     address = {Amsterdam, The Netherlands, The Netherlands},</span>
<span class="sd">                     keywords = {COIL data, Hybrid method, Preprocessor, SVM, Unbalanced data},</span>
<span class="sd">                    } </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_classifier</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">]</span>
    
<div class="viewcode-block" id="SVM_balance.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SVM_balance.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                        e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                        samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in the SMOTE sampling</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SVM_balance.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SVM_balance.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SVM_balance.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SVM_balance.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cv</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="mi">5</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)])</span>
        
        <span class="n">ss</span><span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="n">X_norm</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">C_params</span><span class="o">=</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]</span>
        <span class="n">best_score</span><span class="o">=</span> <span class="mi">0</span>
        <span class="n">best_C</span><span class="o">=</span> <span class="mf">0.01</span>
        <span class="k">for</span> <span class="n">C</span> <span class="ow">in</span> <span class="n">C_params</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Evaluating SVM with C=</span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">C</span><span class="p">)</span>
            <span class="n">svc</span><span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">C</span><span class="o">=</span> <span class="n">C</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span> <span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">)</span>
            <span class="n">score</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cross_val_score</span><span class="p">(</span><span class="n">svc</span><span class="p">,</span> <span class="n">X_norm</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cv</span><span class="o">=</span> <span class="n">cv</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">:</span>
                <span class="n">best_score</span><span class="o">=</span> <span class="n">score</span>
                <span class="n">best_C</span><span class="o">=</span> <span class="n">C</span>
        <span class="n">svc</span><span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">C</span><span class="o">=</span> <span class="n">best_C</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span> <span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">)</span>
        <span class="n">svc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_norm</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">X</span><span class="p">,</span> <span class="n">svc</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_norm</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SVM_balance.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SVM_balance.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="TRIM_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.TRIM_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">TRIM_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{trim_smote,</span>
<span class="sd">                            author=&quot;Puntumapon, Kamthorn</span>
<span class="sd">                            and Waiyamai, Kitsana&quot;,</span>
<span class="sd">                            editor=&quot;Tan, Pang-Ning</span>
<span class="sd">                            and Chawla, Sanjay</span>
<span class="sd">                            and Ho, Chin Kuan</span>
<span class="sd">                            and Bailey, James&quot;,</span>
<span class="sd">                            title=&quot;A Pruning-Based Approach for Searching Precise and Generalized Region for Synthetic Minority Over-Sampling&quot;,</span>
<span class="sd">                            booktitle=&quot;Advances in Knowledge Discovery and Data Mining&quot;,</span>
<span class="sd">                            year=&quot;2012&quot;,</span>
<span class="sd">                            publisher=&quot;Springer Berlin Heidelberg&quot;,</span>
<span class="sd">                            address=&quot;Berlin, Heidelberg&quot;,</span>
<span class="sd">                            pages=&quot;371--382&quot;,</span>
<span class="sd">                            abstract=&quot;One solution to deal with class imbalance is to modify its class distribution. Synthetic over-sampling is a well-known method to modify class distribution by generating new synthetic minority data. Synthetic Minority Over-sampling TEchnique (SMOTE) is a state-of-the-art synthetic over-sampling algorithm that generates new synthetic data along the line between the minority data and their selected nearest neighbors. Advantages of SMOTE is to have decision regions larger and less specific to original data. However, its drawback is the over-generalization problem where synthetic data is generated into majority class region. Over-generalization leads to misclassify non-minority class region into minority class. To overcome the over-generalization problem, we propose an algorithm, called TRIM, to search for precise minority region while maintaining its generalization. TRIM iteratively filters out irrelevant majority data from the precise minority region. Output of the algorithm is the multiple set of seed minority data, and each individual set will be used for generating new synthetic data. Compared with state-of-the-art over-sampling algorithms, experimental results show significant performance improvement in terms of F-measure and AUC. This suggests over-generalization has a significant impact on the performance of the synthetic over-sampling method.&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-642-30220-6&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * It is not described precisely how the filtered data is used for sample generation. The method is proposed to be a preprocessing step, and it states that it applies sample generation to each group extracted. </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">]</span>
    
<div class="viewcode-block" id="TRIM_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.TRIM_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">min_precision</span><span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">min_precision</span><span class="p">,</span> <span class="s1">&#39;min_precision&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_precision</span><span class="o">=</span> <span class="n">min_precision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="TRIM_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.TRIM_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;min_precision&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="TRIM_SMOTE.trim"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.TRIM_SMOTE.trim">[docs]</a>    <span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the trim value.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            y (np.array): array of target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: the trim value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="TRIM_SMOTE.precision"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.TRIM_SMOTE.precision">[docs]</a>    <span class="k">def</span> <span class="nf">precision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the precision value.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            y (np.array): array of target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: the precision value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="TRIM_SMOTE.determine_splitting_point"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.TRIM_SMOTE.determine_splitting_point">[docs]</a>    <span class="k">def</span> <span class="nf">determine_splitting_point</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">split_on_border</span><span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determines the splitting point.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): a subset of the training data</span>
<span class="sd">            y (np.array): an array of target labels</span>
<span class="sd">            split_on_border (bool): wether splitting on class borders is considered</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            tuple(int, float), bool: (splitting feature, splitting value), make the split</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">trim_value</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">d</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">max_t_minus_gain</span><span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">split</span><span class="o">=</span> <span class="kc">None</span>
        
        <span class="c1"># checking all dimensions of X</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="c1"># sort the elements in dimension i</span>
            <span class="n">sorted_X_y</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="n">y</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">pair</span><span class="p">:</span> <span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">sorted_y</span><span class="o">=</span> <span class="p">[</span><span class="n">yy</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">yy</span> <span class="ow">in</span> <span class="n">sorted_X_y</span><span class="p">]</span>
            
            <span class="c1"># number of minority samples on the left</span>
            <span class="n">left_min</span><span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># number of minority samples on the right</span>
            <span class="n">right_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sorted_y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span>
            
            <span class="c1"># check all possible splitting points sequentiall</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_y</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sorted_y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                    <span class="c1"># adjusting the number of minority and majority samples</span>
                    <span class="n">left_min</span><span class="o">=</span> <span class="n">left_min</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">right_min</span><span class="o">=</span> <span class="n">right_min</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="c1"># checking of we can split on the border and do not split tieing feature values</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">split_on_border</span> <span class="o">==</span> <span class="kc">False</span> <span class="ow">or</span> <span class="p">(</span><span class="n">split_on_border</span> <span class="o">==</span> <span class="kc">True</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sorted_y</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">sorted_y</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span> <span class="ow">and</span> <span class="n">sorted_X_y</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">sorted_X_y</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="c1"># compute trim value of the left</span>
                    <span class="n">trim_left</span><span class="o">=</span> <span class="n">left_min</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># compute trim value of the right</span>
                    <span class="n">trim_right</span><span class="o">=</span> <span class="n">right_min</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_y</span><span class="p">)</span> <span class="o">-</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># let&#39;s check the gain</span>
                    <span class="k">if</span> <span class="nb">max</span><span class="p">([</span><span class="n">trim_left</span><span class="p">,</span> <span class="n">trim_right</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_t_minus_gain</span><span class="p">:</span>
                        <span class="n">max_t_minus_gain</span><span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="n">trim_left</span><span class="p">,</span> <span class="n">trim_right</span><span class="p">])</span>
                        <span class="n">split</span><span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">sorted_X_y</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># return splitting values and the value of the logical condition in line 9</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">split</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">split</span><span class="p">,</span> <span class="n">max_t_minus_gain</span> <span class="o">&gt;</span> <span class="n">trim_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="kc">False</span></div>
    
<div class="viewcode-block" id="TRIM_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.TRIM_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">leafs</span><span class="o">=</span> <span class="p">[(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
        <span class="n">candidates</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">seeds</span><span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># executing the trimming</span>
        <span class="c1"># loop in line 2 of the paper</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;do the trimming process&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">leafs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">add_to_leafs</span><span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># executing the loop starting in line 3</span>
            <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">leafs</span><span class="p">:</span>
                <span class="c1"># the function implements the loop starting in line 6</span>
                <span class="c1"># splitting on class border is forced</span>
                <span class="n">split</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_splitting_point</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># small leafs with 1 element (no splitting point) are dropped</span>
                    <span class="c1"># as noise</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># condition in line 9</span>
                    <span class="k">if</span> <span class="n">gain</span><span class="p">:</span>
                        <span class="c1"># making the split</span>
                        <span class="n">mask_left</span><span class="o">=</span> <span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">split</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">split</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">X_left</span><span class="p">,</span> <span class="n">y_left</span><span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mask_left</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">mask_left</span><span class="p">]</span>
                        <span class="n">mask_right</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mask_left</span><span class="p">)</span>
                        <span class="n">X_right</span><span class="p">,</span> <span class="n">y_right</span><span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mask_right</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">mask_right</span><span class="p">]</span>
                        
                        <span class="c1"># condition in line 11</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_left</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">add_to_leafs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">X_left</span><span class="p">,</span> <span class="n">y_left</span><span class="p">))</span>
                        <span class="c1"># condition in line 13</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_right</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">add_to_leafs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">X_right</span><span class="p">,</span> <span class="n">y_right</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># line 16</span>
                        <span class="n">candidates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="c1"># we implement line 15 and 18 by replacing the list of leafs by</span>
            <span class="c1"># the list of new leafs.</span>
            <span class="n">leafs</span><span class="o">=</span> <span class="n">add_to_leafs</span>

            <span class="c1"># iterating through all candidates (loop starting in line 21)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
                <span class="c1"># extracting splitting points, this time split on border is not forced</span>
                <span class="n">split</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_splitting_point</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># small leafs are dropped as noise</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># checking condition in line 27</span>
                    <span class="k">if</span> <span class="n">gain</span><span class="p">:</span>
                        <span class="c1"># doing the split</span>
                        <span class="n">mask_left</span><span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][:,</span><span class="n">split</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&lt;=</span> <span class="n">split</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">X_left</span><span class="p">,</span> <span class="n">y_left</span><span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mask_left</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">mask_left</span><span class="p">]</span>
                        <span class="n">mask_right</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">mask_left</span><span class="p">)</span>
                        <span class="n">X_right</span><span class="p">,</span> <span class="n">y_right</span><span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">mask_right</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">mask_right</span><span class="p">]</span>
                        <span class="c1"># checking logic in line 29</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_left</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">leafs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">X_left</span><span class="p">,</span> <span class="n">y_left</span><span class="p">))</span>
                        <span class="c1"># checking logic in line 31</span>
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_right</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">leafs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">X_right</span><span class="p">,</span> <span class="n">y_right</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># adding candidate to seeds (line 35)</span>
                        <span class="n">seeds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
            <span class="c1"># line 33 and line 36 are implemented by emptying the candidates list</span>
            <span class="n">candidates</span><span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># filtering the resulting set</span>
        <span class="n">filtered_seeds</span><span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seeds</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_precision</span><span class="p">]</span>
        
        <span class="c1"># handling the situation when no seeds were found</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seeds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;no seeds identified&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># fix for bad choice of min_precision</span>
        <span class="n">multiplier</span><span class="o">=</span> <span class="mf">0.9</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_seeds</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">filtered_seeds</span><span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seeds</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">precision</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_precision</span><span class="o">*</span><span class="n">multiplier</span><span class="p">]</span>
            <span class="n">multiplier</span><span class="o">=</span> <span class="n">multiplier</span><span class="o">*</span><span class="mf">0.9</span>
            <span class="k">if</span> <span class="n">multiplier</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;no clusters passing the filtering&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">seeds</span><span class="o">=</span> <span class="n">filtered_seeds</span>
        
        <span class="n">X_seed</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seeds</span><span class="p">])</span>
        <span class="n">y_seed</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">seeds</span><span class="p">])</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;do the sampling&quot;</span><span class="p">)</span>
        <span class="c1"># generating samples by SMOTE</span>
        <span class="n">X_seed_min</span><span class="o">=</span> <span class="n">X_seed</span><span class="p">[</span><span class="n">y_seed</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_seed_min</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;X_seed_min contains less than 2 samples&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_seed_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_seed_min</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_seed_min</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_seed_min</span><span class="p">))</span>
            <span class="n">random_neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">random_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_seed_min</span><span class="p">[</span><span class="n">random_idx</span><span class="p">],</span> <span class="n">X_seed_min</span><span class="p">[</span><span class="n">random_neighbor_idx</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="TRIM_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.TRIM_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;min_precision&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_precision</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SMOTE_RSB"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_RSB">[docs]</a><span class="k">class</span> <span class="nc">SMOTE_RSB</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @Article{smote_rsb,</span>
<span class="sd">                    author=&quot;Ramentol, Enislay</span>
<span class="sd">                    and Caballero, Yail{\&#39;e}</span>
<span class="sd">                    and Bello, Rafael</span>
<span class="sd">                    and Herrera, Francisco&quot;,</span>
<span class="sd">                    title=&quot;SMOTE-RSB*: a hybrid preprocessing approach based on oversampling and undersampling for high imbalanced data-sets using SMOTE and rough sets theory&quot;,</span>
<span class="sd">                    journal=&quot;Knowledge and Information Systems&quot;,</span>
<span class="sd">                    year=&quot;2012&quot;,</span>
<span class="sd">                    month=&quot;Nov&quot;,</span>
<span class="sd">                    day=&quot;01&quot;,</span>
<span class="sd">                    volume=&quot;33&quot;,</span>
<span class="sd">                    number=&quot;2&quot;,</span>
<span class="sd">                    pages=&quot;245--265&quot;,</span>
<span class="sd">                    abstract=&quot;Imbalanced data is a common problem in classification. This phenomenon is growing in importance since it appears in most real domains. It has special relevance to highly imbalanced data-sets (when the ratio between classes is high). Many techniques have been developed to tackle the problem of imbalanced training sets in supervised learning. Such techniques have been divided into two large groups: those at the algorithm level and those at the data level. Data level groups that have been emphasized are those that try to balance the training sets by reducing the larger class through the elimination of samples or increasing the smaller one by constructing new samples, known as undersampling and oversampling, respectively. This paper proposes a new hybrid method for preprocessing imbalanced data-sets through the construction of new samples, using the Synthetic Minority Oversampling Technique together with the application of an editing technique based on the Rough Set Theory and the lower approximation of a subset. The proposed method has been validated by an experimental study showing good results using C4.5 as the learning algorithm.&quot;,</span>
<span class="sd">                    issn=&quot;0219-3116&quot;,</span>
<span class="sd">                    doi=&quot;10.1007/s10115-011-0465-6&quot;,</span>
<span class="sd">                    url=&quot;https://doi.org/10.1007/s10115-011-0465-6&quot;</span>
<span class="sd">                    }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * I think the description of the algorithm in Fig 5 of the paper is not correct. The set &quot;resultSet&quot; is initialized with the original instances, and then the While loop in the Algorithm run until resultSet is empty, which never holds. Also, the resultSet is only extended in the loop. Our implementation is changed in the following way: we generate twice as many instances are required to balance the dataset, and repeat the loop until the number of new samples added to the training set is enough to balance the dataset.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE_RSB.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_RSB.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in the SMOTE sampling</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMOTE_RSB.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_RSB.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SMOTE_RSB.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_RSB.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># Step 1: do the sampling</span>
        <span class="n">smote</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">smote</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">X_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):],</span> <span class="n">y_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_samp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Step 2: (original will be added later)</span>
        <span class="n">result_set</span><span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Step 3: first the data is normalized</span>
        <span class="n">maximums</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X_samp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">minimums</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">X_samp</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># normalize X_new and X_maj</span>
        <span class="n">norm_factor</span><span class="o">=</span> <span class="n">maximums</span> <span class="o">-</span> <span class="n">minimums</span>
        <span class="n">norm_factor</span><span class="p">[</span><span class="n">norm_factor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">maximums</span><span class="p">[</span><span class="n">norm_factor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm_factor</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">X_samp_norm</span><span class="o">=</span> <span class="n">X_samp</span> <span class="o">/</span> <span class="n">norm_factor</span>
        <span class="n">X_maj_norm</span><span class="o">=</span> <span class="n">X_maj</span> <span class="o">/</span> <span class="n">norm_factor</span>
        
        <span class="c1"># compute similarity matrix</span>
        <span class="n">similarity_matrix</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_samp_norm</span><span class="p">,</span> <span class="n">X_maj_norm</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span> <span class="s1">&#39;minkowski&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># Step 4: counting the similar examples</span>
        <span class="n">similarity_value</span><span class="o">=</span> <span class="mf">0.4</span>
        <span class="n">syn</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_samp</span><span class="p">)</span>
        <span class="n">cont</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">syn</span><span class="p">)</span>
        
        <span class="n">already_added</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_samp</span><span class="p">))</span>
        
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_set</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span> <span class="ow">and</span> <span class="n">similarity_value</span> <span class="o">&lt;=</span> <span class="mf">0.9</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">syn</span><span class="p">):</span>
                <span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">similarity_matrix</span><span class="p">[</span><span class="n">i</span><span class="p">,:]</span> <span class="o">&gt;</span> <span class="n">similarity_value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">cont</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">already_added</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">result_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_samp</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">already_added</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="kc">True</span>
            <span class="n">similarity_value</span><span class="o">=</span> <span class="n">similarity_value</span> <span class="o">+</span> <span class="mf">0.05</span>
        
        <span class="c1"># Step 5: returning the results depending the number of instances added to the result set</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">result_set</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_set</span><span class="p">))])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">X_samp</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">y_samp</span><span class="p">])</span></div>
        
<div class="viewcode-block" id="SMOTE_RSB.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_RSB.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="ProWSyn"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ProWSyn">[docs]</a><span class="k">class</span> <span class="nc">ProWSyn</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{prowsyn,</span>
<span class="sd">                        author=&quot;Barua, Sukarna</span>
<span class="sd">                        and Islam, Md. Monirul</span>
<span class="sd">                        and Murase, Kazuyuki&quot;,</span>
<span class="sd">                        editor=&quot;Pei, Jian</span>
<span class="sd">                        and Tseng, Vincent S.</span>
<span class="sd">                        and Cao, Longbing</span>
<span class="sd">                        and Motoda, Hiroshi</span>
<span class="sd">                        and Xu, Guandong&quot;,</span>
<span class="sd">                        title=&quot;ProWSyn: Proximity Weighted Synthetic Oversampling Technique for Imbalanced Data Set Learning&quot;,</span>
<span class="sd">                        booktitle=&quot;Advances in Knowledge Discovery and Data Mining&quot;,</span>
<span class="sd">                        year=&quot;2013&quot;,</span>
<span class="sd">                        publisher=&quot;Springer Berlin Heidelberg&quot;,</span>
<span class="sd">                        address=&quot;Berlin, Heidelberg&quot;,</span>
<span class="sd">                        pages=&quot;317--328&quot;,</span>
<span class="sd">                        abstract=&quot;An imbalanced data set creates severe problems for the classifier as number of samples of one class (majority) is much higher than the other class (minority). Synthetic oversampling methods address this problem by generating new synthetic minority class samples. To distribute the synthetic samples effectively, recent approaches create weight values for original minority samples based on their importance and distribute synthetic samples according to weight values. However, most of the existing algorithms create inappropriate weights and in many cases, they cannot generate the required weight values for the minority samples. This results in a poor distribution of generated synthetic samples. In this respect, this paper presents a new synthetic oversampling algorithm, Proximity Weighted Synthetic Oversampling Technique (ProWSyn). Our proposed algorithm generate effective weight values for the minority data samples based on sample&#39;s proximity information, i.e., distance from boundary which results in a proper distribution of generated synthetic samples across the minority data set. Simulation results on some real world datasets shows the effectiveness of the proposed method showing improvements in various assessment metrics such as AUC, F-measure, and G-mean.&quot;,</span>
<span class="sd">                        isbn=&quot;978-3-642-37456-2&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="ProWSyn.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ProWSyn.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in nearest neighbors component</span>
<span class="sd">            L (int): number of levels</span>
<span class="sd">            theta (float): smoothing factor in weight formula</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">L</span><span class="p">,</span> <span class="s2">&quot;L&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="s2">&quot;theta&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="o">=</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">=</span> <span class="n">theta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ProWSyn.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ProWSyn.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="ProWSyn.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ProWSyn.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># Step 1 - a bit generalized</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Step 2</span>
        <span class="n">P</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="n">Ps</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">proximity_levels</span><span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Step 3</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="c1"># Step 3 a</span>
            <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">P</span><span class="p">])</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
            
            <span class="c1"># Step 3 b</span>
            <span class="n">P_i</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">]))</span>
            
            <span class="c1"># Step 3 c - proximity levels are encoded in the Ps list index</span>
            <span class="n">Ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">P_i</span><span class="p">])</span>
            <span class="n">proximity_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># Step 3 d</span>
            <span class="n">P</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">P_i</span><span class="p">)</span>
        
        <span class="c1"># Step 4</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Ps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
        
        <span class="c1"># Step 5</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">proximity_levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">proximity_levels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proximity_levels</span><span class="p">)</span>
        
        <span class="c1"># Step 6</span>
        <span class="n">weights</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="o">*</span><span class="p">(</span><span class="n">proximity_levels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">proximity_levels</span><span class="p">))])</span>
        <span class="c1"># weights is the probability distribution of sampling in the clusters identified</span>
        <span class="n">weights</span><span class="o">=</span> <span class="n">weights</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        
        <span class="n">suitable</span><span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">weights</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">suitable</span><span class="o">=</span> <span class="kc">True</span>
                
        <span class="k">if</span> <span class="ow">not</span> <span class="n">suitable</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># do the sampling, from each cluster proportionally to the distribution</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">cluster_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Ps</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">random_idx1</span><span class="p">,</span> <span class="n">random_idx2</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">Ps</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">random_idx1</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">random_idx2</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="ProWSyn.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ProWSyn.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;L&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">L</span><span class="p">,</span> 
                <span class="s1">&#39;theta&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SL_graph_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SL_graph_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">SL_graph_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @inproceedings{sl_graph_smote,</span>
<span class="sd">                    author = {Bunkhumpornpat, Chumpol and Subpaiboonkit, Sitthichoke},</span>
<span class="sd">                    booktitle= {13th International Symposium on Communications and Information Technologies},</span>
<span class="sd">                    year = {2013},</span>
<span class="sd">                    month = {09},</span>
<span class="sd">                    pages = {570-575},</span>
<span class="sd">                    title = {Safe level graph for synthetic minority over-sampling techniques},</span>
<span class="sd">                    isbn = {978-1-4673-5578-0}</span>
<span class="sd">                    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">]</span>
    
<div class="viewcode-block" id="SL_graph_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SL_graph_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in nearest neighbors component</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SL_graph_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SL_graph_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SL_graph_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SL_graph_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Fitting nearest neighbors model</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="c1"># Computing safe level values</span>
        <span class="n">safe_level_values</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">])</span>
        
        <span class="c1"># Computing skewness</span>
        <span class="n">skewness</span><span class="o">=</span> <span class="n">skew</span><span class="p">(</span><span class="n">safe_level_values</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">skewness</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># left skewed</span>
            <span class="n">s</span><span class="o">=</span> <span class="n">Safe_Level_SMOTE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># right skewed</span>
            <span class="n">s</span><span class="o">=</span> <span class="n">Borderline_SMOTE1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SL_graph_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SL_graph_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="NRSBoundary_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NRSBoundary_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">NRSBoundary_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @Article{nrsboundary_smote,</span>
<span class="sd">                    author= {Feng, Hu and Hang, Li},</span>
<span class="sd">                    title= {A Novel Boundary Oversampling Algorithm Based on Neighborhood Rough Set Model: NRSBoundary-SMOTE},</span>
<span class="sd">                    journal= {Mathematical Problems in Engineering},</span>
<span class="sd">                    year= {2013},</span>
<span class="sd">                    pages= {10},</span>
<span class="sd">                    doi= {10.1155/2013/694809},</span>
<span class="sd">                    url= {http://dx.doi.org/10.1155/694809}</span>
<span class="sd">                    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">]</span>
    
<div class="viewcode-block" id="NRSBoundary_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NRSBoundary_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in nearest neighbors component</span>
<span class="sd">            w (float): used to set neighborhood radius</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="NRSBoundary_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NRSBoundary_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.005</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="NRSBoundary_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NRSBoundary_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># step 1</span>
        <span class="n">bound_set</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">pos_set</span><span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># step 2</span>
        <span class="n">X_min_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">X_min_indices</span><span class="p">]</span>
        
        <span class="c1"># step 3</span>
        <span class="n">dm</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
        <span class="n">d_max</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">max_dist</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">fill_diagonal</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">)</span>
        <span class="n">d_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">delta</span><span class="o">=</span> <span class="n">d_min</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">*</span><span class="p">(</span><span class="n">d_max</span> <span class="o">-</span> <span class="n">d_min</span><span class="p">)</span>
        
        <span class="c1"># number of neighbors is not interesting here, as we use the</span>
        <span class="c1"># radius_neighbors function to extract the neighbors in a given radius</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
            <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">delta</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">return_distance</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">bound_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">pos_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="n">bound_set</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">bound_set</span><span class="p">)</span>
        <span class="n">pos_set</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pos_set</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pos_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">bound_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># step 4 and 5</span>
        <span class="c1"># computing the nearest neighbors of the bound set from the minority set</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">bound_set</span><span class="p">])</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">trials</span><span class="o">=</span> <span class="mi">0</span>
        <span class="n">w</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bound_set</span><span class="p">))</span>
            <span class="n">random_neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">x_new</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">bound_set</span><span class="p">[</span><span class="n">idx</span><span class="p">]],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_neighbor_idx</span><span class="p">])</span>
            
            <span class="c1"># checking the conflict</span>
            <span class="n">dist_from_pos_set</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">pos_set</span><span class="p">]</span> <span class="o">-</span> <span class="n">x_new</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dist_from_pos_set</span> <span class="o">&gt;</span> <span class="n">delta</span><span class="p">[</span><span class="n">pos_set</span><span class="p">]):</span>
                <span class="c1"># no conflict</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
            <span class="n">trials</span><span class="o">=</span> <span class="n">trials</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">trials</span> <span class="o">&gt;</span> <span class="mi">1000</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">trials</span><span class="o">=</span> <span class="mi">0</span>
                <span class="n">w</span><span class="o">=</span> <span class="n">w</span><span class="o">*</span><span class="mf">0.9</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="NRSBoundary_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NRSBoundary_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="LVQ_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LVQ_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">LVQ_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @inproceedings{lvq_smote,</span>
<span class="sd">                              title={LVQ-SMOTE – Learning Vector Quantization based Synthetic Minority Over–sampling Technique for biomedical data},</span>
<span class="sd">                              author={Munehiro Nakamura and Yusuke Kajiwara and Atsushi Otsuka and Haruhiko Kimura},</span>
<span class="sd">                              booktitle={BioData Mining},</span>
<span class="sd">                              year={2013}</span>
<span class="sd">                            }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * This implementation is only a rough estimation of the method described in the paper. The main problem is that the paper uses many datasets to find similar patterns in the codebooks and replicate patterns appearing in other datasets to the imbalanced datasets based on their relative position compared to the codebook elements. What we do is clustering the minority class to extract a codebook as kmeans cluster means, then, find pairs of codebook elements which have the most similar relative position to a randomly selected pair of codebook elements, and translate nearby minority samples from the neighborhood one pair of codebook elements to the neighborood of another pair of codebook elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_application</span><span class="p">]</span>
    
<div class="viewcode-block" id="LVQ_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LVQ_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in nearest neighbors component</span>
<span class="sd">            n_clusters (int): number of clusters in vector quantization</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="s2">&quot;n_clusters&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>

<div class="viewcode-block" id="LVQ_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LVQ_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">12</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="LVQ_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LVQ_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># clustering X_min to extract codebook</span>
        <span class="n">kmeans</span><span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">codebook</span><span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
        
        <span class="c1"># get nearest neighbors of minority samples to codebook samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">codebook</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="c1"># randomly selecting a pair of codebook elements</span>
            <span class="n">cb_0</span><span class="p">,</span> <span class="n">cb_1</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codebook</span><span class="p">))),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">diff</span><span class="o">=</span> <span class="n">codebook</span><span class="p">[</span><span class="n">cb_0</span><span class="p">]</span> <span class="o">-</span> <span class="n">codebook</span><span class="p">[</span><span class="n">cb_1</span><span class="p">]</span>
            <span class="n">min_dist</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">min_0</span><span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># finding another pair of codebook elements with similar offset</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codebook</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">codebook</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">cb_0</span> <span class="o">!=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">cb_0</span> <span class="o">!=</span> <span class="n">j</span> <span class="ow">and</span> <span class="n">cb_1</span> <span class="o">!=</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">cb_1</span> <span class="o">!=</span> <span class="n">j</span><span class="p">:</span>
                        <span class="n">dd</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">diff</span> <span class="o">-</span> <span class="p">(</span><span class="n">codebook</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">codebook</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span>
                        <span class="k">if</span> <span class="n">dd</span> <span class="o">&lt;</span> <span class="n">min_dist</span><span class="p">:</span>
                            <span class="n">min_dist</span><span class="o">=</span> <span class="n">dd</span>
                            <span class="n">min_0</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">])</span>
            
            <span class="c1"># translating a random neighbor of codebook element min_0 to </span>
            <span class="c1"># the neighborhood of point_0</span>
            <span class="n">point_0</span><span class="o">=</span> <span class="n">codebook</span><span class="p">[</span><span class="n">cb_0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">min_0</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">min_0</span><span class="p">]))]]</span> <span class="o">-</span> <span class="n">codebook</span><span class="p">[</span><span class="n">min_0</span><span class="p">])</span>
            
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">point_0</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="LVQ_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LVQ_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SOI_CJ"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOI_CJ">[docs]</a><span class="k">class</span> <span class="nc">SOI_CJ</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{soi_cj,</span>
<span class="sd">                    author = {Sánchez, Atlántida I. and Morales, Eduardo and Gonzalez, Jesus},</span>
<span class="sd">                    year = {2013},</span>
<span class="sd">                    month = {01},</span>
<span class="sd">                    pages = {},</span>
<span class="sd">                    title = {Synthetic Oversampling of Instances Using Clustering},</span>
<span class="sd">                    volume = {22},</span>
<span class="sd">                    booktitle = {International Journal of Artificial Intelligence Tools}</span>
<span class="sd">                    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_componentwise</span><span class="p">]</span>
    
<div class="viewcode-block" id="SOI_CJ.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOI_CJ.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span> <span class="s1">&#39;interpolation&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of nearest neighbors in the SMOTE sampling</span>
<span class="sd">            method (str): &#39;interpolation&#39;/&#39;jittering&#39;</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_isin</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;interpolation&#39;</span><span class="p">,</span> <span class="s1">&#39;jittering&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SOI_CJ.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOI_CJ.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;interpolation&#39;</span><span class="p">,</span> <span class="s1">&#39;jittering&#39;</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SOI_CJ.clustering"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOI_CJ.clustering">[docs]</a>    <span class="k">def</span> <span class="nf">clustering</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of the clustering technique described in the paper.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): array of training instances</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(set): list of minority clusters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nn_all</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn_all</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># extract nearest neighbors of all samples from the set of minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># initialize clusters by minority samples </span>
        <span class="n">clusters</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)):</span>
            <span class="c1"># empty cluster added</span>
            <span class="n">clusters</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span>
            <span class="c1"># while the closest instance is from the minority class, adding it to the cluster</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                    <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">break</span>
        
        <span class="c1"># cluster merging phase</span>
        <span class="n">is_intersection</span><span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">is_intersection</span><span class="p">:</span>
            <span class="n">is_intersection</span><span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
                    <span class="c1"># computing intersection</span>
                    <span class="n">intersection</span><span class="o">=</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">is_intersection</span><span class="o">=</span> <span class="kc">True</span>
                        <span class="c1"># computing distance matrix</span>
                        <span class="n">dm</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">])],</span> <span class="n">X</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">])])</span>
                        <span class="c1"># largest distance</span>
                        <span class="n">max_dist_pair</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dm</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dm</span><span class="p">))</span>
                        <span class="c1"># elements with the largest distance</span>
                        <span class="n">max_i</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="n">max_dist_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]]</span>
                        <span class="n">max_j</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">])[</span><span class="n">max_dist_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]]</span>
                        
                        <span class="c1"># finding midpoint and radius</span>
                        <span class="n">mid_point</span><span class="o">=</span> <span class="p">(</span><span class="n">max_i</span> <span class="o">+</span> <span class="n">max_j</span><span class="p">)</span><span class="o">/</span><span class="mf">2.0</span>
                        <span class="n">radius</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">mid_point</span> <span class="o">-</span> <span class="n">max_i</span><span class="p">)</span>
                        
                        <span class="c1"># extracting points within the hypersphare of radius &quot;radius&quot;</span>
                        <span class="n">indices</span><span class="o">=</span> <span class="n">nn_all</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">mid_point</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">radius</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                        
                        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                            <span class="c1"># if most of the covered elements come from the minority class, merge clusters</span>
                            <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                            <span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="c1"># otherwise move the difference to the bigger cluster</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">]):</span>
                                <span class="n">clusters</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="n">intersection</span><span class="p">)</span>

        <span class="c1"># returning non-empty clusters</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="SOI_CJ.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOI_CJ.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">std_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># do the clustering</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Executing clustering&quot;</span><span class="p">)</span>
        <span class="n">clusters</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clustering</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># filtering the clusters, at least two points in a cluster are needed</span>
        <span class="c1"># for both interpolation and jittering (due to the standard deviation)</span>
        <span class="n">clusters_filtered</span><span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters_filtered</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if there are clusters having at least 2 elements, do the sampling</span>
            <span class="n">cluster_nums</span><span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters_filtered</span><span class="p">]</span>
            <span class="n">cluster_weights</span><span class="o">=</span> <span class="n">cluster_nums</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cluster_nums</span><span class="p">)</span>
            <span class="n">cluster_stds</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">clusters_filtered</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters_filtered</span><span class="p">))]</span>
            
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Executing sample generation&quot;</span><span class="p">)</span>
            <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
                <span class="n">cluster_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters_filtered</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">cluster_weights</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;interpolation&#39;</span><span class="p">:</span>
                    <span class="n">idx_0</span><span class="p">,</span> <span class="n">idx_1</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">clusters_filtered</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points_componentwise</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx_0</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">idx_1</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;jittering&#39;</span><span class="p">:</span>
                    <span class="n">std</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">std_min</span><span class="p">,</span> <span class="n">cluster_stds</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">clusters_filtered</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_by_jittering_componentwise</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">std</span><span class="p">))</span>
            
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># otherwise fall back to standard smote</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;No clusters with more than 2 elements&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="SOI_CJ.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOI_CJ.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="ROSE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ROSE">[docs]</a><span class="k">class</span> <span class="nc">ROSE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @Article{rose,</span>
<span class="sd">                    author=&quot;Menardi, Giovanna</span>
<span class="sd">                    and Torelli, Nicola&quot;,</span>
<span class="sd">                    title=&quot;Training and assessing classification rules with imbalanced data&quot;,</span>
<span class="sd">                    journal=&quot;Data Mining and Knowledge Discovery&quot;,</span>
<span class="sd">                    year=&quot;2014&quot;,</span>
<span class="sd">                    month=&quot;Jan&quot;,</span>
<span class="sd">                    day=&quot;01&quot;,</span>
<span class="sd">                    volume=&quot;28&quot;,</span>
<span class="sd">                    number=&quot;1&quot;,</span>
<span class="sd">                    pages=&quot;92--122&quot;,</span>
<span class="sd">                    abstract=&quot;The problem of modeling binary responses by using cross-sectional data has been addressed with a number of satisfying solutions that draw on both parametric and nonparametric methods. However, there exist many real situations where one of the two responses (usually the most interesting for the analysis) is rare. It has been largely reported that this class imbalance heavily compromises the process of learning, because the model tends to focus on the prevalent class and to ignore the rare events. However, not only the estimation of the classification model is affected by a skewed distribution of the classes, but also the evaluation of its accuracy is jeopardized, because the scarcity of data leads to poor estimates of the model&#39;s accuracy. In this work, the effects of class imbalance on model training and model assessing are discussed. Moreover, a unified and systematic framework for dealing with the problem of imbalanced classification is proposed, based on a smoothed bootstrap re-sampling technique. The proposed technique is founded on a sound theoretical basis and an extensive empirical study shows that it outperforms the main other remedies to face imbalanced learning problems.&quot;,</span>
<span class="sd">                    issn=&quot;1573-756X&quot;,</span>
<span class="sd">                    doi=&quot;10.1007/s10618-012-0295-5&quot;,</span>
<span class="sd">                    url=&quot;https://doi.org/10.1007/s10618-012-0295-5&quot;</span>
<span class="sd">                    }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * It is not entirely clear if the authors propose kernel density estimation \</span>
<span class="sd">        or the fitting of simple multivariate Gaussians on the minority samples. \</span>
<span class="sd">        The latter seems to be more likely, I implement that approach.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_componentwise</span><span class="p">]</span>
    
<div class="viewcode-block" id="ROSE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ROSE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="ROSE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ROSE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="ROSE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ROSE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># Estimating the H matrix</span>
        <span class="n">std</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">d</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">n</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">H</span><span class="o">=</span> <span class="n">std</span><span class="o">*</span><span class="p">(</span><span class="mf">4.0</span><span class="o">/</span><span class="p">((</span><span class="n">d</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">n</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">d</span> <span class="o">+</span> <span class="mi">4</span><span class="p">))</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_by_gaussian_jittering</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">random_idx</span><span class="p">],</span> <span class="n">H</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="ROSE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ROSE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SMOTE_OUT"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_OUT">[docs]</a><span class="k">class</span> <span class="nc">SMOTE_OUT</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smote_out_smote_cosine_selected_smote,</span>
<span class="sd">                      title={SMOTE-Out, SMOTE-Cosine, and Selected-SMOTE: An enhancement strategy to handle imbalance in data level},</span>
<span class="sd">                      author={Fajri Koto},</span>
<span class="sd">                      journal={2014 International Conference on Advanced Computer Science and Information System},</span>
<span class="sd">                      year={2014},</span>
<span class="sd">                      pages={280-284}</span>
<span class="sd">                    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE_OUT.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_OUT.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): parameter of the NearestNeighbors component</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMOTE_OUT.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_OUT.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SMOTE_OUT.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_OUT.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="n">minority_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># nearest neighbors among minority points</span>
        <span class="n">nn_min</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">min_distances</span><span class="p">,</span> <span class="n">min_indices</span><span class="o">=</span> <span class="n">nn_min</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="c1"># nearest neighbors among majority points</span>
        <span class="n">nn_maj</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        <span class="n">maj_distances</span><span class="p">,</span> <span class="n">maj_indices</span><span class="o">=</span> <span class="n">nn_maj</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># generate samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="c1"># implementation of Algorithm 1 in the paper</span>
            <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minority_indices</span><span class="p">)))</span>
            <span class="n">u</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">minority_indices</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]]</span>
            <span class="n">v</span><span class="o">=</span> <span class="n">X_maj</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">maj_indices</span><span class="p">[</span><span class="n">random_idx</span><span class="p">])]</span>
            <span class="n">dif1</span><span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>
            <span class="n">uu</span><span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="mf">0.3</span><span class="o">*</span><span class="n">dif1</span>
            <span class="n">x</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">min_indices</span><span class="p">[</span><span class="n">random_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span>
            <span class="n">dif2</span><span class="o">=</span> <span class="n">uu</span> <span class="o">-</span> <span class="n">x</span>
            <span class="n">w</span><span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">dif2</span>
            
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="SMOTE_OUT.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_OUT.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SMOTE_Cosine"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_Cosine">[docs]</a><span class="k">class</span> <span class="nc">SMOTE_Cosine</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smote_out_smote_cosine_selected_smote,</span>
<span class="sd">                      title={SMOTE-Out, SMOTE-Cosine, and Selected-SMOTE: An enhancement strategy to handle imbalance in data level},</span>
<span class="sd">                      author={Fajri Koto},</span>
<span class="sd">                      journal={2014 International Conference on Advanced Computer Science and Information System},</span>
<span class="sd">                      year={2014},</span>
<span class="sd">                      pages={280-284}</span>
<span class="sd">                    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE_Cosine.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_Cosine.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): parameter of the NearestNeighbors component</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMOTE_Cosine.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_Cosine.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SMOTE_Cosine.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_Cosine.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="n">minority_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Fitting the nearest neighbors models to the minority and majority data</span>
        <span class="c1"># using two different metrics for the minority</span>
        <span class="n">nn_min_euc</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">nn_min_euc_dist</span><span class="p">,</span> <span class="n">nn_min_euc_ind</span><span class="o">=</span> <span class="n">nn_min_euc</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">nn_min_cos</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span> <span class="s1">&#39;cosine&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">nn_min_cos_dist</span><span class="p">,</span> <span class="n">nn_min_cos_ind</span><span class="o">=</span> <span class="n">nn_min_cos</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">nn_maj</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        <span class="n">nn_maj_dist</span><span class="p">,</span> <span class="n">nn_maj_ind</span><span class="o">=</span> <span class="n">nn_maj</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minority_indices</span><span class="p">)))</span>
            <span class="n">u</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">minority_indices</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]]</span>
            <span class="c1"># get the rank of each minority sample according to their distance from u</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">sorted_by_euc_ind</span><span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nn_min_euc_ind</span><span class="p">[</span><span class="n">random_idx</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">sorted_by_cos_ind</span><span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">nn_min_cos_ind</span><span class="p">[</span><span class="n">random_idx</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="c1"># adding the ranks to get the composite similarity measure (called voting in the paper)</span>
            <span class="n">ranked_min_indices</span><span class="o">=</span> <span class="n">sorted_by_euc_ind</span> <span class="o">+</span> <span class="n">sorted_by_cos_ind</span>
            <span class="c1"># sorting the ranking</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">sorted_ranking</span><span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ranked_min_indices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="c1"># get the indices of the n_neighbors nearest neighbors according to the composite metrics</span>
            <span class="n">min_indices</span><span class="o">=</span> <span class="n">sorted_ranking</span><span class="p">[</span><span class="mi">1</span><span class="p">:(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

            <span class="n">v</span><span class="o">=</span> <span class="n">X_maj</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">nn_maj_ind</span><span class="p">[</span><span class="n">random_idx</span><span class="p">])]</span>
            <span class="n">dif1</span><span class="o">=</span> <span class="n">u</span> <span class="o">-</span> <span class="n">v</span>
            <span class="n">uu</span><span class="o">=</span> <span class="n">u</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="mf">0.3</span><span class="o">*</span><span class="n">dif1</span>
            <span class="n">x</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">min_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:])]</span>
            <span class="n">dif2</span><span class="o">=</span> <span class="n">uu</span> <span class="o">-</span> <span class="n">x</span>
            <span class="n">w</span><span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="mf">0.5</span><span class="o">*</span><span class="n">dif2</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="SMOTE_Cosine.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_Cosine.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="Selected_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Selected_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">Selected_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">        @article{smote_out_smote_cosine_selected_smote,</span>
<span class="sd">                  title={SMOTE-Out, SMOTE-Cosine, and Selected-SMOTE: An enhancement strategy to handle imbalance in data level},</span>
<span class="sd">                  author={Fajri Koto},</span>
<span class="sd">                  journal={2014 International Conference on Advanced Computer Science and Information System},</span>
<span class="sd">                  year={2014},</span>
<span class="sd">                  pages={280-284}</span>
<span class="sd">                }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Significant attribute selection was not described in the paper, therefore we have implemented something meaningful.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_componentwise</span><span class="p">]</span>
    
<div class="viewcode-block" id="Selected_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Selected_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">perc_sign_attr</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            strategy (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): parameter of the NearestNeighbors component</span>
<span class="sd">            perc_sign_attr (float): [0,1] - percentage of significant attributes</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s1">&#39;n_neighbors&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">perc_sign_attr</span><span class="p">,</span> <span class="s1">&#39;perc_sign_attr&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perc_sign_attr</span><span class="o">=</span> <span class="n">perc_sign_attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Selected_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Selected_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;perc_sign_attr&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="Selected_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Selected_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="n">minority_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="n">nn_min_euc</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">nn_min_dist</span><span class="p">,</span> <span class="n">nn_min_ind</span><span class="o">=</span> <span class="n">nn_min_euc</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># significant attribute selection was not described in the paper</span>
        <span class="c1"># I have implemented significant attribute selection by checking</span>
        <span class="c1"># the overlap between ranges of minority and majority class attributes</span>
        <span class="c1"># the attributes with bigger overlap respecting their ranges</span>
        <span class="c1"># are considered more significant</span>
        <span class="n">min_ranges_a</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">min_ranges_b</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">maj_ranges_a</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">maj_ranges_b</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># end points of overlaps</span>
        <span class="n">max_a</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">min_ranges_a</span><span class="p">,</span> <span class="n">maj_ranges_a</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">min_b</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">min_ranges_b</span><span class="p">,</span> <span class="n">maj_ranges_b</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># size of overlap</span>
        <span class="n">overlap</span><span class="o">=</span> <span class="n">min_b</span> <span class="o">-</span> <span class="n">max_a</span>
        
        <span class="c1"># replacing negative values (no overlap) by zero</span>
        <span class="n">overlap</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">overlap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">overlap</span><span class="p">)</span>
        <span class="c1"># percentage of overlap compared to the ranges of attributes in the minority set</span>
        <span class="n">percentages</span><span class="o">=</span> <span class="n">overlap</span><span class="o">/</span><span class="p">(</span><span class="n">min_ranges_b</span> <span class="o">-</span> <span class="n">min_ranges_a</span><span class="p">)</span>
        <span class="c1"># fixing zero division if some attributes have zero range</span>
        <span class="n">percentages</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">percentages</span><span class="p">)</span>
        <span class="c1"># number of significant attributes to determine</span>
        <span class="n">num_sign_attr</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">perc_sign_attr</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">percentages</span><span class="p">)))])</span>
        
        <span class="n">significant_attr</span><span class="o">=</span> <span class="p">(</span><span class="n">percentages</span> <span class="o">&gt;=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">percentages</span><span class="p">)[</span><span class="o">-</span><span class="n">num_sign_attr</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minority_indices</span><span class="p">)))</span>
            <span class="n">u</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">minority_indices</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]]</span>
            <span class="n">v</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">nn_min_ind</span><span class="p">[</span><span class="n">random_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points_componentwise</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">significant_attr</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="Selected_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Selected_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;perc_sign_attr&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">perc_sign_attr</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="LN_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LN_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">LN_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{ln_smote, </span>
<span class="sd">                            author={Maciejewski, T. and Stefanowski, J.}, </span>
<span class="sd">                            booktitle={2011 IEEE Symposium on Computational Intelligence and Data Mining (CIDM)}, </span>
<span class="sd">                            title={Local neighbourhood extension of SMOTE for mining imbalanced data}, </span>
<span class="sd">                            year={2011}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={104-111}, </span>
<span class="sd">                            keywords={Bayes methods;data mining;pattern classification;local neighbourhood extension;imbalanced data mining;focused resampling technique;SMOTE over-sampling method;naive Bayes classifiers;Noise measurement;Noise;Decision trees;Breast cancer;Sensitivity;Data mining;Training}, </span>
<span class="sd">                            doi={10.1109/CIDM.2011.5949434}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={April}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_componentwise</span><span class="p">]</span>
    
<div class="viewcode-block" id="LN_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LN_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): parameter of the NearestNeighbors component</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="LN_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LN_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="LN_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LN_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
            <span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span>
        
        <span class="k">if</span> <span class="n">n_neighbors</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># nearest neighbors of each instance to each instance in the dataset</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">minority_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># dimensionality</span>
        <span class="n">d</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="k">def</span> <span class="nf">safe_level</span><span class="p">(</span><span class="n">p_idx</span><span class="p">,</span> <span class="n">n_idx</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            computing the safe level of samples</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                p_idx (int): index of positive sample</span>
<span class="sd">                n_idx (int): index of other sample</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                int: safe level</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">n_idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># implementation for 1 sample only</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">p_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># implementation for 2 samples</span>
                <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">y</span><span class="p">[</span><span class="n">n_idx</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span> <span class="ow">and</span> <span class="n">p_idx</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">[</span><span class="n">n_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="c1"># -1 because p_idx will be replaced</span>
                    <span class="n">n_positives</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">n_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">n_idx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                        <span class="c1"># this is the effect of replacing p_idx by the next (k+1)th neighbor</span>
                        <span class="n">n_positives</span><span class="o">=</span> <span class="n">n_positives</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">return</span> <span class="n">n_positives</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">n_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">random_gap</span><span class="p">(</span><span class="n">slp</span><span class="p">,</span> <span class="n">sln</span><span class="p">,</span> <span class="n">n_label</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            determining random gap</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                slp (int): safe level of p</span>
<span class="sd">                sln (int): safe level of n</span>
<span class="sd">                n_label (int): label of n</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: gap</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">delta</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">sln</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">slp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">delta</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sl_ratio</span><span class="o">=</span> <span class="n">slp</span><span class="o">/</span><span class="n">sln</span>
                <span class="k">if</span> <span class="n">sl_ratio</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">delta</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">sl_ratio</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">delta</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">/</span><span class="n">sl_ratio</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">delta</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="n">sl_ratio</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">n_label</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                <span class="n">delta</span><span class="o">=</span> <span class="n">delta</span><span class="o">*</span><span class="n">sln</span><span class="o">/</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">delta</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">trials</span><span class="o">=</span> <span class="mi">0</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">p_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">minority_indices</span><span class="p">)</span>
            <span class="c1"># extract random neighbor of p</span>
            <span class="n">n_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="n">p_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="c1"># checking can-create criteria</span>
            <span class="n">slp</span><span class="o">=</span> <span class="n">safe_level</span><span class="p">(</span><span class="n">p_idx</span><span class="p">)</span>
            <span class="n">sln</span><span class="o">=</span> <span class="n">safe_level</span><span class="p">(</span><span class="n">p_idx</span><span class="p">,</span> <span class="n">n_idx</span><span class="p">)</span>
            
            <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">slp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sln</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="c1"># can create</span>
                <span class="n">p</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">p_idx</span><span class="p">]</span>
                <span class="n">n</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">n_idx</span><span class="p">]</span>
                <span class="n">x_new</span><span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
                <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                    <span class="n">delta</span><span class="o">=</span> <span class="n">random_gap</span><span class="p">(</span><span class="n">slp</span><span class="p">,</span> <span class="n">sln</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">n_idx</span><span class="p">])</span>
                    <span class="n">diff</span><span class="o">=</span> <span class="n">n</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>
                    <span class="n">x_new</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">+</span> <span class="n">delta</span><span class="o">*</span><span class="n">diff</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
            
            <span class="n">trials</span><span class="o">=</span> <span class="n">trials</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span><span class="o">/</span><span class="n">trials</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">num_to_sample</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;no instances with slp &gt; 0 and sln &gt; 0 found&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="LN_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.LN_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="MWMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MWMOTE">[docs]</a><span class="k">class</span> <span class="nc">MWMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @ARTICLE{mwmote, </span>
<span class="sd">                        author={Barua, S. and Islam, M. M. and Yao, X. and Murase, K.}, </span>
<span class="sd">                        journal={IEEE Transactions on Knowledge and Data Engineering}, </span>
<span class="sd">                        title={MWMOTE--Majority Weighted Minority Oversampling Technique for Imbalanced Data Set Learning}, </span>
<span class="sd">                        year={2014}, </span>
<span class="sd">                        volume={26}, </span>
<span class="sd">                        number={2}, </span>
<span class="sd">                        pages={405-425}, </span>
<span class="sd">                        keywords={learning (artificial intelligence);pattern clustering;sampling methods;AUC;area under curve;ROC;receiver operating curve;G-mean;geometric mean;minority class cluster;clustering approach;weighted informative minority class samples;Euclidean distance;hard-to-learn informative minority class samples;majority class;synthetic minority class samples;synthetic oversampling methods;imbalanced learning problems;imbalanced data set learning;MWMOTE-majority weighted minority oversampling technique;Sampling methods;Noise measurement;Boosting;Simulation;Complexity theory;Interpolation;Abstracts;Imbalanced learning;undersampling;oversampling;synthetic sample generation;clustering}, </span>
<span class="sd">                        doi={10.1109/TKDE.2012.232}, </span>
<span class="sd">                        ISSN={1041-4347}, </span>
<span class="sd">                        month={Feb}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * The original method was not prepared for the case of having clusters of 1 elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">]</span>
    
<div class="viewcode-block" id="MWMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MWMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">k1</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">k2</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">k3</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">M</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">cf_th</span><span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span> <span class="n">cmax</span><span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            k1 (int): parameter of the NearestNeighbors component</span>
<span class="sd">            k2 (int): parameter of the NearestNeighbors component</span>
<span class="sd">            k3 (int): parameter of the NearestNeighbors component</span>
<span class="sd">            M (int): number of clusters</span>
<span class="sd">            cf_th (float): cutoff threshold</span>
<span class="sd">            cmax (float): maximum closeness value</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k1</span><span class="p">,</span> <span class="s1">&#39;k1&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k2</span><span class="p">,</span> <span class="s1">&#39;k2&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k3</span><span class="p">,</span> <span class="s1">&#39;k3&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="s1">&#39;M&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">cf_th</span><span class="p">,</span> <span class="s1">&#39;cf_th&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">cmax</span><span class="p">,</span> <span class="s1">&#39;cmax&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="o">=</span> <span class="n">k1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="o">=</span> <span class="n">k2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k3</span><span class="o">=</span> <span class="n">k3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">=</span> <span class="n">M</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cf_th</span><span class="o">=</span> <span class="n">cf_th</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmax</span><span class="o">=</span> <span class="n">cmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="MWMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MWMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> 
                                                    <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> 
                                                    <span class="s1">&#39;cf_th&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">5.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;cmax&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">10.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="MWMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MWMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="n">minority</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Step 1</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist1</span><span class="p">,</span> <span class="n">ind1</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># Step 2</span>
        <span class="n">filtered_minority</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">minority</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filtered_minority</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;filtered_minority array is empty&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Step 3 - ind2 needs to be indexed by indices of the lengh of X_maj</span>
        <span class="n">nn_maj</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn_maj</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        <span class="n">dist2</span><span class="p">,</span> <span class="n">ind2</span><span class="o">=</span> <span class="n">nn_maj</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">filtered_minority</span><span class="p">])</span>
        
        <span class="c1"># Step 4</span>
        <span class="n">border_majority</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ind2</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        
        <span class="c1"># Step 5 - ind3 needs to be indexed by indices of the length of X_min</span>
        <span class="n">nn_min</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">k3</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn_min</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist3</span><span class="p">,</span> <span class="n">ind3</span><span class="o">=</span> <span class="n">nn_min</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_maj</span><span class="p">[</span><span class="n">border_majority</span><span class="p">])</span>
        
        <span class="c1"># Step 6 - informative minority indexes X_min</span>
        <span class="n">informative_minority</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ind3</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        
        <span class="k">def</span> <span class="nf">closeness_factor</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">cf_th</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cf_th</span><span class="p">,</span> <span class="n">cmax</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmax</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Closeness factor according to the Eq (6)</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                y (np.array): training instance (border_majority)</span>
<span class="sd">                x (np.array): training instance (informative_minority)</span>
<span class="sd">                cf_th (float): cutoff threshold</span>
<span class="sd">                cmax (float): maximum values</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: closeness factor</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">d</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">d</span><span class="o">=</span> <span class="mf">0.1</span>
            <span class="k">if</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">cf_th</span><span class="p">:</span>
                <span class="n">f</span><span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">d</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">f</span><span class="o">=</span> <span class="n">cf_th</span>
            <span class="k">return</span> <span class="n">f</span><span class="o">/</span><span class="n">cf_th</span><span class="o">*</span><span class="n">cmax</span>
        
        <span class="c1"># Steps 7 - 9</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s1">&#39;computing closeness factors&#39;</span><span class="p">)</span>        
        <span class="n">closeness_factors</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">border_majority</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">informative_minority</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">border_majority</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">informative_minority</span><span class="p">)):</span>
                <span class="n">closeness_factors</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">closeness_factor</span><span class="p">(</span><span class="n">X_maj</span><span class="p">[</span><span class="n">border_majority</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">informative_minority</span><span class="p">[</span><span class="n">j</span><span class="p">]])</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s1">&#39;computing information weights&#39;</span><span class="p">)</span>
        <span class="n">information_weights</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">border_majority</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">informative_minority</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">border_majority</span><span class="p">)):</span>
            <span class="n">norm_factor</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">closeness_factors</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">informative_minority</span><span class="p">)):</span>
                <span class="n">information_weights</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">closeness_factors</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">norm_factor</span>
        
        <span class="n">selection_weights</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">information_weights</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">selection_probabilities</span><span class="o">=</span> <span class="n">selection_weights</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">selection_weights</span><span class="p">)</span>
        
        <span class="c1"># Step 10</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s1">&#39;do clustering&#39;</span><span class="p">)</span>
        <span class="n">kmeans</span><span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">imin_labels</span><span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">[</span><span class="n">informative_minority</span><span class="p">]</span>
        
        <span class="n">clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">imin_labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        
        <span class="c1"># Step 11</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># Step 12</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">random_index</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">informative_minority</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span> <span class="n">selection_probabilities</span><span class="p">)</span>
            <span class="n">cluster_label</span><span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span><span class="p">[</span><span class="n">random_index</span><span class="p">]</span>
            <span class="n">random_index_in_cluster</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">])</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">random_index</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_index_in_cluster</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="MWMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MWMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;k1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k1</span><span class="p">,</span> 
                <span class="s1">&#39;k2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k2</span><span class="p">,</span> 
                <span class="s1">&#39;k3&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k3</span><span class="p">,</span> 
                <span class="s1">&#39;M&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> 
                <span class="s1">&#39;cf_th&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cf_th</span><span class="p">,</span> 
                <span class="s1">&#39;cmax&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmax</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="PDFOS"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.PDFOS">[docs]</a><span class="k">class</span> <span class="nc">PDFOS</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{pdfos,</span>
<span class="sd">                    title = &quot;PDFOS: PDF estimation based over-sampling for imbalanced two-class problems&quot;,</span>
<span class="sd">                    journal = &quot;Neurocomputing&quot;,</span>
<span class="sd">                    volume = &quot;138&quot;,</span>
<span class="sd">                    pages = &quot;248 - 259&quot;,</span>
<span class="sd">                    year = &quot;2014&quot;,</span>
<span class="sd">                    issn = &quot;0925-2312&quot;,</span>
<span class="sd">                    doi = &quot;https://doi.org/10.1016/j.neucom.2014.02.006&quot;,</span>
<span class="sd">                    url = &quot;http://www.sciencedirect.com/science/article/pii/S0925231214002501&quot;,</span>
<span class="sd">                    author = &quot;Ming Gao and Xia Hong and Sheng Chen and Chris J. Harris and Emad Khalaf&quot;,</span>
<span class="sd">                    keywords = &quot;Imbalanced classification, Probability density function based over-sampling, Radial basis function classifier, Orthogonal forward selection, Particle swarm optimisation&quot;</span>
<span class="sd">                    }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Not prepared for low-rank data.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_estimation</span><span class="p">]</span>
    
<div class="viewcode-block" id="PDFOS.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.PDFOS.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="PDFOS.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.PDFOS.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
    <span class="k">def</span> <span class="nf">_sample_by_kernel_density_estimation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">num_to_sample</span><span class="p">,</span> <span class="n">n_optimize</span><span class="o">=</span> <span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sample num_to_sample instances by kernel density estimation</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X_min (np.array): minority data</span>
<span class="sd">            num_to_sample (int): number of instances to sample</span>
<span class="sd">            n_optimize (int): number of vectors used for the optimization process</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># dimensionality of the data</span>
        <span class="n">m</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># computing the covariance matrix of the data</span>
        <span class="n">S</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Condition number of covariance matrix: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">S</span><span class="p">))</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Input size: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Input dim: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">m</span><span class="p">)</span>
        
        <span class="n">S_mrank</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">matrix_rank</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-2</span><span class="p">)</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Matrix rank of covariance matrix: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">S_mrank</span><span class="p">)</span>
        
        <span class="c1"># checking the rank of the matrix</span>
        <span class="k">if</span> <span class="n">S_mrank</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The covariance matrix is singular, performing PCA to fix it&quot;</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;dim: </span><span class="si">%d</span><span class="s2">, rank: </span><span class="si">%d</span><span class="s2">, size: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">S_mrank</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))))</span>
            <span class="n">n_components</span><span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">min</span><span class="p">([</span><span class="n">S_mrank</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)])</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n_components</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">pca</span><span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span> <span class="n">n_components</span><span class="p">)</span>
            <span class="n">X_low_dim</span><span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">X_samp</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_by_kernel_density_estimation</span><span class="p">(</span><span class="n">X_low_dim</span><span class="p">,</span> <span class="n">num_to_sample</span><span class="p">,</span> <span class="n">n_optimize</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pca</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">X_samp</span><span class="p">)</span>
        
        <span class="n">S_inv</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="n">det</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Determinant: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">det</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">eq_9</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Eq (9) in the paper</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">tmp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">S_inv</span><span class="p">),</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">sigma</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">tmp</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">eq_5</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Eq (5) in the paper</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">tmp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="n">S_inv</span><span class="p">),</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">sigma</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="n">tmp</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">eq_5_0</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Eq (5) with the same vectors feeded in</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">sigma</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">m</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        
        <span class="k">def</span> <span class="nf">eq_8</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Eq (8) in the paper</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">e9</span><span class="o">=</span> <span class="n">eq_9</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
            <span class="n">e5</span><span class="o">=</span> <span class="n">eq_5</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">e9</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">e5</span>
        
        <span class="k">def</span> <span class="nf">M</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Eq (7) in the paper</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">total</span><span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
                    <span class="n">total</span><span class="o">=</span> <span class="n">total</span> <span class="o">+</span> <span class="n">eq_8</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
                        
            <span class="n">a</span><span class="o">=</span> <span class="n">total</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">b</span><span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">eq_5_0</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        
        <span class="c1"># finding the best sigma parameter</span>
        <span class="n">best_sigma</span><span class="o">=</span> <span class="mi">0</span>
        <span class="n">error</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="c1"># the dataset is reduced to make the optimization more efficient</span>
        <span class="n">X_reduced</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))),</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">n_optimize</span><span class="p">]),</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)]</span>
        
        <span class="c1"># we suppose that the data is normalized, thus, this search space should be meaningful</span>
        <span class="k">for</span> <span class="n">sigma</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span> <span class="mi">20</span><span class="p">):</span>
            <span class="n">e</span><span class="o">=</span> <span class="n">M</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="n">X_reduced</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;</span> <span class="n">error</span><span class="p">:</span>
                <span class="n">error</span><span class="o">=</span> <span class="n">e</span>
                <span class="n">best_sigma</span><span class="o">=</span> <span class="n">sigma</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;best sigma found: </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">best_sigma</span><span class="p">)</span>
        
        <span class="c1"># generating samples according to the </span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">best_sigma</span><span class="o">*</span><span class="n">S</span><span class="p">))</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
    
<div class="viewcode-block" id="PDFOS.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.PDFOS.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># scaling the data to aid numerical stability</span>
        <span class="n">ss</span><span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="n">X_ss</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X_ss</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># generating samples by kernel density estimation</span>
        <span class="n">samples</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_by_kernel_density_estimation</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">num_to_sample</span><span class="p">,</span> <span class="n">n_optimize</span><span class="o">=</span> <span class="mi">100</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="PDFOS.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.PDFOS.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="IPADE_ID"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.IPADE_ID">[docs]</a><span class="k">class</span> <span class="nc">IPADE_ID</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{ipade_id,</span>
<span class="sd">                    title = &quot;Addressing imbalanced classification with instance generation techniques: IPADE-ID&quot;,</span>
<span class="sd">                    journal = &quot;Neurocomputing&quot;,</span>
<span class="sd">                    volume = &quot;126&quot;,</span>
<span class="sd">                    pages = &quot;15 - 28&quot;,</span>
<span class="sd">                    year = &quot;2014&quot;,</span>
<span class="sd">                    note = &quot;Recent trends in Intelligent Data Analysis Online Data Processing&quot;,</span>
<span class="sd">                    issn = &quot;0925-2312&quot;,</span>
<span class="sd">                    doi = &quot;https://doi.org/10.1016/j.neucom.2013.01.050&quot;,</span>
<span class="sd">                    url = &quot;http://www.sciencedirect.com/science/article/pii/S0925231213006887&quot;,</span>
<span class="sd">                    author = &quot;Victoria López and Isaac Triguero and Cristóbal J. Carmona and Salvador García and Francisco Herrera&quot;,</span>
<span class="sd">                    keywords = &quot;Differential evolution, Instance generation, Nearest neighbor, Decision tree, Imbalanced datasets&quot;</span>
<span class="sd">                    }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * According to the algorithm, if the addition of a majority sample doesn&#39;t improve the AUC during the DE optimization process, the addition of no further majority points is tried.</span>
<span class="sd">        * In the differential evolution the multiplication by a random number seems have a deteriorating effect, new scaling parameter added to fix this.</span>
<span class="sd">        * It is not specified how to do the evaluation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_memetic</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_classifier</span><span class="p">]</span>
    
<div class="viewcode-block" id="IPADE_ID.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.IPADE_ID.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">F</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">G</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">OT</span><span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">max_it</span><span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">dt_classifier</span><span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">),</span> <span class="n">base_classifier</span><span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            F (float): control parameter of differential evolution</span>
<span class="sd">            G (float): control parameter of the evolution</span>
<span class="sd">            OT (int): number of optimizations</span>
<span class="sd">            max_it (int): maximum number of iterations for DE_optimization</span>
<span class="sd">            dt_classifier (obj): decision tree classifier object</span>
<span class="sd">            base_classifier (obj): classifier object</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">OT</span><span class="p">,</span> <span class="s1">&#39;OT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">max_it</span><span class="p">,</span> <span class="s1">&#39;max_it&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">=</span> <span class="n">F</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">=</span> <span class="n">G</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">OT</span><span class="o">=</span> <span class="n">OT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_it</span><span class="o">=</span> <span class="n">max_it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt_classifier</span><span class="o">=</span> <span class="n">dt_classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_classifier</span><span class="o">=</span> <span class="n">base_classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="IPADE_ID.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.IPADE_ID.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># as the OT and max_it parameters control the discovery of the feature</span>
        <span class="c1"># space it is enough to try sufficiently large numbers</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> 
                                                    <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> 
                                                    <span class="s1">&#39;OT&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">30</span><span class="p">],</span> 
                                                    <span class="s1">&#39;max_it&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">40</span><span class="p">],</span> 
                                                    <span class="s1">&#39;dt_classifier&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">)],</span> 
                                                    <span class="s1">&#39;base_classifier&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">)]})</span></div>
    
<div class="viewcode-block" id="IPADE_ID.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.IPADE_ID.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">mms</span><span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="n">X</span><span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">min_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">maj_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="k">def</span> <span class="nf">DE_optimization</span><span class="p">(</span><span class="n">GS</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">min_indices</span><span class="p">,</span> <span class="n">maj_indices</span><span class="p">,</span> <span class="n">classifier</span><span class="p">,</span> <span class="n">for_validation</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Implements the DE_optimization method of the paper.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                GS (np.matrix): actual best training set</span>
<span class="sd">                GS_y (np.array): corresponding class labels</span>
<span class="sd">                X (np.matrix): complete training set</span>
<span class="sd">                y (np.array): all class labels</span>
<span class="sd">                min_indices (np.array): array of minority class labels in y</span>
<span class="sd">                maj_indices (np.array): array of majority class labels in y</span>
<span class="sd">                classifier (object): base classifier</span>
<span class="sd">                for_validation (np.array): array of indices for X used for validation</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                np.matrix: optimized training set</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># evaluate training set</span>
            <span class="n">AUC_GS</span><span class="o">=</span> <span class="n">evaluate_ID</span><span class="p">(</span><span class="n">GS</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="n">for_validation</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">for_validation</span><span class="p">],</span> <span class="n">classifier</span><span class="p">)</span>
            
            <span class="c1"># optimizing the training set</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_it</span><span class="p">):</span>
                <span class="n">GS_hat</span><span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># doing the differential evolution</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">GS</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">GS_y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                        <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">min_indices</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">maj_indices</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                    
                    <span class="n">GS_hat</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">GS</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">r1</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="o">*</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">r2</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">r3</span><span class="p">]),</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
                
                <span class="c1"># evaluating the current setting</span>
                <span class="n">AUC_GS_hat</span><span class="o">=</span> <span class="n">evaluate_ID</span><span class="p">(</span><span class="n">GS_hat</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="n">for_validation</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">for_validation</span><span class="p">],</span> <span class="n">classifier</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">AUC_GS_hat</span> <span class="o">&gt;</span> <span class="n">AUC_GS</span><span class="p">:</span>
                    <span class="n">GS</span><span class="o">=</span> <span class="n">GS_hat</span>
                    <span class="n">AUC_GS</span><span class="o">=</span> <span class="n">AUC_GS_hat</span>
            
            <span class="k">return</span> <span class="n">GS</span>
        
        <span class="k">def</span> <span class="nf">evaluate_ID</span><span class="p">(</span><span class="n">GS</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">,</span> <span class="n">TR</span><span class="p">,</span> <span class="n">TR_y</span><span class="p">,</span> <span class="n">base_classifier</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Implements the evaluate_ID function of the paper.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                GS (np.matrix): actual training set</span>
<span class="sd">                GS_y (np.array): list of corresponding class labels</span>
<span class="sd">                TR (np.matrix): complete training set</span>
<span class="sd">                TR_y (np.array): all class labels</span>
<span class="sd">                base_classifier (object): classifier to be used</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: ROC AUC score</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">base_classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">GS</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">)</span>
            <span class="n">pred</span><span class="o">=</span> <span class="n">base_classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">TR</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">base_classifier</span><span class="o">.</span><span class="n">classes_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">TR_y</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="mf">0.0</span>
            <span class="k">return</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">TR_y</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">evaluate_class</span><span class="p">(</span><span class="n">GS</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">,</span> <span class="n">TR</span><span class="p">,</span> <span class="n">TR_y</span><span class="p">,</span> <span class="n">base_classifier</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Implements the evaluate_ID function of the paper.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                GS (np.matrix): actual training set</span>
<span class="sd">                GS_y (np.array): list of corresponding class labels</span>
<span class="sd">                TR (np.matrix): complete training set</span>
<span class="sd">                TR_y (np.array): all class labels</span>
<span class="sd">                base_classifier (object): classifier to be used</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: accuracy score</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">base_classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">GS</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">)</span>
            <span class="n">pred</span><span class="o">=</span> <span class="n">base_classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">TR</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">TR_y</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
        
        <span class="c1"># Phase 1: Initialization</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Initialization&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt_classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">leafs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt_classifier</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">unique_leafs</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">leafs</span><span class="p">)</span>
        <span class="n">used_in_GS</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="n">for_validation</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">used_in_GS</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># extracting mean elements of the leafs</span>
        <span class="n">GS</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">GS_y</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">unique_leafs</span><span class="p">:</span>
            <span class="n">indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">leafs</span> <span class="o">==</span> <span class="n">u</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">GS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">GS_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mode</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">used_in_GS</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">=</span> <span class="kc">True</span>
        
        <span class="c1"># updating the indices of the validation set excluding those used in GS</span>
        <span class="n">for_validation</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">used_in_GS</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Size of validation set </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">for_validation</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">for_validation</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;No minority samples in validation set&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">GS_y</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;No minority samples in reduced dataset&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># DE optimization takes place</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;DE optimization&quot;</span><span class="p">)</span>
        <span class="n">base_classifier</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_classifier</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_classifier</span><span class="o">.</span><span class="n">get_params</span><span class="p">()))</span>
        <span class="n">GS</span><span class="o">=</span> <span class="n">DE_optimization</span><span class="p">(</span><span class="n">GS</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">min_indices</span><span class="p">,</span> <span class="n">maj_indices</span><span class="p">,</span> <span class="n">base_classifier</span><span class="p">,</span> <span class="n">for_validation</span><span class="p">)</span>
        <span class="c1"># evaluate results</span>
        <span class="n">base_classifier</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_classifier</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_classifier</span><span class="o">.</span><span class="n">get_params</span><span class="p">()))</span>
        <span class="n">AUC</span><span class="o">=</span> <span class="n">evaluate_ID</span><span class="p">(</span><span class="n">GS</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="n">for_validation</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">for_validation</span><span class="p">],</span> <span class="n">base_classifier</span><span class="p">)</span>
        
        <span class="c1"># Phase 2: Addition of new instances</span>
        <span class="n">register_class</span><span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span> <span class="s1">&#39;optimizable&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">:</span> <span class="s1">&#39;optimizable&#39;</span><span class="p">}</span>
        <span class="n">number_of_optimizations</span><span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        <span class="n">accuracy_class</span><span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Starting optimization&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">AUC</span> <span class="o">&lt;</span> <span class="mf">1.0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">register_class</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;optimizable&#39;</span> <span class="ow">or</span> <span class="n">register_class</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;optimizable&#39;</span><span class="p">):</span>
            <span class="n">less_accuracy</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="c1"># loop in line 8</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]:</span>
                <span class="c1"># condition in line 9</span>
                <span class="k">if</span> <span class="n">register_class</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;optimizable&#39;</span><span class="p">:</span>
                    <span class="n">class_for_validation</span><span class="o">=</span> <span class="n">for_validation</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="n">for_validation</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span>
                    <span class="n">base_classifier</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_classifier</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_classifier</span><span class="o">.</span><span class="n">get_params</span><span class="p">()))</span>
                    <span class="n">accuracy_class</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">evaluate_class</span><span class="p">(</span><span class="n">GS</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="n">class_for_validation</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">class_for_validation</span><span class="p">],</span> <span class="n">base_classifier</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">accuracy_class</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">less_accuracy</span><span class="p">:</span>
                        <span class="n">less_accuracy</span><span class="o">=</span> <span class="n">accuracy_class</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">target_class</span><span class="o">=</span> <span class="n">i</span>
            <span class="c1"># conditional in line 17</span>
            <span class="k">if</span> <span class="n">target_class</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span> <span class="ow">and</span> <span class="n">number_of_optimizations</span><span class="p">[</span><span class="n">target_class</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># it is not clear where does GS_trial coming from in line 18</span>
                <span class="n">GS</span><span class="o">=</span> <span class="n">DE_optimization</span><span class="p">(</span><span class="n">GS</span><span class="p">,</span> <span class="n">GS_y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">min_indices</span><span class="p">,</span> <span class="n">maj_indices</span><span class="p">,</span> <span class="n">base_classifier</span><span class="p">,</span> <span class="n">for_validation</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">target_class</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                    <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">min_indices</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">maj_indices</span><span class="p">)</span>
                
                <span class="n">GS_trial</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">GS</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>
                <span class="n">GS_trial_y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">GS_y</span><span class="p">,</span> <span class="n">y</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>
                <span class="c1"># removing idx from the validation set in order to keep the validation fair</span>
                <span class="n">for_validation_trial</span><span class="o">=</span> <span class="n">for_validation</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">for_validation</span><span class="p">:</span>
                    <span class="n">for_validation_trial</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                
                <span class="n">for_validation_trial</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">for_validation_trial</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="c1"># doing optimization</span>
                <span class="n">GS_trial</span><span class="o">=</span> <span class="n">DE_optimization</span><span class="p">(</span><span class="n">GS_trial</span><span class="p">,</span> <span class="n">GS_trial_y</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">min_indices</span><span class="p">,</span> <span class="n">maj_indices</span><span class="p">,</span> <span class="n">base_classifier</span><span class="p">,</span> <span class="n">for_validation</span><span class="p">)</span>
            
            <span class="c1"># line 23</span>
            <span class="n">base_classifier</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_classifier</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_classifier</span><span class="o">.</span><span class="n">get_params</span><span class="p">()))</span>
            <span class="c1">#base_classifier= DecisionTreeClassifier(random_state= 2)</span>
            <span class="n">AUC_trial</span><span class="o">=</span> <span class="n">evaluate_ID</span><span class="p">(</span><span class="n">GS_trial</span><span class="p">,</span> <span class="n">GS_trial_y</span><span class="p">,</span> <span class="n">X</span><span class="p">[</span><span class="n">for_validation</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">for_validation</span><span class="p">],</span> <span class="n">base_classifier</span><span class="p">)</span>
            <span class="c1"># conditional in line 24</span>
            <span class="k">if</span> <span class="n">AUC_trial</span> <span class="o">&gt;</span> <span class="n">AUC</span><span class="p">:</span>
                <span class="n">AUC</span><span class="o">=</span> <span class="n">AUC_trial</span>
                <span class="n">GS</span><span class="o">=</span> <span class="n">GS_trial</span>
                <span class="n">GS_y</span><span class="o">=</span> <span class="n">GS_trial_y</span>
                <span class="n">for_validation</span><span class="o">=</span> <span class="n">for_validation_trial</span>
                
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Size of validation set </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">for_validation</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">for_validation</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;No minority samples in validation set&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">GS_y</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;No minority samples in reduced dataset&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                
                <span class="n">number_of_optimizations</span><span class="p">[</span><span class="n">target_class</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># conditional in line 29</span>
                <span class="k">if</span> <span class="n">target_class</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span> <span class="ow">and</span> <span class="n">number_of_optimizations</span><span class="p">[</span><span class="n">target_class</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">OT</span><span class="p">:</span>
                    <span class="n">number_of_optimizations</span><span class="p">[</span><span class="n">target_class</span><span class="p">]</span><span class="o">=</span> <span class="n">number_of_optimizations</span><span class="p">[</span><span class="n">target_class</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">register_class</span><span class="p">[</span><span class="n">target_class</span><span class="p">]</span><span class="o">=</span> <span class="s1">&#39;non-optimizable&#39;</span>

        <span class="k">return</span> <span class="n">mms</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">GS</span><span class="p">),</span> <span class="n">GS_y</span></div>
        
<div class="viewcode-block" id="IPADE_ID.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.IPADE_ID.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;F&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">F</span><span class="p">,</span> 
                <span class="s1">&#39;G&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">G</span><span class="p">,</span> 
                <span class="s1">&#39;OT&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">OT</span><span class="p">,</span> 
                <span class="s1">&#39;max_it&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_it</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> 
                <span class="s1">&#39;dt_classifier&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt_classifier</span><span class="p">,</span> 
                <span class="s1">&#39;base_classifier&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_classifier</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="RWO_sampling"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.RWO_sampling">[docs]</a><span class="k">class</span> <span class="nc">RWO_sampling</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{rwo_sampling,</span>
<span class="sd">                    author = {Zhang, Huaxzhang and Li, Mingfang},</span>
<span class="sd">                    year = {2014},</span>
<span class="sd">                    month = {11},</span>
<span class="sd">                    pages = {},</span>
<span class="sd">                    title = {RWO-Sampling: A Random Walk Over-Sampling Approach to Imbalanced Data Classification},</span>
<span class="sd">                    volume = {20},</span>
<span class="sd">                    booktitle = {Information Fusion}</span>
<span class="sd">                    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="RWO_sampling.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.RWO_sampling.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="RWO_sampling.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.RWO_sampling.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="RWO_sampling.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.RWO_sampling.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="n">stds</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)))</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">multivariate_normal</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))],</span> <span class="n">stds</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="RWO_sampling.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.RWO_sampling.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="NEATER"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NEATER">[docs]</a><span class="k">class</span> <span class="nc">NEATER</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{neater, </span>
<span class="sd">                            author={Almogahed, B. A. and Kakadiaris, I. A.}, </span>
<span class="sd">                            booktitle={2014 22nd International Conference on Pattern Recognition}, </span>
<span class="sd">                            title={NEATER: Filtering of Over-sampled Data Using Non-cooperative Game Theory}, </span>
<span class="sd">                            year={2014}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={1371-1376}, </span>
<span class="sd">                            keywords={data handling;game theory;information filtering;NEATER;imbalanced data problem;synthetic data;filtering of over-sampled data using non-cooperative game theory;Games;Game theory;Vectors;Sociology;Statistics;Silicon;Mathematical model}, </span>
<span class="sd">                            doi={10.1109/ICPR.2014.245}, </span>
<span class="sd">                            ISSN={1051-4651}, </span>
<span class="sd">                            month={Aug}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Evolving both majority and minority probabilities as nothing ensures that the probabilities remain in the range [0,1], and they need to be normalized.</span>
<span class="sd">        * The inversely weighted function needs to be cut at some value (like the alpha level), otherwise it will overemphasize the utility of having differing neighbors next to each other.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">]</span>
    
<div class="viewcode-block" id="NEATER.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NEATER.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">smote_n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            smote_n_neighbors (int): number of neighbors in SMOTE sampling</span>
<span class="sd">            b (int): number of neighbors</span>
<span class="sd">            alpha (float): smoothing term</span>
<span class="sd">            h (int): number of iterations in evolution</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">smote_n_neighbors</span><span class="p">,</span> <span class="s2">&quot;smote_n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smote_n_neighbors</span><span class="o">=</span> <span class="n">smote_n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="o">=</span> <span class="n">b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">=</span> <span class="n">h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>

<div class="viewcode-block" id="NEATER.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NEATER.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;smote_n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">],</span> 
                                                    <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">20</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="NEATER.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NEATER.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Applying SMOTE and ADASYN</span>
        <span class="n">X_0</span><span class="p">,</span> <span class="n">y_0</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smote_n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">X_1</span><span class="p">,</span> <span class="n">y_1</span><span class="o">=</span> <span class="n">ADASYN</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">X_new</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_0</span><span class="p">,</span> <span class="n">X_1</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):]])</span>
        <span class="n">y_new</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y_0</span><span class="p">,</span> <span class="n">y_1</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">):]])</span>
        
        <span class="n">X_syn</span><span class="o">=</span> <span class="n">X_new</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_syn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_all</span><span class="o">=</span> <span class="n">X_new</span>
        <span class="n">y_all</span><span class="o">=</span> <span class="n">y_new</span>
        
        <span class="c1"># binary indicator indicating synthetic instances</span>
        <span class="n">synthetic</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">False</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="kc">True</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X_syn</span><span class="p">))])</span>
        
        <span class="c1"># initializing strategy probabilities</span>
        <span class="n">prob</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_all</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">prob</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                <span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.0</span>
        
        <span class="c1"># Finding nearest neighbors, +1 as X_syn is part of X_all and nearest</span>
        <span class="c1"># neighbors will be themselves</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_all</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_syn</span><span class="p">)</span>
        
        <span class="c1"># computing distances</span>
        <span class="n">dm</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_syn</span><span class="p">,</span> <span class="n">X_all</span><span class="p">)</span>
        <span class="n">dm</span><span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">dm</span>
        <span class="n">dm</span><span class="p">[</span><span class="n">dm</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        
        <span class="k">def</span> <span class="nf">utilities</span><span class="p">(</span><span class="n">prob</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Computes the utilit function</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                prob (np.matrix): strategy probabilities</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                np.array, np.array, np.array: utility values, minority utilities, majority utilities</span>
<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="n">util_mixed</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span><span class="o">*</span><span class="p">(</span><span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_syn</span><span class="p">))])])</span>
            <span class="n">util_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_syn</span><span class="p">))])])</span>
            <span class="n">util_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span><span class="o">*</span><span class="p">(</span><span class="mi">0</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">0</span><span class="o">*</span><span class="n">prob</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_syn</span><span class="p">))])])</span>
            
            <span class="c1">#util_mixed= np.hstack([np.array([0]*len(X)), np.array([np.sum([1*prob[i][0]*prob[j][0] + dm[i,j]*(prob[i][1]*prob[j][0] + prob[i][0]*prob[j][1]) + 1*prob[i][1]*prob[j][1] for j in indices[i][1:]]) for i in range(len(X_syn))])])</span>
            <span class="c1">#util_min= np.hstack([np.array([0]*len(X)), np.array([np.sum([0*prob[j][0] + dm[i,j]*(1*prob[j][0] + 0*prob[j][1]) + 1*prob[j][1] for j in indices[i][1:]]) for i in range(len(X_syn))])])</span>
            <span class="c1">#util_maj= np.hstack([np.array([0]*len(X)), np.array([np.sum([1*prob[j][0] + dm[i,j]*(0*prob[j][0] + 1*prob[j][1]) + 0*prob[j][1] for j in indices[i][1:]]) for i in range(len(X_syn))])])</span>

            <span class="k">return</span> <span class="n">util_mixed</span><span class="p">,</span> <span class="n">util_min</span><span class="p">,</span> <span class="n">util_maj</span>
        
        <span class="k">def</span> <span class="nf">evolution</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">synthetic</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Executing one step of the probabilistic evolution</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                prob (np.matrix): strategy probabilities</span>
<span class="sd">                synthetic (np.array): flags of synthetic examples</span>
<span class="sd">                alpha (float): smoothing function</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                np.matrix: updated probabilities</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">util_mixed</span><span class="p">,</span> <span class="n">util_min</span><span class="p">,</span> <span class="n">util_maj</span><span class="o">=</span> <span class="n">utilities</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
            
            <span class="n">prob_new</span><span class="o">=</span> <span class="n">prob</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">prob_new</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">synthetic</span><span class="p">,</span> <span class="n">prob</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">util_min</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">util_mixed</span><span class="p">),</span> <span class="n">prob</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">prob_new</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">synthetic</span><span class="p">,</span> <span class="n">prob</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">util_maj</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="n">util_mixed</span><span class="p">),</span> <span class="n">prob</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">norm_factor</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prob_new</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">prob_new</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">prob_new</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">norm_factor</span>
            <span class="n">prob_new</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">prob_new</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">norm_factor</span>
            
            <span class="k">return</span> <span class="n">prob_new</span>
        
        <span class="c1"># executing the evolution</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">):</span>
            <span class="n">prob</span><span class="o">=</span> <span class="n">evolution</span><span class="p">(</span><span class="n">prob</span><span class="p">,</span> <span class="n">synthetic</span><span class="p">)</span>
        
        <span class="c1"># determining final labels</span>
        <span class="n">y_all</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">prob</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">X_all</span><span class="p">,</span> <span class="n">y_all</span></div>
        
<div class="viewcode-block" id="NEATER.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NEATER.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;smote_n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">smote_n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">,</span> 
                <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> 
                <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="DEAGO"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DEAGO">[docs]</a><span class="k">class</span> <span class="nc">DEAGO</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{deago, </span>
<span class="sd">                            author={Bellinger, C. and Japkowicz, N. and Drummond, C.}, </span>
<span class="sd">                            booktitle={2015 IEEE 14th International Conference on Machine Learning and Applications (ICMLA)}, </span>
<span class="sd">                            title={Synthetic Oversampling for Advanced Radioactive Threat Detection}, </span>
<span class="sd">                            year={2015}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={948-953}, </span>
<span class="sd">                            keywords={radioactive waste;advanced radioactive threat detection;gamma-ray spectral classification;industrial nuclear facilities;Health Canadas national monitoring networks;Vancouver 2010;Isotopes;Training;Monitoring;Gamma-rays;Machine learning algorithms;Security;Neural networks;machine learning;classification;class imbalance;synthetic oversampling;artificial neural networks;autoencoders;gamma-ray spectra}, </span>
<span class="sd">                            doi={10.1109/ICMLA.2015.58}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={Dec}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * There is no hint on the activation functions and amounts of noise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_estimation</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_application</span><span class="p">]</span>
    
<div class="viewcode-block" id="DEAGO.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DEAGO.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">e</span><span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            e (int): number of epochs</span>
<span class="sd">            h (float): fraction of number of hidden units</span>
<span class="sd">            sigma (float): training noise</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="s2">&quot;e&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="o">=</span> <span class="n">e</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">=</span> <span class="n">h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="DEAGO.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DEAGO.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">40</span><span class="p">],</span> 
                                                    <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> 
                                                    <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="DEAGO.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DEAGO.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># ugly hack to get reproducible results from keras with tensorflow backend</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">os</span>
            <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;PYTHONHASHSEED&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">keras</span> <span class="k">as</span> <span class="nn">K</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">random</span>
            <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">tensorflow</span> <span class="k">import</span> <span class="n">set_random_seed</span>
            <span class="n">set_random_seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seed</span><span class="o">=</span> <span class="mi">127</span>
            <span class="kn">import</span> <span class="nn">os</span>
            <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;PYTHONHASHSEED&#39;</span><span class="p">]</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">keras</span> <span class="k">as</span> <span class="nn">K</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="kn">import</span> <span class="nn">random</span>
            <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
            <span class="kn">from</span> <span class="nn">tensorflow</span> <span class="k">import</span> <span class="n">set_random_seed</span>
            <span class="n">set_random_seed</span><span class="p">(</span><span class="n">seed</span><span class="p">)</span>
        
        <span class="kn">from</span> <span class="nn">keras</span> <span class="k">import</span> <span class="n">backend</span> <span class="k">as</span> <span class="n">K</span>
        <span class="kn">import</span> <span class="nn">tensorflow</span> <span class="k">as</span> <span class="nn">tf</span>
        <span class="n">session_conf</span><span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">ConfigProto</span><span class="p">(</span><span class="n">intra_op_parallelism_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inter_op_parallelism_threads</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">sess</span><span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">Session</span><span class="p">(</span><span class="n">graph</span><span class="o">=</span><span class="n">tf</span><span class="o">.</span><span class="n">get_default_graph</span><span class="p">(),</span> <span class="n">config</span><span class="o">=</span><span class="n">session_conf</span><span class="p">)</span>
        <span class="n">K</span><span class="o">.</span><span class="n">set_session</span><span class="p">(</span><span class="n">sess</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Input&#39;</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">keras.layers</span> <span class="k">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">GaussianNoise</span>
            <span class="kn">from</span> <span class="nn">keras.models</span> <span class="k">import</span> <span class="n">Model</span>
            <span class="kn">from</span> <span class="nn">keras.callbacks</span> <span class="k">import</span> <span class="n">EarlyStopping</span>
            
            <span class="bp">self</span><span class="o">.</span><span class="n">Input</span><span class="o">=</span> <span class="n">Input</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Dense</span><span class="o">=</span> <span class="n">Dense</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">GaussianNoise</span><span class="o">=</span> <span class="n">GaussianNoise</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Model</span><span class="o">=</span> <span class="n">Model</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">EarlyStopping</span><span class="o">=</span> <span class="n">EarlyStopping</span>
            
        
        <span class="c1"># sampling by smote</span>
        <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># samples to map to the manifold extracted by the autoencoder</span>
        <span class="n">X_init</span><span class="o">=</span> <span class="n">X_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_init</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># normalizing</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">ss</span><span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="n">X_min_normalized</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">X_init_normalized</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_init</span><span class="p">)</span>
        
        <span class="c1"># extracting dimensions</span>
        <span class="n">d</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">encoding_d</span><span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">d</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">))])</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Input dimension: </span><span class="si">%d</span><span class="s2">, encoding dimension: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">encoding_d</span><span class="p">))</span>
        
        <span class="c1"># constructing the autoencoder</span>
        <span class="n">callbacks</span><span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">EarlyStopping</span><span class="p">(</span><span class="n">monitor</span><span class="o">=</span><span class="s1">&#39;val_loss&#39;</span><span class="p">,</span> <span class="n">patience</span><span class="o">=</span> <span class="mi">2</span><span class="p">)]</span>
        
        <span class="n">input_layer</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">d</span><span class="p">,))</span>
        <span class="n">noise</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">GaussianNoise</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">)(</span><span class="n">input_layer</span><span class="p">)</span>
        <span class="n">encoded</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">encoding_d</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span><span class="s1">&#39;relu&#39;</span><span class="p">)(</span><span class="n">noise</span><span class="p">)</span>
        <span class="n">decoded</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Dense</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">)(</span><span class="n">encoded</span><span class="p">)</span>
        
        <span class="n">dae</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Model</span><span class="p">(</span><span class="n">input_layer</span><span class="p">,</span> <span class="n">decoded</span><span class="p">)</span>
        <span class="n">dae</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">optimizer</span><span class="o">=</span><span class="s1">&#39;adadelta&#39;</span><span class="p">,</span> <span class="n">loss</span><span class="o">=</span><span class="s1">&#39;mean_squared_error&#39;</span><span class="p">)</span>
        <span class="n">actual_epochs</span><span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="mf">5000.0</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">val_perc</span><span class="o">=</span> <span class="mf">0.2</span>
            <span class="n">val_num</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val_perc</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">X_min_train</span><span class="o">=</span> <span class="n">X_min_normalized</span><span class="p">[:</span><span class="o">-</span><span class="n">val_num</span><span class="p">]</span>
            <span class="n">X_min_val</span><span class="o">=</span> <span class="n">X_min_normalized</span><span class="p">[</span><span class="o">-</span><span class="n">val_num</span><span class="p">:]</span>
            
            <span class="c1">#dae.fit(X_min_normalized, X_min_normalized, epochs= actual_epochs, verbose= 0)</span>
            <span class="n">dae</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min_train</span><span class="p">,</span> <span class="n">X_min_train</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span> <span class="n">actual_epochs</span><span class="p">,</span> <span class="n">validation_data</span><span class="o">=</span><span class="p">(</span><span class="n">X_min_val</span><span class="p">,</span> <span class="n">X_min_val</span><span class="p">),</span> <span class="n">callbacks</span><span class="o">=</span> <span class="n">callbacks</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dae</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min_normalized</span><span class="p">,</span> <span class="n">X_min_normalized</span><span class="p">,</span> <span class="n">epochs</span><span class="o">=</span> <span class="n">actual_epochs</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># mapping the initial samples to the manifold</span>
        <span class="n">samples</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">dae</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_init_normalized</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="DEAGO.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DEAGO.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;e&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">e</span><span class="p">,</span> 
                <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> 
                <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="Gazzah"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Gazzah">[docs]</a><span class="k">class</span> <span class="nc">Gazzah</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{gazzah, </span>
<span class="sd">                            author={Gazzah, S. and Hechkel, A. and Essoukri Ben Amara, N. }, </span>
<span class="sd">                            booktitle={2015 IEEE 12th International Multi-Conference on Systems, Signals Devices (SSD15)}, </span>
<span class="sd">                            title={A hybrid sampling method for imbalanced data}, </span>
<span class="sd">                            year={2015}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={1-6}, </span>
<span class="sd">                            keywords={computer vision;image classification;learning (artificial intelligence);sampling methods;hybrid sampling method;imbalanced data;diversification;computer vision domain;classical machine learning systems;intraclass variations;system performances;classification accuracy;imbalanced training data;training data set;over-sampling;minority class;SMOTE star topology;feature vector deletion;intra-class variations;distribution criterion;biometric data;true positive rate;Training data;Principal component analysis;Databases;Support vector machines;Training;Feature extraction;Correlation;Imbalanced data sets;Intra-class variations;Data analysis;Principal component analysis;One-against-all SVM}, </span>
<span class="sd">                            doi={10.1109/SSD.2015.7348093}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={March}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_dim_reduction</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">]</span>
    
<div class="viewcode-block" id="Gazzah.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Gazzah.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_components (int): number of components in PCA analysis</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_components</span><span class="p">,</span> <span class="s2">&quot;n_components&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Gazzah.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Gazzah.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="Gazzah.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Gazzah.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># do the oversampling</span>
        <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">polynom_fit_SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">X_min_samp</span><span class="o">=</span> <span class="n">X_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min_samp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># do the undersampling</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting the PCA model</span>
        <span class="n">pca</span><span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">]))</span>
        <span class="n">X_maj_trans</span><span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        <span class="n">R</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">X_maj_trans</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="c1"># determining the majority samples to remove</span>
        <span class="n">to_remove</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">R</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_maj_trans</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Removing </span><span class="si">%d</span><span class="s2"> majority samples&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">))</span>
        <span class="c1"># removing the majority samples</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min_samp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;no samples added&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_min_samp</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min_samp</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="Gazzah.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Gazzah.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="MCT"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MCT">[docs]</a><span class="k">class</span> <span class="nc">MCT</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{mct,</span>
<span class="sd">                    author = {Jiang, Liangxiao and Qiu, Chen and Li, Chaoqun},</span>
<span class="sd">                    year = {2015},</span>
<span class="sd">                    month = {03},</span>
<span class="sd">                    pages = {1551004},</span>
<span class="sd">                    title = {A Novel Minority Cloning Technique for Cost-Sensitive Learning},</span>
<span class="sd">                    volume = {29},</span>
<span class="sd">                    booktitle = {International Journal of Pattern Recognition and Artificial Intelligence}</span>
<span class="sd">                    }</span>

<span class="sd">    Notes:</span>
<span class="sd">        * Mode is changed to median, distance is changed to Euclidean to support continuous features, and normalized.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_copy</span><span class="p">]</span>
    
<div class="viewcode-block" id="MCT.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MCT.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="MCT.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MCT.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="MCT.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MCT.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># having continuous variables, the mode is replaced by median</span>
        <span class="n">x_med</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">distances</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x_med</span> <span class="o">-</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_min</span><span class="p">])</span>
        <span class="n">distances</span><span class="o">=</span> <span class="n">distances</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
        <span class="c1"># distribution of copies is determined (Euclidean distance is a dissimilarity measure</span>
        <span class="c1"># which is changed to similarity by subtracting from 1.0)</span>
        <span class="n">distribution</span><span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">distances</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">distances</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">distribution</span><span class="p">)):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;NaN in the probability distribution&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">distribution</span><span class="p">)])</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="MCT.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MCT.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="ADG"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADG">[docs]</a><span class="k">class</span> <span class="nc">ADG</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{adg,</span>
<span class="sd">                    author = {Pourhabib, A. and Mallick, Bani K. and Ding, Yu},</span>
<span class="sd">                    year = {2015},</span>
<span class="sd">                    month = {16},</span>
<span class="sd">                    pages = {2695--2724},</span>
<span class="sd">                    title = {A Novel Minority Cloning Technique for Cost-Sensitive Learning},</span>
<span class="sd">                    volume = {16},</span>
<span class="sd">                    journal = {Journal of Machine Learning Research}</span>
<span class="sd">                    }</span>

<span class="sd">    Notes:</span>
<span class="sd">        * This method has a lot of parameters, it becomes fairly hard to cross-validate thoroughly.</span>
<span class="sd">        * Fails if matrix is singular when computing alpha_star, fixed by PCA.</span>
<span class="sd">        * Singularity might be caused by repeating samples.</span>
<span class="sd">        * Maintaining the kernel matrix becomes unfeasible above a couple of thousand vectors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">]</span>
    
<div class="viewcode-block" id="ADG.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADG.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span> <span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span> <span class="mi">12</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            kernel (str): &#39;inner&#39;/&#39;rbf_x&#39;, where x is a float, the bandwidth</span>
<span class="sd">            lam (float): lambda parameter of the method</span>
<span class="sd">            mu (float): mu parameter of the method</span>
<span class="sd">            k (int): number of samples to generate in each iteration</span>
<span class="sd">            gamma (float): gamma parameter of the method</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">kernel</span> <span class="o">!=</span> <span class="s1">&#39;inner&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">kernel</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;rbf&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s1">&#39;Kernel function </span><span class="si">%s</span><span class="s1"> not supported&#39;</span> <span class="o">%</span> <span class="n">kernel</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">kernel</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;rbf&#39;</span><span class="p">):</span>
            <span class="n">par</span><span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">par</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s1">&#39;Kernel parameter </span><span class="si">%f</span><span class="s1"> is not supported&#39;</span> <span class="o">%</span> <span class="n">par</span><span class="p">)</span>
                
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">lam</span><span class="p">,</span> <span class="s1">&#39;lam&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">mu</span><span class="p">,</span> <span class="s1">&#39;mu&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="s1">&#39;gamma&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">=</span> <span class="n">kernel</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="o">=</span> <span class="n">lam</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="o">=</span> <span class="n">mu</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="ADG.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADG.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="s1">&#39;rbf_0.5&#39;</span><span class="p">,</span> <span class="s1">&#39;rbf_1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;rbf_2.0&#39;</span><span class="p">],</span> 
                                                   <span class="s1">&#39;lam&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                   <span class="s1">&#39;mu&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                   <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">12</span><span class="p">],</span> 
                                                   <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="ADG.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADG.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">def</span> <span class="nf">bic_score</span><span class="p">(</span><span class="n">kmeans</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Compute BIC score for clustering</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                kmeans (sklearn.KMeans): kmeans object</span>
<span class="sd">                X (np.matrix):  clustered data</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: bic value</span>
<span class="sd">            </span>
<span class="sd">            Inspired by https://stats.stackexchange.com/questions/90769/using-bic-to-estimate-the-number-of-k-in-kmeans</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># extract descriptors of the clustering</span>
            <span class="n">cluster_centers</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
            <span class="n">cluster_labels</span>  <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span>
            <span class="n">n_clusters</span> <span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">n_clusters</span>
            <span class="n">n_in_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">)</span>
            <span class="n">N</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span>
        
            <span class="c1">#compute variance for all clusters beforehand</span>
            <span class="n">cluster_variances</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">cluster_centers</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)]</span>
            <span class="n">clustering_variance</span><span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="n">N</span> <span class="o">-</span> <span class="n">n_clusters</span><span class="p">)</span><span class="o">*</span><span class="n">d</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cluster_variances</span><span class="p">)</span>
        
            <span class="n">const_term</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">n_clusters</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">d</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        
            <span class="n">bic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">n_in_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">n_in_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span>
                          <span class="n">n_in_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span>
                          <span class="p">((</span><span class="n">n_in_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">clustering_variance</span><span class="p">)</span> <span class="o">-</span>
                          <span class="p">((</span><span class="n">n_in_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span><span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)])</span> <span class="o">-</span> <span class="n">const_term</span>
        
            <span class="k">return</span> <span class="n">bic</span>
        
        <span class="k">def</span> <span class="nf">xmeans</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Clustering with BIC based n_cluster selection</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                X (np.matrix): data to cluster</span>
<span class="sd">                r (tuple): lower and upper bound on the number of clusters</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                sklearn.KMeans: clustering with lowest BIC score</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">best_bic</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">best_clustering</span><span class="o">=</span> <span class="kc">None</span>
            
            <span class="c1"># do clustering for all n_clusters in the specified range</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)])):</span>
                <span class="n">kmeans</span><span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                
                <span class="n">bic</span><span class="o">=</span> <span class="n">bic_score</span><span class="p">(</span><span class="n">kmeans</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bic</span> <span class="o">&lt;</span> <span class="n">best_bic</span><span class="p">:</span>
                    <span class="n">best_bic</span><span class="o">=</span> <span class="n">bic</span>
                    <span class="n">best_clustering</span><span class="o">=</span> <span class="n">kmeans</span>
            
            <span class="k">return</span> <span class="n">best_clustering</span>
        
        <span class="k">def</span> <span class="nf">xgmeans</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Gaussian mixture with BIC to select the optimal number of components</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                X (np.matrix): data to cluster</span>
<span class="sd">                r (tuple): lower and upper bound on the number of components</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                sklearn.GaussianMixture: Gaussian mixture model with the lowest BIC score</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">best_bic</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">best_mixture</span><span class="o">=</span> <span class="kc">None</span>
            
            <span class="c1"># do model fitting for all n_components in the specified range</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">([</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)])):</span>
                <span class="n">gmm</span><span class="o">=</span> <span class="n">GaussianMixture</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span> <span class="n">k</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="n">bic</span><span class="o">=</span> <span class="n">gmm</span><span class="o">.</span><span class="n">bic</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">bic</span> <span class="o">&lt;</span> <span class="n">best_bic</span><span class="p">:</span>
                    <span class="n">best_bic</span><span class="o">=</span> <span class="n">bic</span>
                    <span class="n">best_mixture</span><span class="o">=</span> <span class="n">gmm</span>
            
            <span class="k">return</span> <span class="n">best_mixture</span>
        
        <span class="k">def</span> <span class="nf">evaluate_matrices</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            The function evaluates the matrices specified in the method.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                X (np.matrix): features</span>
<span class="sd">                y (np.array): target labels</span>
<span class="sd">                kernel (function): the kernel function to be used</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                np.matrix, np.matrix, int, int, np.matrix, np.array, np.matrix, np.matrix, np.matrix</span>
<span class="sd">                np.array, np.matrix, np.matrix, np.matrix, np.matrix:</span>
<span class="sd">                    X_minux, X_plus, l_minus, l_plus, X, y, K, M_plus, M_minus, M, K_plus, K_minus, N_plus, n_minus</span>
<span class="sd">                    using the notations of the paper, X and y are ordered by target labels</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">X_minus</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
            <span class="n">X_plus</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
            <span class="n">l_minus</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_minus</span><span class="p">)</span>
            <span class="n">l_plus</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_plus</span><span class="p">)</span>
            
            <span class="n">X</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_minus</span><span class="p">,</span> <span class="n">X_plus</span><span class="p">])</span>
            <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span><span class="o">*</span><span class="n">l_minus</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span><span class="o">*</span><span class="n">l_plus</span><span class="p">)])</span>
            
            <span class="n">K</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span> <span class="n">kernel</span><span class="p">)</span>
            <span class="n">M_plus</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">K</span><span class="p">[:,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_minus</span><span class="p">):],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">M_minus</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">K</span><span class="p">[:,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">X_minus</span><span class="p">)],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">M</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M_minus</span> <span class="o">-</span> <span class="n">M_plus</span><span class="p">,</span> <span class="n">M_minus</span> <span class="o">-</span> <span class="n">M_plus</span><span class="p">)</span>
            
            <span class="n">K_minus</span><span class="o">=</span> <span class="n">K</span><span class="p">[:,</span> <span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">X_minus</span><span class="p">)]</span>
            <span class="n">K_plus</span><span class="o">=</span> <span class="n">K</span><span class="p">[:,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_minus</span><span class="p">):]</span>
            
            <span class="c1">#N_minus= np.dot(np.dot(K_minus, np.eye(l_minus) - np.full((l_minus, l_minus), 1.0/l_minus)), K_minus.T)</span>
            <span class="c1">#N_plus= np.dot(np.dot(K_plus, np.eye(l_plus) - np.full((l_plus, l_plus), 1.0/l_plus)), K_plus.T)</span>
            
            <span class="k">return</span> <span class="n">X_minus</span><span class="p">,</span> <span class="n">X_plus</span><span class="p">,</span> <span class="n">l_minus</span><span class="p">,</span> <span class="n">l_plus</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">M_plus</span><span class="p">,</span> <span class="n">M_minus</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K_plus</span><span class="p">,</span> <span class="n">K_minus</span>
        
        <span class="c1"># Implementation of the technique, following the steps and notations of the paper</span>
        <span class="n">q</span><span class="o">=</span> <span class="n">num_to_sample</span>
        
        <span class="c1"># instantiating the proper kernel function, the parameter of the RBF is supposed</span>
        <span class="c1"># to be the denominator in the Gaussian</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span> <span class="o">==</span> <span class="s1">&#39;inner&#39;</span><span class="p">:</span>
            <span class="n">kernel_function</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kf</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;rbf&#39;</span><span class="p">:</span>
                <span class="n">d</span><span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">kf</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">kernel_function</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>
        
        <span class="c1"># Initial evaluation of the matrices</span>
        <span class="n">X_minus</span><span class="p">,</span> <span class="n">X_plus</span><span class="p">,</span> <span class="n">l_minus</span><span class="p">,</span> <span class="n">l_plus</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">M_plus</span><span class="p">,</span> <span class="n">M_minus</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">K_plus</span><span class="p">,</span> <span class="n">K_minus</span><span class="o">=</span> <span class="n">evaluate_matrices</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kernel</span><span class="o">=</span> <span class="n">kernel_function</span><span class="p">)</span>
        <span class="c1"># The computing of N matrix is factored into two steps, computing N_plus and N_minus</span>
        <span class="c1"># this is used to improve efficiency</span>
        <span class="n">K_plus2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K_plus</span><span class="p">,</span> <span class="n">K_plus</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">K_plus_sum</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K_plus</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">K_plus_diad</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">K_plus_sum</span><span class="p">,</span> <span class="n">K_plus_sum</span><span class="p">)</span><span class="o">/</span><span class="n">l_plus</span>
        
        <span class="n">K_minus2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K_minus</span><span class="p">,</span> <span class="n">K_minus</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">K_minus_sum</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">K_minus</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">K_minus_diad</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">K_minus_sum</span><span class="p">,</span> <span class="n">K_minus_sum</span><span class="p">)</span><span class="o">/</span><span class="n">l_minus</span>
        
        <span class="n">N</span><span class="o">=</span> <span class="n">K_plus2</span> <span class="o">-</span> <span class="n">K_plus_diad</span> <span class="o">+</span> <span class="n">K_minus2</span> <span class="o">-</span> <span class="n">K_minus_diad</span>
        
        <span class="n">X_plus_hat</span><span class="o">=</span> <span class="n">X_plus</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">l_minus</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_minus</span><span class="p">)</span>
        
        <span class="n">early_stop</span><span class="o">=</span> <span class="kc">False</span>
        <span class="n">total_added</span><span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># executing the sample generation</span>
        <span class="k">while</span> <span class="n">q</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Starting iteration with q=</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">q</span><span class="p">)</span>
            <span class="c1"># step 1</span>
            <span class="n">clusters</span><span class="o">=</span> <span class="n">xmeans</span><span class="p">(</span><span class="n">X_plus_hat</span><span class="p">)</span>
            <span class="n">l_c</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">clusters</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">clusters</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">)])</span>
            
            <span class="c1"># step 2</span>
            <span class="n">k_c</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.0</span><span class="o">/</span><span class="n">l_c</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">l_c</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">k_c</span><span class="p">[</span><span class="n">k_c</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="mi">1</span>
            <span class="n">lam_c</span><span class="p">,</span> <span class="n">mu_c</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="o">/</span><span class="n">l_c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="o">/</span><span class="n">l_c</span>
            
            <span class="c1"># step 3</span>
            <span class="n">omega</span><span class="o">=</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">k_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">lam_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">mu_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k_c</span><span class="p">))])</span>
            <span class="n">nu_c</span><span class="o">=</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">k_c</span><span class="o">*</span><span class="n">lam_c</span>
            <span class="n">M_plus_c</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">K</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_minus</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))[</span><span class="n">clusters</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k_c</span><span class="p">))]</span>
            
            <span class="c1"># step 4</span>
            <span class="n">A</span><span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">*</span><span class="n">N</span><span class="p">)</span> <span class="o">-</span> <span class="n">omega</span><span class="o">*</span><span class="n">K</span>
            <span class="n">b</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([(</span><span class="n">M_minus</span> <span class="o">-</span> <span class="n">M_plus_c</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">nu_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k_c</span><span class="p">))],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">alpha_star</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># handling the issue of singular matrix</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Singular matrix&quot;</span><span class="p">)</span>
                <span class="c1"># deleting huge data structures</span>
                <span class="k">if</span> <span class="n">q</span> <span class="o">==</span> <span class="n">num_to_sample</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                    <span class="n">K</span><span class="p">,</span> <span class="n">K_plus</span><span class="p">,</span> <span class="n">K_minus</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
                    <span class="n">n_components</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
                    <span class="n">pca</span><span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span> <span class="n">n_components</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;reducing dimensionality to </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">n_components</span><span class="p">))</span>
                    <span class="n">X_trans</span><span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">ADG</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span>
                                        <span class="n">kernel</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span>
                                        <span class="n">lam</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span>
                                        <span class="n">mu</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span>
                                        <span class="n">k</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span>
                                        <span class="n">gamma</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span>
                                        <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X_trans</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">X_samp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">pca</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">X_samp</span><span class="p">),</span> <span class="n">y_samp</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">q</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">continue</span>
            
            <span class="c1"># step 5</span>
            <span class="n">mixture</span><span class="o">=</span> <span class="n">xgmeans</span><span class="p">(</span><span class="n">X_plus</span><span class="p">)</span>
            
            <span class="c1"># step 6</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Z</span><span class="o">=</span> <span class="n">mixture</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">q</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: sampling error in sklearn.mixture.GaussianMixture&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="c1"># step 7</span>
            <span class="c1"># computing the kernel matrix of generated samples with all samples</span>
            <span class="n">K_10</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span> <span class="n">kernel_function</span><span class="p">)</span>
            <span class="n">mask_inner_prod</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">K_10</span><span class="p">,</span> <span class="n">alpha_star</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Z_hat</span><span class="o">=</span> <span class="n">Z</span><span class="p">[</span><span class="n">mask_inner_prod</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z_hat</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">q</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                <span class="k">continue</span>
            
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;number of vectors added: </span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Z_hat</span><span class="p">),</span> <span class="n">q</span><span class="p">))</span>
            
            <span class="c1"># step 8</span>
            <span class="c1"># this step is not used for anything, the identified clusters are only used in</span>
            <span class="c1"># step 13 of the paper, however, the values set (M_plus^c) are overwritten in step 3 </span>
            <span class="c1"># of the next iteration</span>
            
            <span class="c1"># step 9</span>
            <span class="n">X_plus_hat</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_plus_hat</span><span class="p">,</span> <span class="n">Z_hat</span><span class="p">])</span>
            <span class="n">l_plus</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_plus_hat</span><span class="p">)</span>
            
            <span class="c1"># step 11 - 16</span>
            <span class="c1"># these steps have been reorganized a bit for efficient calculations</span>
            
            <span class="n">K</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">K</span><span class="p">,</span> <span class="n">K_10</span><span class="p">[</span><span class="n">mask_inner_prod</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">],</span> <span class="p">[</span><span class="n">K_10</span><span class="p">[</span><span class="n">mask_inner_prod</span><span class="p">],</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">Z_hat</span><span class="p">,</span> <span class="n">Z_hat</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span> <span class="n">kernel_function</span><span class="p">)]])</span>

            <span class="n">K_minus</span><span class="o">=</span> <span class="n">K</span><span class="p">[:,</span> <span class="p">:</span><span class="n">l_minus</span><span class="p">]</span>
            <span class="n">K_plus</span><span class="o">=</span> <span class="n">K</span><span class="p">[:,</span> <span class="n">l_minus</span><span class="p">:]</span>
            
            <span class="c1"># step 10</span>
            <span class="n">X</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_minus</span><span class="p">,</span> <span class="n">X_plus_hat</span><span class="p">])</span>
            <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z_hat</span><span class="p">))])</span>
            
            <span class="k">if</span> <span class="n">early_stop</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">break</span>
            
            <span class="n">M_plus</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">K_plus</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">M_minus</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">K_minus</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># step 13 is already involved in the core of the loop</span>
            <span class="n">M</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">M_minus</span> <span class="o">-</span> <span class="n">M_plus</span><span class="p">,</span> <span class="n">M_minus</span> <span class="o">-</span> <span class="n">M_plus</span><span class="p">)</span>
            
            <span class="n">l_new</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z_hat</span><span class="p">)</span>
            <span class="n">total_added</span><span class="o">=</span> <span class="n">total_added</span> <span class="o">+</span> <span class="n">l_new</span>
            
            <span class="n">K_minus2_01</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K_minus</span><span class="p">[:</span><span class="o">-</span><span class="n">l_new</span><span class="p">:],</span> <span class="n">K_minus</span><span class="p">[</span><span class="o">-</span><span class="n">l_new</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">K_minus2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">K_minus2</span><span class="p">,</span> <span class="n">K_minus2_01</span><span class="p">],</span> <span class="p">[</span><span class="n">K_minus2_01</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K_minus</span><span class="p">[</span><span class="o">-</span><span class="n">l_new</span><span class="p">:],</span> <span class="n">K_minus</span><span class="p">[</span><span class="o">-</span><span class="n">l_new</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)]])</span>
            <span class="n">K_minus_sum</span><span class="o">=</span> <span class="n">M_minus</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">K_minus</span><span class="p">)</span>
            
            <span class="n">K_plus2</span><span class="o">=</span> <span class="n">K_plus2</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K_plus</span><span class="p">[:</span><span class="o">-</span><span class="n">l_new</span><span class="p">,</span><span class="n">l_new</span><span class="p">:],</span> <span class="n">K_plus</span><span class="p">[:</span><span class="o">-</span><span class="n">l_new</span><span class="p">,</span><span class="n">l_new</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">K_plus2_01</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K_plus</span><span class="p">[:</span><span class="o">-</span><span class="n">l_new</span><span class="p">],</span> <span class="n">K_plus</span><span class="p">[</span><span class="o">-</span><span class="n">l_new</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">K_plus2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">K_plus2</span><span class="p">,</span> <span class="n">K_plus2_01</span><span class="p">],</span> <span class="p">[</span><span class="n">K_plus2_01</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">K_plus</span><span class="p">[</span><span class="o">-</span><span class="n">l_new</span><span class="p">:],</span> <span class="n">K_plus</span><span class="p">[</span><span class="o">-</span><span class="n">l_new</span><span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)]])</span>
            <span class="n">K_plus_sum</span><span class="o">=</span> <span class="n">M_plus</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">K_plus</span><span class="p">)</span>
            
            <span class="n">N</span><span class="o">=</span> <span class="n">K_plus2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">K_plus_sum</span><span class="o">/</span><span class="n">l_plus</span><span class="p">,</span> <span class="n">K_plus_sum</span><span class="p">)</span> <span class="o">+</span> <span class="n">K_minus2</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">K_minus_sum</span><span class="o">/</span><span class="n">l_minus</span><span class="p">,</span> <span class="n">K_minus_sum</span><span class="p">)</span>
            
            <span class="c1"># step 17</span>
            <span class="k">if</span> <span class="n">l_new</span><span class="o">/</span><span class="n">total_added</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">:</span>
                <span class="n">early_stop</span><span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">q</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="ADG.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ADG.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;kernel&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">kernel</span><span class="p">,</span> 
                <span class="s1">&#39;lam&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">lam</span><span class="p">,</span> 
                <span class="s1">&#39;mu&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">,</span> 
                <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> 
                <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SMOTE_IPF"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_IPF">[docs]</a><span class="k">class</span> <span class="nc">SMOTE_IPF</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smote_ipf,</span>
<span class="sd">                        title = &quot;SMOTE–IPF: Addressing the noisy and borderline examples problem in imbalanced classification by a re-sampling method with filtering&quot;,</span>
<span class="sd">                        journal = &quot;Information Sciences&quot;,</span>
<span class="sd">                        volume = &quot;291&quot;,</span>
<span class="sd">                        pages = &quot;184 - 203&quot;,</span>
<span class="sd">                        year = &quot;2015&quot;,</span>
<span class="sd">                        issn = &quot;0020-0255&quot;,</span>
<span class="sd">                        doi = &quot;https://doi.org/10.1016/j.ins.2014.08.051&quot;,</span>
<span class="sd">                        url = &quot;http://www.sciencedirect.com/science/article/pii/S0020025514008561&quot;,</span>
<span class="sd">                        author = &quot;José A. Sáez and Julián Luengo and Jerzy Stefanowski and Francisco Herrera&quot;,</span>
<span class="sd">                        keywords = &quot;Imbalanced classification, Borderline examples, Noisy data, Noise filters, SMOTE&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_classifier</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE_IPF.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_IPF.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_folds</span><span class="o">=</span> <span class="mi">9</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="n">voting</span><span class="o">=</span> <span class="s1">&#39;majority&#39;</span><span class="p">,</span> <span class="n">classifier</span><span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in SMOTE sampling</span>
<span class="sd">            n_folds (int): the number of partitions</span>
<span class="sd">            k (int): used in stopping condition</span>
<span class="sd">            p (float): percentage value ([0,1]) used in stopping condition</span>
<span class="sd">            voting (str): &#39;majority&#39;/&#39;consensus&#39;</span>
<span class="sd">            classifier (obj): classifier object</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_folds</span><span class="p">,</span> <span class="s2">&quot;n_folds&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_isin</span><span class="p">(</span><span class="n">voting</span><span class="p">,</span> <span class="s2">&quot;voting&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;majority&#39;</span><span class="p">,</span> <span class="s1">&#39;consensus&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_folds</span><span class="o">=</span> <span class="n">n_folds</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="o">=</span> <span class="n">p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">voting</span><span class="o">=</span> <span class="n">voting</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">=</span> <span class="n">classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMOTE_IPF.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_IPF.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_folds&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span> 
                                                    <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">],</span> 
                                                    <span class="s1">&#39;voting&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;majority&#39;</span><span class="p">,</span> <span class="s1">&#39;consensus&#39;</span><span class="p">],</span> 
                                                    <span class="s1">&#39;classifier&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">)]})</span></div>
    
<div class="viewcode-block" id="SMOTE_IPF.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_IPF.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># do SMOTE sampling</span>
        <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">n_folds</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_folds</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)])</span>
        
        <span class="n">condition</span><span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># validating the sampled dataset</span>
            <span class="n">validator</span><span class="o">=</span> <span class="n">StratifiedKFold</span><span class="p">(</span><span class="n">n_folds</span><span class="p">)</span>
            <span class="n">predictions</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">train_index</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">validator</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_samp</span><span class="p">[</span><span class="n">train_index</span><span class="p">],</span> <span class="n">y_samp</span><span class="p">[</span><span class="n">train_index</span><span class="p">])</span>
                <span class="n">predictions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_samp</span><span class="p">))</span>
            
            <span class="c1"># do decision based on one of the voting schemes</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">voting</span> <span class="o">==</span> <span class="s1">&#39;majority&#39;</span><span class="p">:</span>
                <span class="n">pred_votes</span><span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">to_remove</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">pred_votes</span><span class="p">,</span> <span class="n">y_samp</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">voting</span> <span class="o">==</span> <span class="s1">&#39;consensus&#39;</span><span class="p">:</span>
                <span class="n">pred_votes</span><span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">sum_votes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">predictions</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">to_remove</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">not_equal</span><span class="p">(</span><span class="n">pred_votes</span><span class="p">,</span> <span class="n">y_samp</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">sum_votes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_folds</span><span class="p">)))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s1">&#39;Voting scheme </span><span class="si">%s</span><span class="s1"> is not implemented&#39;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">voting</span><span class="p">)</span>
            
            <span class="c1"># delete samples incorrectly classified</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s1">&#39;Removing </span><span class="si">%d</span><span class="s1"> elements&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">))</span>
            <span class="n">X_samp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_samp</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">y_samp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y_samp</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)</span>
            
            <span class="c1"># if the number of samples removed becomes small or k iterations were done quit</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_samp</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">:</span>
                <span class="n">condition</span><span class="o">=</span> <span class="n">condition</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">condition</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">condition</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">:</span>
                <span class="k">break</span>
            
        <span class="k">return</span> <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span></div>
        
<div class="viewcode-block" id="SMOTE_IPF.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_IPF.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_folds&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_folds</span><span class="p">,</span> 
                <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> 
                <span class="s1">&#39;p&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> 
                <span class="s1">&#39;voting&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">voting</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> 
                <span class="s1">&#39;classifier&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="KernelADASYN"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.KernelADASYN">[docs]</a><span class="k">class</span> <span class="nc">KernelADASYN</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{kernel_adasyn, </span>
<span class="sd">                            author={Tang, B. and He, H.}, </span>
<span class="sd">                            booktitle={2015 IEEE Congress on Evolutionary Computation (CEC)}, </span>
<span class="sd">                            title={KernelADASYN: Kernel based adaptive synthetic data generation for imbalanced learning}, </span>
<span class="sd">                            year={2015}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={664-671}, </span>
<span class="sd">                            keywords={learning (artificial intelligence);pattern classification;sampling methods;KernelADASYN;kernel based adaptive synthetic data generation;imbalanced learning;standard classification algorithms;data distribution;minority class decision rule;expensive minority class data misclassification;kernel based adaptive synthetic over-sampling approach;imbalanced data classification problems;kernel density estimation methods;Kernel;Estimation;Accuracy;Measurement;Standards;Training data;Sampling methods;Imbalanced learning;adaptive over-sampling;kernel density estimation;pattern recognition;medical and healthcare data learning}, </span>
<span class="sd">                            doi={10.1109/CEC.2015.7256954}, </span>
<span class="sd">                            ISSN={1089-778X}, </span>
<span class="sd">                            month={May}}</span>

<span class="sd">    Notes:</span>
<span class="sd">        * The method of sampling was not specified, Markov Chain Monte Carlo has been implemented.</span>
<span class="sd">        * Not prepared for improperly conditioned covariance matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_estimation</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">]</span>
    
<div class="viewcode-block" id="KernelADASYN.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.KernelADASYN.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            k (int): number of neighbors in the nearest neighbors component</span>
<span class="sd">            h (float): kernel bandwidth</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s1">&#39;h&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">=</span> <span class="n">h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="KernelADASYN.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.KernelADASYN.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> 
                                                    <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.02</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="KernelADASYN.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.KernelADASYN.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting the nearest neighbors model</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># computing majority score</span>
        <span class="n">r</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;majority score is 0 for all or all but one minority samples&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">r</span><span class="o">=</span> <span class="n">r</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        
        <span class="c1"># kernel density function</span>
        <span class="k">def</span> <span class="nf">p_x</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Returns minority density value at x</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                x (np.array): feature vector</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float: density value</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">result</span><span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span>
            <span class="n">result</span><span class="o">=</span> <span class="n">result</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">)</span><span class="o">**</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            
            <span class="k">return</span> <span class="n">result</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">))</span>
            
            <span class="c1">#return result*np.sum([r[i]*np.exp(-0.5*np.linalg.norm(x - X_min[i])**2/self.h) for i in range(len(X_min))])</span>
        
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">it</span><span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># parameters of the Monte Carlo sampling</span>
        <span class="n">burn_in</span><span class="o">=</span> <span class="mi">1000</span>
        <span class="n">periods</span><span class="o">=</span> <span class="mi">50</span>
        
        <span class="c1"># covariance is used to generate a random sample in the neighborhood</span>
        <span class="n">covariance</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rowvar</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cond</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;reducing dimensions due to inproperly conditioned covariance matrix&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;matrix ill-conditioned&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">n_components</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">pca</span><span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span> <span class="n">n_components</span><span class="p">)</span>
            <span class="n">X_trans</span><span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">ka</span><span class="o">=</span> <span class="n">KernelADASYN</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">ka</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X_trans</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">pca</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">X_samp</span><span class="p">),</span> <span class="n">y_samp</span>
        
        <span class="c1"># starting Markov-Chain Monte Carlo for sampling</span>
        <span class="n">x_old</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="n">p_old</span><span class="o">=</span> <span class="n">p_x</span><span class="p">(</span><span class="n">x_old</span><span class="p">)</span>
        
        <span class="c1"># Cholesky decomposition</span>
        <span class="n">L</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">cholesky</span><span class="p">(</span><span class="n">covariance</span><span class="p">)</span>
        
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">x_new</span><span class="o">=</span> <span class="n">x_old</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_old</span><span class="p">)),</span> <span class="n">L</span><span class="p">)</span>
            <span class="n">p_new</span><span class="o">=</span> <span class="n">p_x</span><span class="p">(</span><span class="n">x_new</span><span class="p">)</span>
            
            <span class="n">alpha</span><span class="o">=</span> <span class="n">p_new</span><span class="o">/</span><span class="n">p_old</span>
            <span class="n">u</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">u</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">:</span>
                <span class="n">x_old</span><span class="o">=</span> <span class="n">x_new</span>
                <span class="n">p_old</span><span class="o">=</span> <span class="n">p_new</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
            
            <span class="n">it</span><span class="o">=</span> <span class="n">it</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">it</span> <span class="o">%</span> <span class="n">periods</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">it</span> <span class="o">&gt;</span> <span class="n">burn_in</span><span class="p">:</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x_old</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="KernelADASYN.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.KernelADASYN.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> 
                <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="MOT2LD"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MOT2LD">[docs]</a><span class="k">class</span> <span class="nc">MOT2LD</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{mot2ld,</span>
<span class="sd">                            author=&quot;Xie, Zhipeng</span>
<span class="sd">                            and Jiang, Liyang</span>
<span class="sd">                            and Ye, Tengju</span>
<span class="sd">                            and Li, Xiaoli&quot;,</span>
<span class="sd">                            editor=&quot;Renz, Matthias</span>
<span class="sd">                            and Shahabi, Cyrus</span>
<span class="sd">                            and Zhou, Xiaofang</span>
<span class="sd">                            and Cheema, Muhammad Aamir&quot;,</span>
<span class="sd">                            title=&quot;A Synthetic Minority Oversampling Method Based on Local Densities in Low-Dimensional Space for Imbalanced Learning&quot;,</span>
<span class="sd">                            booktitle=&quot;Database Systems for Advanced Applications&quot;,</span>
<span class="sd">                            year=&quot;2015&quot;,</span>
<span class="sd">                            publisher=&quot;Springer International Publishing&quot;,</span>
<span class="sd">                            address=&quot;Cham&quot;,</span>
<span class="sd">                            pages=&quot;3--18&quot;,</span>
<span class="sd">                            abstract=&quot;Imbalanced class distribution is a challenging problem in many real-life classification problems. Existing synthetic oversampling do suffer from the curse of dimensionality because they rely heavily on Euclidean distance. This paper proposed a new method, called Minority Oversampling Technique based on Local Densities in Low-Dimensional Space (or MOT2LD in short). MOT2LD first maps each training sample into a low-dimensional space, and makes clustering of their low-dimensional representations. It then assigns weight to each minority sample as the product of two quantities: local minority density and local majority count, indicating its importance of sampling. The synthetic minority class samples are generated inside some minority cluster. MOT2LD has been evaluated on 15 real-world data sets. The experimental results have shown that our method outperforms some other existing methods including SMOTE, Borderline-SMOTE, ADASYN, and MWMOTE, in terms of G-mean and F-measure.&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-319-18123-3&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Clusters might contain 1 elements, and all points can be filtered as noise.</span>
<span class="sd">        * Clusters might contain 0 elements as well, if all points are filtered as noise.</span>
<span class="sd">        * The entire clustering can become empty.</span>
<span class="sd">        * TSNE is very slow when the number of instances is over a couple of 1000</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="MOT2LD.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MOT2LD.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">d_cut</span><span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_components (int): number of components for stochastic neighborhood embedding</span>
<span class="sd">            k (int): number of neighbors in the nearest neighbor component</span>
<span class="sd">            d_cut (float/str): distance cut value/&#39;auto&#39; for automated selection</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_components</span><span class="p">,</span> <span class="s1">&#39;n_component&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d_cut</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d_cut</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">d_cut</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s1">&#39;Non-positive d_cut is not allowed&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">d_cut</span> <span class="o">!=</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s1">&#39;d_cut value </span><span class="si">%s</span><span class="s1"> not implemented&#39;</span> <span class="o">%</span> <span class="n">d_cut</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_cut</span><span class="o">=</span> <span class="n">d_cut</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="MOT2LD.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MOT2LD.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;d_cut&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;auto&#39;</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="MOT2LD.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MOT2LD.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;starting TSNE&quot;</span><span class="p">)</span>
        <span class="c1"># do the stochastic embedding</span>
        <span class="n">X_tsne</span><span class="o">=</span> <span class="n">TSNE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X_tsne</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;TSNE finished&quot;</span><span class="p">)</span>
        
        <span class="c1"># fitting nearest neighbors model for all training data</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_tsne</span><span class="p">)</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d_cut</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="n">d_cut</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_cut</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_cut</span> <span class="o">==</span> <span class="s1">&#39;auto&#39;</span><span class="p">:</span>
            <span class="n">d_cut</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">distances</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># fitting nearest neighbors model to the minority data</span>
        <span class="n">nn_min</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn_min</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">distances_min</span><span class="p">,</span> <span class="n">indices_min</span><span class="o">=</span> <span class="n">nn_min</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># extracting the number of neighbors in a given radius</span>
        <span class="n">rho</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">d_cut</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_min</span><span class="p">])</span>
        <span class="n">closest_highest</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">delta</span><span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1"># implementation of the density peak clustering algorithm</span>
        <span class="c1"># based on http://science.sciencemag.org/content/344/6191/1492.full</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">)):</span>
            <span class="n">closest_neighbors</span><span class="o">=</span> <span class="n">indices_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">closest_densities</span><span class="o">=</span> <span class="n">rho</span><span class="p">[</span><span class="n">closest_neighbors</span><span class="p">]</span>
            <span class="n">closest_highs</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">closest_densities</span> <span class="o">&gt;</span> <span class="n">rho</span><span class="p">[</span><span class="n">i</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest_highs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">closest_highest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">closest_highs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">delta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">distances_min</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">closest_highs</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">closest_highest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">delta</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">distances_min</span><span class="p">))</span>
        
        <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rho</span><span class="p">))),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">peak_indices</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ssignal</span><span class="o">.</span><span class="n">find_peaks_cwt</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">widths</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">))))</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">peak_indices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;no peaks found&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">cluster_center_indices</span><span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">peak_indices</span><span class="p">]</span>
        <span class="n">cluster_centers</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">cluster_center_indices</span><span class="p">]</span>
        
        <span class="c1"># finding closest cluster center to minority points and deriving cluster labels</span>
        <span class="n">nn_cluster</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn_cluster</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">cluster_centers</span><span class="p">)</span>
        <span class="n">dist_cluster</span><span class="p">,</span> <span class="n">ind_cluster</span><span class="o">=</span> <span class="n">nn_cluster</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">cluster_labels</span><span class="o">=</span> <span class="n">ind_cluster</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># computing local minority counts and determining noisy samples</span>
        <span class="n">local_minority_count</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span>
        <span class="n">noise</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">rho</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="n">local_minority_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># determining importance scores</span>
        <span class="n">importance</span><span class="o">=</span> <span class="n">local_minority_count</span><span class="o">/</span><span class="n">rho</span>
        <span class="n">prob</span><span class="o">=</span> <span class="n">importance</span>
        <span class="n">prob</span><span class="p">[</span><span class="n">noise</span><span class="p">]</span><span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">prob</span><span class="o">=</span> <span class="n">prob</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
        
        <span class="c1"># extracting cluster indices</span>
        <span class="n">cluster_indices</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="c1"># removing noise from clusters</span>
        <span class="n">cluster_indices</span><span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">noise</span><span class="p">)))</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster_indices</span><span class="p">]</span>
        
        <span class="c1"># checking if clustering is empty</span>
        <span class="n">empty_clustering</span><span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">empty_clustering</span><span class="o">=</span> <span class="kc">False</span>
        
        <span class="k">if</span> <span class="n">empty_clustering</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Empty clustering&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">cluster_indices_size_0</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster_indices</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prob</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">cluster_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="n">cluster_indices_size_0</span><span class="p">:</span>
                <span class="n">prob</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">prob</span><span class="o">=</span> <span class="n">prob</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">prob</span><span class="p">)</span>
        
        <span class="c1"># carrying out the sampling</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="c1"># random sample according to the distribution computed</span>
            <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">prob</span><span class="p">)</span>
            <span class="c1"># cluster label of the random minority sample</span>
            <span class="n">cluster_label</span><span class="o">=</span> <span class="n">cluster_labels</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cluster_label</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if the cluster has only 1 elements, it is repeated</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">random_idx</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>            
                <span class="c1"># otherwise a random cluster index is selected for sample generation</span>
                <span class="n">random_neighbor_in_cluster_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">])</span>
                <span class="k">while</span> <span class="n">random_idx</span> <span class="o">==</span> <span class="n">random_neighbor_in_cluster_idx</span><span class="p">:</span>
                    <span class="n">random_neighbor_in_cluster_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">cluster_label</span><span class="p">])</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">random_idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_neighbor_in_cluster_idx</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">noise</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="MOT2LD.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MOT2LD.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> 
                <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> 
                <span class="s1">&#39;d_cut&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_cut</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="V_SYNTH"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.V_SYNTH">[docs]</a><span class="k">class</span> <span class="nc">V_SYNTH</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{v_synth,</span>
<span class="sd">                     author = {Young,Ii, William A. and Nykl, Scott L. and Weckman, Gary R. and Chelberg, David M.},</span>
<span class="sd">                     title = {Using Voronoi Diagrams to Improve Classification Performances when Modeling Imbalanced Datasets},</span>
<span class="sd">                     journal = {Neural Comput. Appl.},</span>
<span class="sd">                     issue_date = {July      2015},</span>
<span class="sd">                     volume = {26},</span>
<span class="sd">                     number = {5},</span>
<span class="sd">                     month = jul,</span>
<span class="sd">                     year = {2015},</span>
<span class="sd">                     issn = {0941-0643},</span>
<span class="sd">                     pages = {1041--1054},</span>
<span class="sd">                     numpages = {14},</span>
<span class="sd">                     url = {http://dx.doi.org/10.1007/s00521-014-1780-0},</span>
<span class="sd">                     doi = {10.1007/s00521-014-1780-0},</span>
<span class="sd">                     acmid = {2790665},</span>
<span class="sd">                     publisher = {Springer-Verlag},</span>
<span class="sd">                     address = {London, UK, UK},</span>
<span class="sd">                     keywords = {Data engineering, Data mining, Imbalanced datasets, Knowledge extraction, Numerical algorithms, Synthetic over-sampling},</span>
<span class="sd">                    }</span>

<span class="sd">    Notes:</span>
<span class="sd">        * The proposed encompassing bounding box generation is incorrect.</span>
<span class="sd">        * Voronoi diagram generation in high dimensional spaces is instable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="V_SYNTH.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.V_SYNTH.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_components (int): number of components for PCA</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_components</span><span class="p">,</span> <span class="s2">&quot;n_component&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="V_SYNTH.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.V_SYNTH.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="V_SYNTH.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.V_SYNTH.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># creating the bounding box</span>
        <span class="n">mins</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">maxs</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">mins</span><span class="o">=</span> <span class="n">mins</span> <span class="o">-</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mins</span><span class="p">)</span>
        <span class="n">maxs</span><span class="o">=</span> <span class="n">maxs</span> <span class="o">+</span> <span class="mf">0.1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">maxs</span><span class="p">)</span>
        
        <span class="n">bounding_box</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mins</span><span class="p">,</span> <span class="n">maxs</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="mi">100</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])]))]</span>
        <span class="n">X_bb</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">bounding_box</span><span class="p">])</span>
        
        <span class="c1"># applying PCA to reduce the dimensionality of the data</span>
        <span class="n">n_components</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">])</span>
        <span class="n">pca</span><span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span> <span class="n">n_components</span><span class="p">)</span>
        <span class="n">X_pca</span><span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_bb</span><span class="p">)</span>
        <span class="n">y_pca</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">))])</span>
        
        <span class="n">dm</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>
        <span class="n">to_remove</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">:</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">X_pca</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_pca</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">y_pca</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y_pca</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)</span>

        <span class="c1"># doing the Voronoi tessellation</span>
        <span class="n">voronoi</span><span class="o">=</span> <span class="n">sspatial</span><span class="o">.</span><span class="n">Voronoi</span><span class="p">(</span><span class="n">X_pca</span><span class="p">)</span>
        
        <span class="c1"># extracting those ridge point pairs which are candidates for generating</span>
        <span class="c1"># an edge between two cells of different class labels</span>
        <span class="n">candidate_face_generators</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">voronoi</span><span class="o">.</span><span class="n">ridge_points</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">y</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                <span class="n">candidate_face_generators</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate_face_generators</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="c1"># randomly choosing a pair from the ridge point pairs of different labels</span>
            <span class="n">random_face</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">candidate_face_generators</span><span class="p">)</span>
            <span class="c1"># extracting the vertices of the face between the points</span>
            <span class="n">face_vertices</span><span class="o">=</span> <span class="n">voronoi</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">voronoi</span><span class="o">.</span><span class="n">ridge_vertices</span><span class="p">[</span><span class="n">random_face</span><span class="p">]]</span>
            <span class="c1"># creating a random vector for sampling the face (supposed to be convex)</span>
            <span class="n">w</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_pca</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="n">w</span><span class="o">=</span> <span class="n">w</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            
            <span class="c1"># initiating a sample point on the face</span>
            <span class="n">sample_point_on_face</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_pca</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_pca</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                <span class="n">sample_point_on_face</span><span class="o">=</span> <span class="n">sample_point_on_face</span> <span class="o">+</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">face_vertices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
            <span class="c1"># finding the ridge point with the minority label</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">voronoi</span><span class="o">.</span><span class="n">ridge_points</span><span class="p">[</span><span class="n">random_face</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                <span class="n">h</span><span class="o">=</span> <span class="n">voronoi</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">voronoi</span><span class="o">.</span><span class="n">ridge_points</span><span class="p">[</span><span class="n">random_face</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">h</span><span class="o">=</span> <span class="n">voronoi</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">voronoi</span><span class="o">.</span><span class="n">ridge_points</span><span class="p">[</span><span class="n">random_face</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                
            <span class="c1"># generating a point between the minority ridge point and the random point on the face</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">sample_point_on_face</span><span class="p">,</span> <span class="n">h</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">pca</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="V_SYNTH.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.V_SYNTH.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="OUPS"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.OUPS">[docs]</a><span class="k">class</span> <span class="nc">OUPS</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{oups,</span>
<span class="sd">                        title = &quot;A priori synthetic over-sampling methods for increasing classification sensitivity in imbalanced data sets&quot;,</span>
<span class="sd">                        journal = &quot;Expert Systems with Applications&quot;,</span>
<span class="sd">                        volume = &quot;66&quot;,</span>
<span class="sd">                        pages = &quot;124 - 135&quot;,</span>
<span class="sd">                        year = &quot;2016&quot;,</span>
<span class="sd">                        issn = &quot;0957-4174&quot;,</span>
<span class="sd">                        doi = &quot;https://doi.org/10.1016/j.eswa.2016.09.010&quot;,</span>
<span class="sd">                        url = &quot;http://www.sciencedirect.com/science/article/pii/S0957417416304882&quot;,</span>
<span class="sd">                        author = &quot;William A. Rivera and Petros Xanthopoulos&quot;,</span>
<span class="sd">                        keywords = &quot;SMOTE, OUPS, Class imbalance, Classification&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * In the description of the algorithm a fractional number p (j) is used to index a vector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="OUPS.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.OUPS.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="OUPS.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.OUPS.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="OUPS.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.OUPS.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># extracting propensity scores</span>
        <span class="n">lr</span><span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">lr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">propensity</span><span class="o">=</span> <span class="n">lr</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lr</span><span class="o">.</span><span class="n">classes_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        
        <span class="c1"># sorting indices according to propensity scores</span>
        <span class="n">prop_sorted</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">propensity</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">propensity</span><span class="p">))),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="n">p</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span>
        <span class="n">n</span><span class="o">=</span> <span class="mi">0</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># implementing Algorithm 1 in the cited paper with some minor changes to enable</span>
        <span class="c1"># the proper sampling of p numbers</span>
        <span class="k">while</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">propensity</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">prop_sorted</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">propensity</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">num</span><span class="o">=</span> <span class="mi">1</span>
                <span class="n">p_tmp</span><span class="o">=</span> <span class="n">p</span>
                <span class="k">while</span> <span class="n">p_tmp</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span> <span class="o">+</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">propensity</span><span class="p">):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">p_tmp</span><span class="p">:</span>
                        <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">prop_sorted</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="mi">1</span><span class="p">]],</span> <span class="n">X</span><span class="p">[</span><span class="n">prop_sorted</span><span class="p">[</span><span class="n">n</span><span class="o">+</span><span class="n">num</span><span class="p">][</span><span class="mi">1</span><span class="p">]]))</span>
                    <span class="n">p_tmp</span><span class="o">=</span> <span class="n">p_tmp</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="n">num</span><span class="o">=</span> <span class="n">num</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">n</span><span class="o">=</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="OUPS.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.OUPS.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SMOTE_D"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_D">[docs]</a><span class="k">class</span> <span class="nc">SMOTE_D</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{smote_d,</span>
<span class="sd">                            author=&quot;Torres, Fredy Rodr{\&#39;i}guez</span>
<span class="sd">                            and Carrasco-Ochoa, Jes{\&#39;u}s A.</span>
<span class="sd">                            and Mart{\&#39;i}nez-Trinidad, Jos{\&#39;e} Fco.&quot;,</span>
<span class="sd">                            editor=&quot;Mart{\&#39;i}nez-Trinidad, Jos{\&#39;e} Francisco</span>
<span class="sd">                            and Carrasco-Ochoa, Jes{\&#39;u}s Ariel</span>
<span class="sd">                            and Ayala Ramirez, Victor</span>
<span class="sd">                            and Olvera-L{\&#39;o}pez, Jos{\&#39;e} Arturo</span>
<span class="sd">                            and Jiang, Xiaoyi&quot;,</span>
<span class="sd">                            title=&quot;SMOTE-D a Deterministic Version of SMOTE&quot;,</span>
<span class="sd">                            booktitle=&quot;Pattern Recognition&quot;,</span>
<span class="sd">                            year=&quot;2016&quot;,</span>
<span class="sd">                            publisher=&quot;Springer International Publishing&quot;,</span>
<span class="sd">                            address=&quot;Cham&quot;,</span>
<span class="sd">                            pages=&quot;177--188&quot;,</span>
<span class="sd">                            abstract=&quot;Imbalanced data is a problem of current research interest. This problem arises when the number of objects in a class is much lower than in other classes. In order to address this problem several methods for oversampling the minority class have been proposed. Oversampling methods generate synthetic objects for the minority class in order to balance the amount of objects between classes, among them, SMOTE is one of the most successful and well-known methods. In this paper, we introduce a modification of SMOTE which deterministically generates synthetic objects for the minority class. Our proposed method eliminates the random component of SMOTE and generates different amount of synthetic objects for each object of the minority class. An experimental comparison of the proposed method against SMOTE in standard imbalanced datasets is provided. The experimental results show an improvement of our proposed method regarding SMOTE, in terms of F-measure.&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-319-39393-3&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Copying happens if two points are the neighbors of each other.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE_D.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_D.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            k (int): number of neighbors in nearest neighbors component</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMOTE_D.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_D.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SMOTE_D.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_D.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># extracting standard deviations of distances</span>
        <span class="n">stds</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">dist</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># estimating sampling density</span>
        <span class="n">p_i</span><span class="o">=</span> <span class="n">stds</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">stds</span><span class="p">)</span>
        
        <span class="c1"># the other component of sampling density</span>
        <span class="n">p_ij</span><span class="o">=</span> <span class="n">dist</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">[:,</span><span class="mi">1</span><span class="p">:],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)[:,</span><span class="kc">None</span><span class="p">]</span>
        
        <span class="c1"># number of samples to generate between minority points</span>
        <span class="n">counts_ij</span><span class="o">=</span> <span class="n">num_to_sample</span><span class="o">*</span><span class="n">p_i</span><span class="p">[:,</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">p_ij</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_i</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">])):</span>
                <span class="k">while</span> <span class="n">counts_ij</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">counts_ij</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                        <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">counts_ij</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">counts_ij</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">counts_ij</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>
        
<div class="viewcode-block" id="SMOTE_D.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_D.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SMOTE_PSO"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_PSO">[docs]</a><span class="k">class</span> <span class="nc">SMOTE_PSO</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smote_pso,</span>
<span class="sd">                        title = &quot;PSO-based method for SVM classification on skewed data sets&quot;,</span>
<span class="sd">                        journal = &quot;Neurocomputing&quot;,</span>
<span class="sd">                        volume = &quot;228&quot;,</span>
<span class="sd">                        pages = &quot;187 - 197&quot;,</span>
<span class="sd">                        year = &quot;2017&quot;,</span>
<span class="sd">                        note = &quot;Advanced Intelligent Computing: Theory and Applications&quot;,</span>
<span class="sd">                        issn = &quot;0925-2312&quot;,</span>
<span class="sd">                        doi = &quot;https://doi.org/10.1016/j.neucom.2016.10.041&quot;,</span>
<span class="sd">                        url = &quot;http://www.sciencedirect.com/science/article/pii/S0925231216312668&quot;,</span>
<span class="sd">                        author = &quot;Jair Cervantes and Farid Garcia-Lamont and Lisbeth Rodriguez and Asdrúbal López and José Ruiz Castilla and Adrian Trueba&quot;,</span>
<span class="sd">                        keywords = &quot;Skew data sets, SVM, Hybrid algorithms&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * I find the description of the technique a bit confusing, especially on the bounds of the search space of velocities and positions. Equations 15 and 16 specify the lower and upper bounds, the lower bound is in fact a vector while the upper bound is a distance. I tried to implement something meaningful.</span>
<span class="sd">        * I also find the setting of accelerating constant 2.0 strange, most of the time the velocity will be bounded due to this choice. </span>
<span class="sd">        * Also, training and predicting probabilities with a non-linear SVM as the evaluation function becomes fairly expensive when the number of training vectors reaches a couple of thousands. To reduce computational burden, minority and majority vectors far from the other class are removed to reduce the size of both classes to a maximum of 500 samples. Generally, this shouldn&#39;t really affect the results as the technique focuses on the samples near the class boundaries.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_memetic</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_classifier</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE_PSO.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_PSO.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">n_pop</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">c1</span><span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">num_it</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            k (int): number of neighbors in nearest neighbors component, this is also the</span>
<span class="sd">                        multiplication factor of minority support vectors</span>
<span class="sd">            eps (float): use to specify the initially generated support vectors along minority-</span>
<span class="sd">                            majority lines</span>
<span class="sd">            n_pop (int): size of population</span>
<span class="sd">            w (float): intertia constant</span>
<span class="sd">            c1 (float): acceleration constant of local optimum</span>
<span class="sd">            c2 (float): acceleration constant of population optimum</span>
<span class="sd">            num_it (int): number of iterations</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="s2">&quot;eps&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_pop</span><span class="p">,</span> <span class="s2">&quot;n_pop&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="s2">&quot;c1&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="s2">&quot;c2&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">num_it</span><span class="p">,</span> <span class="s2">&quot;num_it&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">=</span> <span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="o">=</span> <span class="n">n_pop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="o">=</span> <span class="n">c1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="o">=</span> <span class="n">c2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_it</span><span class="o">=</span> <span class="n">num_it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMOTE_PSO.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_PSO.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_pop&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> 
                                                    <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;c1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;c2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;num_it&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SMOTE_PSO.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_PSO.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># saving original dataset</span>
        <span class="n">X_orig</span><span class="o">=</span> <span class="n">X</span>
        <span class="n">y_orig</span><span class="o">=</span> <span class="n">y</span>
        
        <span class="c1"># scaling the records</span>
        <span class="n">mms</span><span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="n">X_scaled</span><span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># removing majority and minority samples far from the training data if needed to</span>
        <span class="c1"># increase performance</span>
        <span class="n">performance_threshold</span><span class="o">=</span> <span class="mi">500</span>
        
        <span class="n">n_maj_to_remove</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span> <span class="o">-</span> <span class="n">performance_threshold</span>
        <span class="k">if</span> <span class="n">n_maj_to_remove</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if majority samples are to be removed</span>
            <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)</span>
            <span class="n">di</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))],</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">to_remove</span><span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># finding the proper number of samples farest from the minority samples</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">di</span><span class="p">))):</span>
                <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">:</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n_maj_to_remove</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="c1"># removing the samples</span>
            <span class="n">X_scaled</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)</span>
            
        <span class="n">n_min_to_remove</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">-</span> <span class="n">performance_threshold</span>
        <span class="k">if</span> <span class="n">n_min_to_remove</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># if majority samples are to be removed</span>
            <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">])</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">)</span>
            <span class="n">di</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">([(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))],</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">to_remove</span><span class="o">=</span> <span class="p">[]</span>
            <span class="c1"># finding the proper number of samples farest from the minority samples</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">di</span><span class="p">))):</span>
                <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">di</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">n_min_to_remove</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="c1"># removing the samples</span>
            <span class="n">X_scaled</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">)</span>
        
        <span class="c1"># fitting SVM to extract initial support vectors</span>
        <span class="n">svc</span><span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">kernel</span><span class="o">=</span> <span class="s1">&#39;rbf&#39;</span><span class="p">,</span> <span class="n">probability</span><span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">svc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_scaled</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># extracting the support vectors</span>
        <span class="n">SV_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">svc</span><span class="o">.</span><span class="n">support_</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        <span class="n">SV_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">svc</span><span class="o">.</span><span class="n">support_</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">])</span>
        
        <span class="n">X_SV_min</span><span class="o">=</span> <span class="n">X_scaled</span><span class="p">[</span><span class="n">SV_min</span><span class="p">]</span>
        <span class="n">X_SV_maj</span><span class="o">=</span> <span class="n">X_scaled</span><span class="p">[</span><span class="n">SV_maj</span><span class="p">]</span>
        
        <span class="c1"># finding nearest majority support vectors</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_SV_maj</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_SV_maj</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_SV_min</span><span class="p">)</span>
        
        <span class="c1"># finding the initial particle and specifying the search space</span>
        <span class="n">X_min_gen</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">search_space</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">init_velocity</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">SV_min</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_SV_maj</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">])):</span>
                <span class="n">min_vector</span><span class="o">=</span> <span class="n">X_SV_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">maj_vector</span><span class="o">=</span> <span class="n">X_SV_maj</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span>
                <span class="c1"># the upper bound of the search space if specified by the closest majority support vector</span>
                <span class="n">upper_bound</span><span class="o">=</span> <span class="n">X_SV_maj</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="c1"># the third element of the search space specification is the distance of the vector and the closest</span>
                <span class="c1"># majority support vector, which specifies the radius of the search</span>
                <span class="n">search_space</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">min_vector</span><span class="p">,</span> <span class="n">maj_vector</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">min_vector</span> <span class="o">-</span> <span class="n">upper_bound</span><span class="p">)])</span>
                <span class="c1"># initial particles</span>
                <span class="n">X_min_gen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">min_vector</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">*</span><span class="p">(</span><span class="n">maj_vector</span> <span class="o">-</span> <span class="n">min_vector</span><span class="p">))</span>
                <span class="c1"># initial velocities</span>
                <span class="n">init_velocity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">*</span><span class="p">(</span><span class="n">maj_vector</span> <span class="o">-</span> <span class="n">min_vector</span><span class="p">))</span>
        
        <span class="n">X_min_gen</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">X_min_gen</span><span class="p">)</span>
        <span class="n">init_velocity</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">init_velocity</span><span class="p">)</span>
        
        <span class="c1"># evaluates a specific particle</span>
        <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Trains support vector classifier and evaluates it</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                X_train (np.matrix): training vectors</span>
<span class="sd">                y_train (np.array): target labels</span>
<span class="sd">                X_test (np.matrix): test vectors</span>
<span class="sd">                y_test (np.array): test labels</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">svc</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
            <span class="n">y_pred</span><span class="o">=</span> <span class="n">svc</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">svc</span><span class="o">.</span><span class="n">classes_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">)</span>
        
        <span class="c1"># initializing the particle swarm and the particle and population level</span>
        <span class="c1"># memory</span>
        <span class="n">particle_swarm</span><span class="o">=</span> <span class="p">[</span><span class="n">X_min_gen</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
        <span class="n">velocities</span><span class="o">=</span> <span class="p">[</span><span class="n">init_velocity</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
        <span class="n">local_best</span><span class="o">=</span> <span class="p">[</span><span class="n">X_min_gen</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
        <span class="n">local_best_scores</span><span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span>
        <span class="n">global_best</span><span class="o">=</span> <span class="n">X_min_gen</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">global_best_score</span><span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_it</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Iteration </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span>
            <span class="c1"># evaluate population</span>
            <span class="n">scores</span><span class="o">=</span> <span class="p">[</span><span class="n">evaluate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_scaled</span><span class="p">,</span> <span class="n">p</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))]),</span> <span class="n">X_scaled</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">particle_swarm</span><span class="p">]</span>
            
            <span class="c1"># update best scores</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">scores</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">local_best_scores</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">local_best_scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">s</span>
                    <span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">particle_swarm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">global_best_score</span><span class="p">:</span>
                    <span class="n">global_best_score</span><span class="o">=</span> <span class="n">s</span>
                    <span class="n">global_best</span><span class="o">=</span> <span class="n">particle_swarm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="c1"># update velocities</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">particle_swarm</span><span class="p">):</span>
                <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="o">*</span><span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">global_best</span> <span class="o">-</span> <span class="n">p</span><span class="p">)</span>
            
            <span class="c1"># bound velocities according to search space constraints</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">velocities</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">search_space</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span><span class="p">:</span>
                        <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">search_space</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
            
            <span class="c1"># update positions</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">particle_swarm</span><span class="p">):</span>
                <span class="n">particle_swarm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">particle_swarm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="c1"># bound positions according to search space constraints</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">particle_swarm</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">search_space</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">search_space</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">search_space</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">search_space</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">search_space</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">search_space</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_orig</span><span class="p">,</span> <span class="n">mms</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">global_best</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y_orig</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">global_best</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="SMOTE_PSO.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_PSO.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> 
                <span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> 
                <span class="s1">&#39;n_pop&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">,</span> 
                <span class="s1">&#39;w&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> 
                <span class="s1">&#39;c1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> 
                <span class="s1">&#39;c2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span> 
                <span class="s1">&#39;num_it&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_it</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="CURE_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CURE_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">CURE_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @Article{cure_smote,</span>
<span class="sd">                        author=&quot;Ma, Li</span>
<span class="sd">                        and Fan, Suohai&quot;,</span>
<span class="sd">                        title=&quot;CURE-SMOTE algorithm and hybrid algorithm for feature selection and parameter optimization based on random forests&quot;,</span>
<span class="sd">                        journal=&quot;BMC Bioinformatics&quot;,</span>
<span class="sd">                        year=&quot;2017&quot;,</span>
<span class="sd">                        month=&quot;Mar&quot;,</span>
<span class="sd">                        day=&quot;14&quot;,</span>
<span class="sd">                        volume=&quot;18&quot;,</span>
<span class="sd">                        number=&quot;1&quot;,</span>
<span class="sd">                        pages=&quot;169&quot;,</span>
<span class="sd">                        abstract=&quot;The random forests algorithm is a type of classifier with prominent universality, a wide application range, and robustness for avoiding overfitting. But there are still some drawbacks to random forests. Therefore, to improve the performance of random forests, this paper seeks to improve imbalanced data processing, feature selection and parameter optimization.&quot;,</span>
<span class="sd">                        issn=&quot;1471-2105&quot;,</span>
<span class="sd">                        doi=&quot;10.1186/s12859-017-1578-z&quot;,</span>
<span class="sd">                        url=&quot;https://doi.org/10.1186/s12859-017-1578-z&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * It is not specified how to determine the cluster with the &quot;slowest growth rate&quot;</span>
<span class="sd">        * All clusters can be removed as noise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">]</span>
    
<div class="viewcode-block" id="CURE_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CURE_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">noise_th</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_clusters (int): number of clusters to generate</span>
<span class="sd">            noise_th (int): below this number of elements the cluster is considered as noise</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="s2">&quot;n_clusters&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">noise_th</span><span class="p">,</span> <span class="s2">&quot;noise_th&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">noise_th</span><span class="o">=</span> <span class="n">noise_th</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="CURE_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CURE_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> 
                                                    <span class="s1">&#39;noise_th&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="CURE_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CURE_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># standardizing the data</span>
        <span class="n">mms</span><span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="n">X_scaled</span><span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X_scaled</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># initiating clustering</span>
        <span class="n">clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))]</span>
        <span class="n">dm</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># setting the diagonal of the distance matrix to infinity</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)):</span>
            <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
        <span class="c1"># starting the clustering iteration</span>
        <span class="n">iteration</span><span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">:</span>
            <span class="n">iteration</span><span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="c1"># delete a cluster with slowest growth rate, determined by</span>
            <span class="c1"># the cluster size</span>
            <span class="k">if</span> <span class="n">iteration</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># extracting cluster sizes</span>
                <span class="n">cluster_sizes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">])</span>
                <span class="c1"># removing one of the clusters with the smallest size</span>
                <span class="n">to_remove</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_sizes</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">cluster_sizes</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">to_remove</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">clusters</span><span class="p">[</span><span class="n">to_remove</span><span class="p">]</span>
                <span class="c1"># adjusting the distance matrix accordingly</span>
                <span class="n">dm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">dm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            
            <span class="c1"># finding the cluster pair with the smallest distance</span>
            <span class="n">min_coord</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dm</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dm</span><span class="p">))</span>
            <span class="n">merge_a</span><span class="o">=</span> <span class="n">min_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">merge_b</span><span class="o">=</span> <span class="n">min_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># merging the clusters</span>
            <span class="n">clusters</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">clusters</span><span class="p">[</span><span class="n">merge_a</span><span class="p">],</span> <span class="n">clusters</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]])</span>
            <span class="c1"># removing one of them</span>
            <span class="k">del</span> <span class="n">clusters</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]</span>
            <span class="c1"># adjusting the distances in the distance matrix</span>
            <span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">],</span> <span class="n">dm</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">dm</span><span class="p">[:,</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span>
            <span class="c1"># removing the row and column corresponding to one of the merged clusters</span>
            <span class="n">dm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">merge_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">dm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">merge_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># updating the diagonal</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)):</span>
                <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
        <span class="c1"># removing clusters declared as noise</span>
        <span class="n">to_remove</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_th</span><span class="p">:</span>
                <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">))</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">]</span>
        
        <span class="c1"># all clusters can be noise</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;all clusters removed as noise&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">cluster_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">))</span>
            <span class="n">center</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">representative</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])]</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">representative</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">mms</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">))]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="CURE_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CURE_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> 
                <span class="s1">&#39;noise_th&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">noise_th</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SOMO"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOMO">[docs]</a><span class="k">class</span> <span class="nc">SOMO</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{somo,</span>
<span class="sd">                        title = &quot;Self-Organizing Map Oversampling (SOMO) for imbalanced data set learning&quot;,</span>
<span class="sd">                        journal = &quot;Expert Systems with Applications&quot;,</span>
<span class="sd">                        volume = &quot;82&quot;,</span>
<span class="sd">                        pages = &quot;40 - 52&quot;,</span>
<span class="sd">                        year = &quot;2017&quot;,</span>
<span class="sd">                        issn = &quot;0957-4174&quot;,</span>
<span class="sd">                        doi = &quot;https://doi.org/10.1016/j.eswa.2017.03.073&quot;,</span>
<span class="sd">                        url = &quot;http://www.sciencedirect.com/science/article/pii/S0957417417302324&quot;,</span>
<span class="sd">                        author = &quot;Georgios Douzas and Fernando Bacao&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * It is not specified how to handle those cases when a cluster contains 1 minority samples, the mean of within-cluster distances is set to 100 in these cases.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">]</span>
    
<div class="viewcode-block" id="SOMO.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOMO.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_grid</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_grid (int): size of grid</span>
<span class="sd">            sigma (float): sigma of SOM</span>
<span class="sd">            learning_rate (float) learning rate of SOM</span>
<span class="sd">            n_iter (int): number of iterations</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s1">&#39;proportion&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_grid</span><span class="p">,</span> <span class="s1">&#39;n_grid&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">learning_rate</span><span class="p">,</span> <span class="s1">&#39;learning_rate&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_iter</span><span class="p">,</span> <span class="s1">&#39;n_iter&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_grid</span><span class="o">=</span> <span class="n">n_grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="o">=</span> <span class="n">learning_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="o">=</span> <span class="n">n_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SOMO.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOMO.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_grid&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">13</span><span class="p">],</span> 
                                                    <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">],</span> 
                                                    <span class="s1">&#39;learning_rate&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SOMO.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOMO.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">N_inter</span><span class="o">=</span> <span class="n">num_to_sample</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">N_intra</span><span class="o">=</span> <span class="n">num_to_sample</span><span class="o">/</span><span class="mi">2</span>
        
        <span class="c1"># training SOM</span>
        <span class="n">som</span><span class="o">=</span> <span class="n">minisom</span><span class="o">.</span><span class="n">MiniSom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_grid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_grid</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">sigma</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> <span class="n">learning_rate</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">som</span><span class="o">.</span><span class="n">train_random</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)</span>
        
        <span class="c1"># constructing the grid</span>
        <span class="n">grid_min</span><span class="o">=</span> <span class="p">{}</span>
        <span class="n">grid_maj</span><span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
            <span class="n">tmp</span><span class="o">=</span> <span class="n">som</span><span class="o">.</span><span class="n">winner</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">idx</span><span class="o">=</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tmp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">grid_min</span><span class="p">:</span>
                <span class="n">grid_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">grid_maj</span><span class="p">:</span>
                <span class="n">grid_maj</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                <span class="n">grid_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">grid_maj</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># converting the grid to arrays</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grid_min</span><span class="p">:</span>
            <span class="n">grid_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grid_maj</span><span class="p">:</span>
            <span class="n">grid_maj</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">grid_maj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            
        <span class="c1"># filtering</span>
        <span class="n">filtered</span><span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grid_min</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">grid_maj</span><span class="p">:</span>
                <span class="n">filtered</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">filtered</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid_maj</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">grid_min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1.0</span>
        
        <span class="c1"># computing densities</span>
        <span class="n">densities</span><span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">filtered</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">filtered</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">densities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">grid_min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">grid_min</span><span class="p">[</span><span class="n">i</span><span class="p">]]))</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">densities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="mi">10</span>
                    
        <span class="c1"># all clusters can be filtered</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">densities</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;all clusters filtered&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># computing neighbour densities, using 4 neighborhood</span>
        <span class="n">neighbors</span><span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
        <span class="n">pair_densities</span><span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">densities</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="n">j</span><span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">n</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">densities</span><span class="p">:</span>
                    <span class="n">pair_densities</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">)]</span><span class="o">=</span> <span class="n">densities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">densities</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        
        <span class="c1"># computing weights</span>
        <span class="n">density_keys</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">densities</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">density_vals</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">densities</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        
        <span class="c1"># determining pair keys and density values</span>
        <span class="n">pair_keys</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">pair_densities</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">pair_vals</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">pair_densities</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
        
        <span class="c1"># determining densities</span>
        <span class="n">density_vals</span><span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">density_vals</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">density_vals</span><span class="p">)</span>
        <span class="n">pair_dens_vals</span><span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">pair_vals</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">pair_vals</span><span class="p">)</span>
        
        <span class="c1"># computing num of samples to generate</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">pair_vals</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dens_num</span><span class="o">=</span> <span class="n">N_intra</span>
            <span class="n">pair_num</span><span class="o">=</span> <span class="n">N_inter</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dens_num</span><span class="o">=</span> <span class="n">N_inter</span> <span class="o">+</span> <span class="n">N_intra</span>
            <span class="n">pair_num</span><span class="o">=</span> <span class="mi">0</span>
        
        <span class="c1"># generating the samples according to the extracted distributions</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dens_num</span><span class="p">:</span>
            <span class="n">cluster_idx</span><span class="o">=</span> <span class="n">density_keys</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">density_keys</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">density_vals</span><span class="p">)]</span>
            <span class="n">cluster</span><span class="o">=</span> <span class="n">grid_min</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span>
            <span class="n">sample_a</span><span class="p">,</span> <span class="n">sample_b</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">sample_a</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">sample_b</span><span class="p">]))</span>
        
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pair_num</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="n">pair_keys</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pair_keys</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">pair_dens_vals</span><span class="p">)]</span>
            <span class="n">cluster_a</span><span class="o">=</span> <span class="n">grid_min</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">cluster_b</span><span class="o">=</span> <span class="n">grid_min</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">cluster_a</span><span class="p">)],</span> <span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">cluster_b</span><span class="p">)]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="SOMO.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SOMO.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_grid&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_grid</span><span class="p">,</span> 
                <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> 
                <span class="s1">&#39;learning_rate&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">learning_rate</span><span class="p">,</span> 
                <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="ISOMAP_Hybrid"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISOMAP_Hybrid">[docs]</a><span class="k">class</span> <span class="nc">ISOMAP_Hybrid</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @inproceedings{isomap_hybrid,</span>
<span class="sd">                             author = {Gu, Qiong and Cai, Zhihua and Zhu, Li},</span>
<span class="sd">                             title = {Classification of Imbalanced Data Sets by Using the Hybrid Re-sampling Algorithm Based on Isomap},</span>
<span class="sd">                             booktitle = {Proceedings of the 4th International Symposium on Advances in Computation and Intelligence},</span>
<span class="sd">                             series = {ISICA &#39;09},</span>
<span class="sd">                             year = {2009},</span>
<span class="sd">                             isbn = {978-3-642-04842-5},</span>
<span class="sd">                             location = {Huangshi, China},</span>
<span class="sd">                             pages = {287--296},</span>
<span class="sd">                             numpages = {10},</span>
<span class="sd">                             url = {http://dx.doi.org/10.1007/978-3-642-04843-2_31},</span>
<span class="sd">                             doi = {10.1007/978-3-642-04843-2_31},</span>
<span class="sd">                             acmid = {1691478},</span>
<span class="sd">                             publisher = {Springer-Verlag},</span>
<span class="sd">                             address = {Berlin, Heidelberg},</span>
<span class="sd">                             keywords = {Imbalanced data set, Isomap, NCR, Smote, re-sampling},</span>
<span class="sd">                            } </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_dim_reduction</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">]</span>
    
<div class="viewcode-block" id="ISOMAP_Hybrid.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISOMAP_Hybrid.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">smote_n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            n_components (int): number of components</span>
<span class="sd">            smote_n_neighbors (int): number of neighbors in SMOTE sampling</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_components</span><span class="p">,</span> <span class="s2">&quot;n_components&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">smote_n_neighbors</span><span class="p">,</span> <span class="s2">&quot;smote_n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="o">=</span> <span class="n">n_components</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smote_n_neighbors</span><span class="o">=</span> <span class="n">smote_n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="ISOMAP_Hybrid.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISOMAP_Hybrid.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> 
                                                    <span class="s1">&#39;smote_n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="ISOMAP_Hybrid.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISOMAP_Hybrid.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">isomap</span><span class="o">=</span> <span class="n">Isomap</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_components</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">X_trans</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">isomap</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">X_sm</span><span class="p">,</span> <span class="n">y_sm</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smote_n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X_trans</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">NeighborhoodCleaningRule</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">remove_noise</span><span class="p">(</span><span class="n">X_sm</span><span class="p">,</span> <span class="n">y_sm</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ISOMAP_Hybrid.transform"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISOMAP_Hybrid.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms new data by the trained isomap</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): new data</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix: the transformed data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">isomap</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="ISOMAP_Hybrid.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISOMAP_Hybrid.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_components&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_components</span><span class="p">,</span> 
                <span class="s1">&#39;smote_n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">smote_n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="CE_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CE_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">CE_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{ce_smote, </span>
<span class="sd">                                author={Chen, S. and Guo, G. and Chen, L.}, </span>
<span class="sd">                                booktitle={2010 IEEE 24th International Conference on Advanced Information Networking and Applications Workshops}, </span>
<span class="sd">                                title={A New Over-Sampling Method Based on Cluster Ensembles}, </span>
<span class="sd">                                year={2010}, </span>
<span class="sd">                                volume={}, </span>
<span class="sd">                                number={}, </span>
<span class="sd">                                pages={599-604}, </span>
<span class="sd">                                keywords={data mining;Internet;pattern classification;pattern clustering;over sampling method;cluster ensembles;classification method;imbalanced data handling;CE-SMOTE;clustering consistency index;cluster boundary minority samples;imbalanced public data set;Mathematics;Computer science;Electronic mail;Accuracy;Nearest neighbor searches;Application software;Data mining;Conferences;Web sites;Information retrieval;classification;imbalanced data sets;cluster ensembles;over-sampling}, </span>
<span class="sd">                                doi={10.1109/WAINA.2010.40}, </span>
<span class="sd">                                ISSN={}, </span>
<span class="sd">                                month={April}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="CE_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CE_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            h (int): size of ensemble</span>
<span class="sd">            k (int): number of clusters/neighbors</span>
<span class="sd">            alpha (float): [0,1] threshold to select boundary samples</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">=</span> <span class="n">h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="CE_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CE_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="CE_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CE_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># do the clustering and labelling</span>
        <span class="n">d</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">labels</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">):</span>
            <span class="n">f</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">d</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">features</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="n">f</span><span class="p">)</span>
            <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="n">features</span><span class="p">])</span><span class="o">.</span><span class="n">labels_</span><span class="p">)</span>
        
        <span class="c1"># do the cluster matching, clustering 0 will be considered the one to match the others to</span>
        <span class="c1"># the problem of finding cluster matching is basically the &quot;assignment problem&quot;</span>
        <span class="n">base_label</span><span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">labels</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">i</span> <span class="o">==</span> <span class="n">base_label</span><span class="p">:</span>
                <span class="n">cost_matrix</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">):</span>
                        <span class="n">cost_matrix</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="n">base_label</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">,</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">))</span>
                <span class="c1"># solving the assignment problem</span>
                <span class="n">row_ind</span><span class="p">,</span> <span class="n">col_ind</span><span class="o">=</span> <span class="n">soptimize</span><span class="o">.</span><span class="n">linear_sum_assignment</span><span class="p">(</span><span class="o">-</span><span class="n">cost_matrix</span><span class="p">)</span>
                <span class="c1"># doing the relabeling</span>
                <span class="n">relabeling</span><span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row_ind</span><span class="p">)):</span>
                    <span class="n">relabeling</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">k</span><span class="p">]</span><span class="o">=</span> <span class="n">j</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">relabeling</span>
        
        <span class="c1"># compute clustering consistency index</span>
        <span class="n">labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
        <span class="n">cci</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span> <span class="n">key</span><span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span><span class="o">.</span><span class="n">count</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
        <span class="n">cci</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">cci</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cci</span><span class="o">=</span> <span class="n">cci</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span>
        
        <span class="c1"># determining minority boundary samples</span>
        <span class="n">P_boundary</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="n">cci</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)]</span>
        
        <span class="c1"># there might be no boundary samples</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">P_boundary</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;empty boundary&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># finding nearest neighbors of boundary samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">P_boundary</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">P_boundary</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">P_boundary</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">P_boundary</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">P_boundary</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="CE_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CE_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> 
                <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> 
                <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="Edge_Det_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Edge_Det_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">Edge_Det_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{Edge_Det_SMOTE, </span>
<span class="sd">                            author={Kang, Y. and Won, S.}, </span>
<span class="sd">                            booktitle={ICCAS 2010}, </span>
<span class="sd">                            title={Weight decision algorithm for oversampling technique on class-imbalanced learning}, </span>
<span class="sd">                            year={2010}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={182-186}, </span>
<span class="sd">                            keywords={edge detection;learning (artificial intelligence);weight decision algorithm;oversampling technique;class-imbalanced learning;class imbalanced data problem;edge detection algorithm;spatial space representation;Classification algorithms;Image edge detection;Training;Noise measurement;Glass;Training data;Machine learning;Imbalanced learning;Classification;Weight decision;Oversampling;Edge detection}, </span>
<span class="sd">                            doi={10.1109/ICCAS.2010.5669889}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={Oct}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * This technique is very loosely specified.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_based</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="Edge_Det_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Edge_Det_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            k (int): number of neighbors</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Edge_Det_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Edge_Det_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="Edge_Det_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Edge_Det_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">d</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># organizing class labels according to feature ranking</span>
        <span class="n">magnitudes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)),</span> <span class="n">y</span><span class="p">),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            <span class="c1"># extracting edge magnitudes in this dimension</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">magnitudes</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">=</span> <span class="n">magnitudes</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+</span> <span class="p">(</span><span class="n">label</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">label</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="c1"># density estimation</span>
        <span class="n">magnitudes</span><span class="o">=</span> <span class="n">magnitudes</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">magnitudes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">magnitudes</span><span class="p">)</span>
        <span class="n">magnitudes</span><span class="o">=</span> <span class="n">magnitudes</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">magnitudes</span><span class="p">)</span>
        
        <span class="c1"># fitting nearest neighbors models to minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_to_sample</span><span class="p">):</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">magnitudes</span><span class="p">)</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="Edge_Det_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Edge_Det_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;k&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="CBSO"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CBSO">[docs]</a><span class="k">class</span> <span class="nc">CBSO</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{cbso,</span>
<span class="sd">                            author=&quot;Barua, Sukarna</span>
<span class="sd">                            and Islam, Md. Monirul</span>
<span class="sd">                            and Murase, Kazuyuki&quot;,</span>
<span class="sd">                            editor=&quot;Lu, Bao-Liang</span>
<span class="sd">                            and Zhang, Liqing</span>
<span class="sd">                            and Kwok, James&quot;,</span>
<span class="sd">                            title=&quot;A Novel Synthetic Minority Oversampling Technique for Imbalanced Data Set Learning&quot;,</span>
<span class="sd">                            booktitle=&quot;Neural Information Processing&quot;,</span>
<span class="sd">                            year=&quot;2011&quot;,</span>
<span class="sd">                            publisher=&quot;Springer Berlin Heidelberg&quot;,</span>
<span class="sd">                            address=&quot;Berlin, Heidelberg&quot;,</span>
<span class="sd">                            pages=&quot;735--744&quot;,</span>
<span class="sd">                            abstract=&quot;Imbalanced data sets contain an unequal distribution of data samples among the classes and pose a challenge to the learning algorithms as it becomes hard to learn the minority class concepts. Synthetic oversampling techniques address this problem by creating synthetic minority samples to balance the data set. However, most of these techniques may create wrong synthetic minority samples which fall inside majority regions. In this respect, this paper presents a novel Cluster Based Synthetic Oversampling (CBSO) algorithm. CBSO adopts its basic idea from existing synthetic oversampling techniques and incorporates unsupervised clustering in its synthetic data generation mechanism. CBSO ensures that synthetic samples created via this method always lie inside minority regions and thus, avoids any wrong synthetic sample creation. Simualtion analyses on some real world datasets show the effectiveness of CBSO showing improvements in various assesment metrics such as overall accuracy, F-measure, and G-mean.&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-642-24958-7&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Clusters containing 1 element induce cloning of samples.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_based</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="CBSO.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CBSO.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">C_p</span><span class="o">=</span> <span class="mf">1.3</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            C_p (float): used to set the threshold of clustering</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">C_p</span><span class="p">,</span> <span class="s2">&quot;C_p&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">C_p</span><span class="o">=</span> <span class="n">C_p</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="CBSO.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CBSO.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;C_p&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.3</span><span class="p">,</span> <span class="mf">1.6</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="CBSO.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CBSO.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model to find neighbors of minority points</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># extracting the number of majority neighbors</span>
        <span class="n">weights</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))]</span>
        <span class="c1"># determine distribution of generating data</span>
        <span class="n">weights</span><span class="o">=</span> <span class="n">weights</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        
        <span class="c1"># do the clustering</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">d_avg</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)[</span><span class="mi">0</span><span class="p">][:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">T_h</span><span class="o">=</span> <span class="n">d_avg</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">C_p</span>
        
        <span class="c1"># initiating clustering</span>
        <span class="n">clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))]</span>
        <span class="n">dm</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># setting the diagonal of the distance matrix to infinity</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)):</span>
            <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
        <span class="c1"># starting the clustering iteration</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># finding the cluster pair with the smallest distance</span>
            <span class="n">min_coord</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dm</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dm</span><span class="p">))</span>
            <span class="n">merge_a</span><span class="o">=</span> <span class="n">min_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">merge_b</span><span class="o">=</span> <span class="n">min_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># check termination conditions</span>
            <span class="k">if</span> <span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">,</span> <span class="n">merge_b</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">T_h</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>
            
            <span class="c1"># merging the clusters</span>
            <span class="n">clusters</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">clusters</span><span class="p">[</span><span class="n">merge_a</span><span class="p">],</span> <span class="n">clusters</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]])</span>
            <span class="c1"># removing one of them</span>
            <span class="k">del</span> <span class="n">clusters</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]</span>
            <span class="c1"># adjusting the distances in the distance matrix</span>
            <span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">],</span> <span class="n">dm</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">dm</span><span class="p">[:,</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span>
            <span class="c1"># removing the row and column corresponding to one of the merged clusters</span>
            <span class="n">dm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">merge_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">dm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">merge_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># updating the diagonal</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)):</span>
                <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="c1"># extracting cluster labels</span>
        <span class="n">labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">labels</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">i</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">weights</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>
                <span class="k">while</span> <span class="n">random_idx</span> <span class="o">==</span> <span class="n">idx</span><span class="p">:</span>
                    <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
    
<div class="viewcode-block" id="CBSO.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CBSO.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;C_p&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_p</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>
    
<div class="viewcode-block" id="E_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.E_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">E_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{e_smote, </span>
<span class="sd">                            author={Deepa, T. and Punithavalli, M.}, </span>
<span class="sd">                            booktitle={2011 3rd International Conference on Electronics Computer Technology}, </span>
<span class="sd">                            title={An E-SMOTE technique for feature selection in High-Dimensional Imbalanced Dataset}, </span>
<span class="sd">                            year={2011}, </span>
<span class="sd">                            volume={2}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={322-324}, </span>
<span class="sd">                            keywords={bioinformatics;data mining;pattern classification;support vector machines;E-SMOTE technique;feature selection;high-dimensional imbalanced dataset;data mining;bio-informatics;dataset balancing;SVM classification;micro array dataset;Feature extraction;Genetic algorithms;Support vector machines;Data mining;Machine learning;Bioinformatics;Cancer;Imbalanced dataset;Featue Selection;E-SMOTE;Support Vector Machine[SVM]}, </span>
<span class="sd">                            doi={10.1109/ICECTECH.2011.5941710}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={April}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * This technique is basically unreproducible. I try to implement something following the idea of applying some simple genetic algorithm for optimization.</span>
<span class="sd">        * In my best understanding, the technique uses evolutionary algorithms to for feature selection and then applies vanilla SMOTE on the selected features only.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_dim_reduction</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_memetic</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">]</span>
    
<div class="viewcode-block" id="E_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.E_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">min_features</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in the nearest neighbors component</span>
<span class="sd">            min_features (int): minimum number of features</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">min_features</span><span class="p">,</span> <span class="s2">&quot;min_features&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_features</span><span class="o">=</span> <span class="n">min_features</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="E_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.E_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;min_features&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="E_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.E_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">min_features</span><span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_features</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">800</span><span class="p">:</span>
            <span class="n">classifier</span><span class="o">=</span> <span class="n">SVC</span><span class="p">(</span><span class="n">gamma</span><span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">classifier</span><span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">max_depth</span><span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="c1"># parameters of the evolutionary algorithm</span>
        <span class="n">n_generations</span><span class="o">=</span> <span class="mi">50</span>
        <span class="n">n_population</span><span class="o">=</span> <span class="mi">5</span>
        
        <span class="c1"># creating initial mask</span>
        <span class="n">mask</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="c1"># fixing if the mask doesn&#39;t contain any features</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">))]</span><span class="o">=</span> <span class="kc">True</span>
        
        <span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">mask_a</span><span class="p">,</span> <span class="n">mask_b</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Crossover operation for two masks</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                mask_a (np.array): binary mask 1</span>
<span class="sd">                mask_b (np.array): binary mask 2</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                np.array: the result of crossover</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">mask</span><span class="o">=</span> <span class="n">mask_a</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask_b</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">mask_b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_features</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">))]</span><span class="o">=</span> <span class="kc">True</span>
            
            <span class="k">return</span> <span class="n">mask</span>
        
        <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="n">mask_old</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Mutation operation for a mask</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                mask_old (np.array): binary mask</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                np.array: the result of mutation</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">mask</span><span class="o">=</span> <span class="n">mask_old</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            
            <span class="k">while</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_features</span><span class="p">:</span>
                <span class="n">mask</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">))]</span><span class="o">=</span> <span class="kc">True</span>
                
            <span class="k">return</span> <span class="n">mask</span>
        
        <span class="c1"># generating initial population</span>
        <span class="n">population</span><span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_population</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_generations</span><span class="p">):</span>
            <span class="c1"># in each generation</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_population</span><span class="p">):</span>
                <span class="c1"># for each element of a population</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># crossover</span>
                    <span class="n">mask</span><span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">n_population</span><span class="p">)][</span><span class="mi">1</span><span class="p">],</span> <span class="n">population</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">n_population</span><span class="p">)][</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># mutation</span>
                    <span class="n">mask</span><span class="o">=</span> <span class="n">mutate</span><span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">n_population</span><span class="p">)][</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># evaluation</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;evaluating mask selection with features </span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mask</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)))</span>
                <span class="n">score</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="n">mask</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="n">mask</span><span class="p">]))</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
                <span class="c1"># appending the result to the population</span>
                <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">score</span><span class="p">,</span> <span class="n">mask</span><span class="p">])</span>
            <span class="c1"># sorting the population in a reversed order and keeping the elements with the highest scores</span>
            <span class="n">population</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])[:</span><span class="n">n_population</span><span class="p">]</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span> <span class="n">population</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># resampling the population in the given dimensions</span>
        <span class="k">return</span> <span class="n">SMOTE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span> <span class="n">y</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="E_SMOTE.transform"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.E_SMOTE.transform">[docs]</a>    <span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform new data by the learnt transformation</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): new data</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix: transformed data</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">X</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="E_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.E_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;min_features&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_features</span><span class="p">,</span>
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="DBSMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DBSMOTE">[docs]</a><span class="k">class</span> <span class="nc">DBSMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @Article{dbsmote,</span>
<span class="sd">                        author=&quot;Bunkhumpornpat, Chumphol</span>
<span class="sd">                        and Sinapiromsaran, Krung</span>
<span class="sd">                        and Lursinsap, Chidchanok&quot;,</span>
<span class="sd">                        title=&quot;DBSMOTE: Density-Based Synthetic Minority Over-sampling TEchnique&quot;,</span>
<span class="sd">                        journal=&quot;Applied Intelligence&quot;,</span>
<span class="sd">                        year=&quot;2012&quot;,</span>
<span class="sd">                        month=&quot;Apr&quot;,</span>
<span class="sd">                        day=&quot;01&quot;,</span>
<span class="sd">                        volume=&quot;36&quot;,</span>
<span class="sd">                        number=&quot;3&quot;,</span>
<span class="sd">                        pages=&quot;664--684&quot;,</span>
<span class="sd">                        abstract=&quot;A dataset exhibits the class imbalance problem when a target class has a very small number of instances relative to other classes. A trivial classifier typically fails to detect a minority class due to its extremely low incidence rate. In this paper, a new over-sampling technique called DBSMOTE is proposed. Our technique relies on a density-based notion of clusters and is designed to over-sample an arbitrarily shaped cluster discovered by DBSCAN. DBSMOTE generates synthetic instances along a shortest path from each positive instance to a pseudo-centroid of a minority-class cluster. Consequently, these synthetic instances are dense near this centroid and are sparse far from this centroid. Our experimental results show that DBSMOTE improves precision, F-value, and AUC more effectively than SMOTE, Borderline-SMOTE, and Safe-Level-SMOTE for imbalanced datasets.&quot;,</span>
<span class="sd">                        issn=&quot;1573-7497&quot;,</span>
<span class="sd">                        doi=&quot;10.1007/s10489-011-0287-y&quot;,</span>
<span class="sd">                        url=&quot;https://doi.org/10.1007/s10489-011-0287-y&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Standardization is needed to use absolute eps values.</span>
<span class="sd">        * The clustering is likely to identify all instances as noise, fixed by recursive call with increaseing eps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_based</span><span class="p">]</span>
    
<div class="viewcode-block" id="DBSMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DBSMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            eps (float): eps paramter of DBSCAN</span>
<span class="sd">            min_samples (int): min_samples paramter of DBSCAN</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="s2">&quot;eps&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">min_samples</span><span class="p">,</span> <span class="s2">&quot;min_samples&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">=</span> <span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="o">=</span> <span class="n">min_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="DBSMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DBSMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">],</span> 
                                                    <span class="s1">&#39;min_samples&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="DBSMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DBSMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">ss</span><span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X_ss</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># doing the clustering using DBSCAN</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X_ss</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">db</span><span class="o">=</span> <span class="n">DBSCAN</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">labels</span><span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">labels_</span>
        <span class="n">num_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        
        <span class="k">if</span> <span class="n">num_labels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># adjusting the parameters if no clusters were identified</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Number of clusters is 0, trying to increase eps and decrease min_samples&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Number of clusters is 0, can&#39;t adjust parameters further&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">DBSMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># determining cluster size distribution</span>
        <span class="n">clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_labels</span><span class="p">)]</span>
        <span class="n">cluster_sizes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_labels</span><span class="p">)])</span>
        <span class="n">cluster_dist</span><span class="o">=</span> <span class="n">cluster_sizes</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cluster_sizes</span><span class="p">)</span>
        
        <span class="c1"># Bellman-Ford algorithm, inspired by https://gist.github.com/joninvski/701720</span>
        <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Initializes shortest path algorithm.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                graph (dict): graph in dictionary representation</span>
<span class="sd">                source (key): source node</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                dict, dict: initialized distance and path dictionaries</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;Inf&#39;</span><span class="p">)</span>
                <span class="n">p</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">d</span><span class="p">[</span><span class="n">source</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span>
        
        <span class="k">def</span> <span class="nf">relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Checks if shorter path exists.</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                u (key): key of a node</span>
<span class="sd">                v (key): key of another node</span>
<span class="sd">                graph (dict): the graph object</span>
<span class="sd">                d (dict): the distances dictionary</span>
<span class="sd">                p (dict): the paths dictionary</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>  <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
                <span class="n">p</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
        
        <span class="k">def</span> <span class="nf">bellman_ford</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Main entry point of the Bellman-Ford algorithm</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                graph (dict): a graph in dictionary representation</span>
<span class="sd">                source (key): the key of the source node</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">d</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">initialize</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                        <span class="n">relax</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
                    <span class="k">assert</span> <span class="n">d</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+</span> <span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">,</span> <span class="n">p</span>
        
        <span class="c1"># extract graphs and center-like objects</span>
        <span class="n">graphs</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">centroid_indices</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">shortest_paths</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_labels</span><span class="p">):</span>
            <span class="c1"># extracting the cluster elements</span>
            <span class="n">cluster</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">c</span><span class="p">]]</span>
            <span class="c1"># initializing the graph object</span>
            <span class="n">graph</span><span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)):</span>
                <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="p">{}</span>
            
            <span class="c1"># fitting nearest neighbors model to the cluster elements</span>
            <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">cluster</span><span class="p">)</span>
            
            <span class="c1"># extracting graph edges according to directly density reachabality definition</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])]</span> <span class="ow">and</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">:</span>
                        <span class="n">graph</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">graphs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">graph</span><span class="p">)</span>
            <span class="c1"># finding the index of the center like object</span>
            <span class="n">centroid_ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">centroid_indices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">centroid_ind</span><span class="p">)</span>
            <span class="c1"># extracting shortest paths from centroid object</span>
            <span class="n">shortest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bellman_ford</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">centroid_ind</span><span class="p">))</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">cluster_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">cluster_dist</span><span class="p">)</span>
            <span class="n">cluster</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]]</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])))</span>
            
            <span class="c1"># executing shortest path algorithm</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">parents</span><span class="o">=</span> <span class="n">shortest_paths</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span>
            
            <span class="c1"># extracting path</span>
            <span class="n">path</span><span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">parents</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">parents</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>
                
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if the center like object is selected</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># if the path consists of 1 edge</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points_componentwise</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">cluster</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># if the path consists of at least two edges</span>
                <span class="n">random_vertex</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points_componentwise</span><span class="p">(</span><span class="n">cluster</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="n">random_vertex</span><span class="p">]],</span> <span class="n">cluster</span><span class="p">[</span><span class="n">path</span><span class="p">[</span><span class="n">random_vertex</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]))</span>
    
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">))]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="DBSMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DBSMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> 
                <span class="s1">&#39;min_samples&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="ASMOBD"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ASMOBD">[docs]</a><span class="k">class</span> <span class="nc">ASMOBD</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{asmobd, </span>
<span class="sd">                            author={Senzhang Wang and Zhoujun Li and Wenhan Chao and Qinghua Cao}, </span>
<span class="sd">                            booktitle={The 2012 International Joint Conference on Neural Networks (IJCNN)}, </span>
<span class="sd">                            title={Applying adaptive over-sampling technique based on data density and cost-sensitive SVM to imbalanced learning}, </span>
<span class="sd">                            year={2012}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={1-8}, </span>
<span class="sd">                            keywords={data analysis;learning (artificial intelligence);sampling methods;smoothing methods;support vector machines;adaptive over-sampling technique;cost-sensitive SVM;imbalanced learning;resampling method;data density information;overfitting;minority sample;learning difficulty;decision region;over generalization;smoothing method;cost-sensitive learning;UCI dataset;G-mean of;receiver operation curve;Smoothing methods;Noise;Support vector machines;Classification algorithms;Interpolation;Measurement;Algorithm design and analysis;over-sampling;Cost-sensitive SVM;imbalanced learning}, </span>
<span class="sd">                            doi={10.1109/IJCNN.2012.6252696}, </span>
<span class="sd">                            ISSN={2161-4407}, </span>
<span class="sd">                            month={June}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * In order to use absolute thresholds, the data is standardized.</span>
<span class="sd">        * The technique has many parameters, not easy to find the right combination.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">]</span>
    
<div class="viewcode-block" id="ASMOBD.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ASMOBD.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">T_1</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">T_2</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">t_1</span><span class="o">=</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">t_2</span><span class="o">=</span> <span class="mf">4.0</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            min_samples (int): parameter of OPTICS</span>
<span class="sd">            eps (float): parameter of OPTICS</span>
<span class="sd">            eta (float): tradeoff paramter</span>
<span class="sd">            T_1 (float): noise threshold (see paper)</span>
<span class="sd">            T_2 (float): noise threshold (see paper)</span>
<span class="sd">            t_1 (float): noise threshold (see paper)</span>
<span class="sd">            t_2 (float): noise threshold (see paper)</span>
<span class="sd">            a (float): smoothing factor (see paper)</span>
<span class="sd">            smoothing (str): &#39;sigmoid&#39;/&#39;linear&#39;</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">min_samples</span><span class="p">,</span> <span class="s2">&quot;min_samples&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="s2">&quot;eps&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span> <span class="s2">&quot;eta&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">T_1</span><span class="p">,</span> <span class="s2">&quot;T_1&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">T_2</span><span class="p">,</span> <span class="s2">&quot;T_2&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">t_1</span><span class="p">,</span> <span class="s2">&quot;t_1&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">t_2</span><span class="p">,</span> <span class="s2">&quot;t_2&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_isin</span><span class="p">(</span><span class="n">smoothing</span><span class="p">,</span> <span class="s2">&quot;smoothing&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="o">=</span> <span class="n">min_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="o">=</span> <span class="n">eps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="o">=</span> <span class="n">eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_1</span><span class="o">=</span> <span class="n">T_1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_2</span><span class="o">=</span> <span class="n">T_2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_1</span><span class="o">=</span> <span class="n">t_1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_2</span><span class="o">=</span> <span class="n">t_2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">smoothing</span><span class="o">=</span> <span class="n">smoothing</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="ASMOBD.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ASMOBD.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span>
                                                   <span class="s1">&#39;min_samples&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                                   <span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">],</span>
                                                   <span class="s1">&#39;eta&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">],</span>
                                                   <span class="s1">&#39;T_1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">],</span>
                                                   <span class="s1">&#39;T_2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.4</span><span class="p">],</span>
                                                   <span class="s1">&#39;t_1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">],</span>
                                                   <span class="s1">&#39;t_2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">4.0</span><span class="p">],</span>
                                                   <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span>
                                                   <span class="s1">&#39;smoothing&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;sigmoid&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="ASMOBD.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ASMOBD.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># standardizing the data to enable using absolute thresholds</span>
        <span class="n">ss</span><span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X_ss</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X_ss</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># executing the optics algorithm</span>
        <span class="n">o</span><span class="o">=</span> <span class="n">OPTICS</span><span class="p">(</span><span class="n">min_samples</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">]),</span> <span class="n">max_eps</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">o</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">cd</span><span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">core_distances_</span>
        <span class="n">r</span><span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">reachability_</span>
        
        <span class="c1"># identifying noise</span>
        <span class="n">noise</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">cd</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_1</span><span class="p">,</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_2</span><span class="p">)</span>
        
        <span class="c1"># fitting nearest neighbors models to identify the number of majority samples in local environments</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_ss</span><span class="p">)</span>
        <span class="n">n_majs</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">ratio</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)):</span>
            <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">radius</span><span class="o">=</span> <span class="n">cd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">return_distance</span><span class="o">=</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
            <span class="n">n_majs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_maj</span><span class="p">)</span>
            <span class="n">n_min</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="o">-</span> <span class="n">n_maj</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">n_min</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ratio</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ratio</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n_maj</span><span class="o">/</span><span class="n">n_min</span><span class="p">)</span>
        
        <span class="n">n_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">n_maj</span><span class="p">)</span>
        <span class="n">ratio</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ratio</span><span class="p">)</span>
        
        <span class="c1"># second constraint on noise</span>
        <span class="n">noise_2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">cd</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">cd</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t_1</span><span class="p">,</span> <span class="n">r</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">t_2</span><span class="p">)</span>
        
        <span class="c1"># calculating density according to the smoothing function specified</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing</span> <span class="o">==</span> <span class="s1">&#39;sigmoid&#39;</span><span class="p">:</span>
            <span class="n">balance_ratio</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">2.0</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="o">*</span><span class="n">ratio</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
            <span class="n">df</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="o">*</span><span class="n">cd</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span><span class="o">*</span><span class="n">n_maj</span> <span class="o">-</span> <span class="n">balance_ratio</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="o">*</span><span class="n">cd</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span><span class="o">*</span><span class="n">n_maj</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">/</span><span class="n">num_to_sample</span>
        
        <span class="c1"># unifying the conditions on noise</span>
        <span class="n">not_noise</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">noise</span><span class="p">,</span> <span class="n">noise_2</span><span class="p">))</span>
        
        <span class="c1"># checking if there are not noise samples remaining</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_noise</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;All minority samples found to be noise, increasing noise thresholds&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ASMOBD</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span>
                          <span class="n">eta</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="n">T_1</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_1</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">T_2</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_2</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">t_1</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_1</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">t_2</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_2</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span> 
                          <span class="n">a</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># removing noise and adjusting the density factors accordingly</span>
        <span class="n">X_min_not_noise</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">not_noise</span><span class="p">]</span>
        
        <span class="c1"># checking if there are not-noisy samples</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min_not_noise</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;no not-noise minority sample remained&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">df</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">not_noise</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">density</span><span class="o">=</span> <span class="n">df</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        
        <span class="c1"># fitting nearest neighbors model to non-noise minority samples</span>
        <span class="n">nn_not_noise</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min_not_noise</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn_not_noise</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min_not_noise</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn_not_noise</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min_not_noise</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min_not_noise</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">density</span><span class="p">)</span>
            <span class="n">random_neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min_not_noise</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min_not_noise</span><span class="p">[</span><span class="n">random_neighbor_idx</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">))]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="ASMOBD.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ASMOBD.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;min_samples&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_samples</span><span class="p">,</span> 
                <span class="s1">&#39;eps&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">,</span> 
                <span class="s1">&#39;eta&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> 
                <span class="s1">&#39;T_1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_1</span><span class="p">,</span> 
                <span class="s1">&#39;T_2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_2</span><span class="p">,</span> 
                <span class="s1">&#39;t_1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_1</span><span class="p">,</span> 
                <span class="s1">&#39;t_2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_2</span><span class="p">,</span> 
                <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">,</span> 
                <span class="s1">&#39;smoothing&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">smoothing</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="Assembled_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Assembled_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">Assembled_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{assembled_smote, </span>
<span class="sd">                            author={Zhou, B. and Yang, C. and Guo, H. and Hu, J.}, </span>
<span class="sd">                            booktitle={The 2013 International Joint Conference on Neural Networks (IJCNN)}, </span>
<span class="sd">                            title={A quasi-linear SVM combined with assembled SMOTE for imbalanced data classification}, </span>
<span class="sd">                            year={2013}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={1-7}, </span>
<span class="sd">                            keywords={approximation theory;interpolation;pattern classification;sampling methods;support vector machines;trees (mathematics);quasilinear SVM;assembled SMOTE;imbalanced dataset classification problem;oversampling method;quasilinear kernel function;approximate nonlinear separation boundary;mulitlocal linear boundaries;interpolation;data distribution information;minimal spanning tree;local linear partitioning method;linear separation boundary;synthetic minority class samples;oversampled dataset classification;standard SVM;composite quasilinear kernel function;artificial data datasets;benchmark datasets;classification performance improvement;synthetic minority over-sampling technique;Support vector machines;Kernel;Merging;Standards;Sociology;Statistics;Interpolation}, </span>
<span class="sd">                            doi={10.1109/IJCNN.2013.6707035}, </span>
<span class="sd">                            ISSN={2161-4407}, </span>
<span class="sd">                            month={Aug}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Absolute value of the angles extracted should be taken. (implemented this way)</span>
<span class="sd">        * It is not specified how many samples are generated in the various clusters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="Assembled_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Assembled_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">pop</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">thres</span><span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in nearest neighbors component</span>
<span class="sd">            pop (int): lower threshold on cluster sizes</span>
<span class="sd">            thres (float): threshold on angles</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">pop</span><span class="p">,</span> <span class="s2">&quot;pop&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">thres</span><span class="p">,</span> <span class="s2">&quot;thres&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="o">=</span> <span class="n">pop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">thres</span><span class="o">=</span> <span class="n">thres</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Assembled_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Assembled_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;pop&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> 
                                                    <span class="s1">&#39;thres&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="Assembled_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Assembled_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model</span>
        <span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># finding the set of border and non-border minority elements</span>
        <span class="n">border_mask</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_neighbors</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">))])</span>
        <span class="n">X_border</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">border_mask</span><span class="p">]</span>
        <span class="n">X_non_border</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">border_mask</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_border</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;X_border is empty&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># initializing clustering</span>
        <span class="n">clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_border</span><span class="p">))]</span>
        <span class="n">dm</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_border</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)):</span>
            <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>

        <span class="c1"># do the clustering </span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
            <span class="c1"># extracting coordinates of clusters with the minimum distance</span>
            <span class="n">min_coord</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dm</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dm</span><span class="p">))</span>
            <span class="n">merge_a</span><span class="o">=</span> <span class="n">min_coord</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">merge_b</span><span class="o">=</span> <span class="n">min_coord</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># checking the size of clusters to see if they should be merged</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">merge_a</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">[</span><span class="n">merge_b</span><span class="p">])</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">:</span>
                <span class="c1"># if both clusters are small, do the merge</span>
                <span class="n">clusters</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">clusters</span><span class="p">[</span><span class="n">merge_a</span><span class="p">],</span> <span class="n">clusters</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]])</span>
                <span class="k">del</span> <span class="n">clusters</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]</span>
                <span class="c1"># update the distance matrix accordingly</span>
                <span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">],</span> <span class="n">dm</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">dm</span><span class="p">[:,</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span>
                <span class="c1"># remove columns</span>
                <span class="n">dm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">merge_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">dm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">merge_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                <span class="c1"># fix the diagonal entries</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)):</span>
                    <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># otherwise find principal directions</span>
                <span class="n">pca_a</span><span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_border</span><span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]])</span>
                <span class="n">pca_b</span><span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_border</span><span class="p">[</span><span class="n">clusters</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]])</span>
                <span class="c1"># extract the angle of principal directions</span>
                <span class="n">angle</span><span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">pca_a</span><span class="o">.</span><span class="n">components_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pca_b</span><span class="o">.</span><span class="n">components_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pca_a</span><span class="o">.</span><span class="n">components_</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">pca_b</span><span class="o">.</span><span class="n">components_</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
                <span class="c1"># check if angle if angle is above a specific threshold</span>
                <span class="k">if</span> <span class="n">angle</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">thres</span><span class="p">:</span>
                    <span class="c1"># do the merge</span>
                    <span class="n">clusters</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">clusters</span><span class="p">[</span><span class="n">merge_a</span><span class="p">],</span> <span class="n">clusters</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]])</span>
                    <span class="k">del</span> <span class="n">clusters</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]</span>
                    <span class="c1"># update the distance matrix acoordingly</span>
                    <span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">],</span> <span class="n">dm</span><span class="p">[</span><span class="n">merge_b</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">dm</span><span class="p">[:,</span><span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">]</span>
                    <span class="c1"># remove columns </span>
                    <span class="n">dm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">merge_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="n">dm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">merge_b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="c1"># fixing the digaonal entries</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm</span><span class="p">)):</span>
                        <span class="n">dm</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># changing the distance of clusters to fininte</span>
                    <span class="n">dm</span><span class="p">[</span><span class="n">merge_a</span><span class="p">,</span> <span class="n">merge_b</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                    <span class="n">dm</span><span class="p">[</span><span class="n">merge_b</span><span class="p">,</span> <span class="n">merge_a</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
        <span class="c1"># extract vectors belonging to the various clusters</span>
        <span class="n">vectors</span><span class="o">=</span> <span class="p">[</span><span class="n">X_border</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="c1"># adding non-border samples</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_non_border</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_non_border</span><span class="p">)</span>
        
        <span class="c1"># extract cluster sizes and calculating point distribution in clusters</span>
        <span class="c1"># the last element of the clusters is the set of non-border xamples</span>
        <span class="n">cluster_sizes</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vectors</span><span class="p">])</span>
        <span class="n">densities</span><span class="o">=</span> <span class="n">cluster_sizes</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cluster_sizes</span><span class="p">)</span>
        
        <span class="c1"># extracting nearest neighbors in clusters</span>
        <span class="n">nns</span><span class="o">=</span> <span class="p">[</span><span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="n">i</span><span class="p">])]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">))]</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">cluster_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">),</span> <span class="n">p</span><span class="o">=</span> <span class="n">densities</span><span class="p">)</span>
            <span class="n">sample_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">random_neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">nns</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">random_neighbor_idx</span><span class="o">=</span> <span class="n">sample_idx</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">vectors</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">],</span> <span class="n">vectors</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">][</span><span class="n">random_neighbor_idx</span><span class="p">]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="Assembled_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Assembled_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;pop&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pop</span><span class="p">,</span> 
                <span class="s1">&#39;thres&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">thres</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SDSMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SDSMOTE">[docs]</a><span class="k">class</span> <span class="nc">SDSMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{sdsmote, </span>
<span class="sd">                            author={Li, K. and Zhang, W. and Lu, Q. and Fang, X.}, </span>
<span class="sd">                            booktitle={2014 International Conference on Identification, Information and Knowledge in the Internet of Things}, </span>
<span class="sd">                            title={An Improved SMOTE Imbalanced Data Classification Method Based on Support Degree}, </span>
<span class="sd">                            year={2014}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={34-38}, </span>
<span class="sd">                            keywords={data mining;pattern classification;sampling methods;improved SMOTE imbalanced data classification method;support degree;data mining;class distribution;imbalanced data-set classification;over sampling method;minority class sample generation;minority class sample selection;minority class boundary sample identification;Classification algorithms;Training;Bagging;Computers;Testing;Algorithm design and analysis;Data mining;Imbalanced data-sets;Classification;Boundary sample;Support degree;SMOTE}, </span>
<span class="sd">                            doi={10.1109/IIKI.2014.14}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={Oct}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_borderline</span><span class="p">]</span>
    
<div class="viewcode-block" id="SDSMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SDSMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in nearest neighbors component</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SDSMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SDSMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SDSMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SDSMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model to find closest majority points to minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># calculating the sum according to S3 in the paper</span>
        <span class="n">S_i</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># calculating average distance according to S5</span>
        <span class="n">S</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">S_i</span><span class="p">)</span>
        <span class="n">S_ave</span><span class="o">=</span> <span class="n">S</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">))</span>
        
        <span class="c1"># calculate support degree</span>
        <span class="n">k</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">S_ave</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span> <span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span>
        <span class="n">density</span><span class="o">=</span> <span class="n">k</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        
        <span class="c1"># fitting nearest neighbors model to minority samples to run SMOTE-like sampling</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">density</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">density</span><span class="p">)</span>
            <span class="n">random_neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_neighbor_idx</span><span class="p">]))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="SDSMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SDSMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="DSMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DSMOTE">[docs]</a><span class="k">class</span> <span class="nc">DSMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{dsmote, </span>
<span class="sd">                            author={Mahmoudi, S. and Moradi, P. and Akhlaghian, F. and Moradi, R.}, </span>
<span class="sd">                            booktitle={2014 4th International Conference on Computer and Knowledge Engineering (ICCKE)}, </span>
<span class="sd">                            title={Diversity and separable metrics in over-sampling technique for imbalanced data classification}, </span>
<span class="sd">                            year={2014}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={152-158}, </span>
<span class="sd">                            keywords={learning (artificial intelligence);pattern classification;sampling methods;diversity metric;separable metric;over-sampling technique;imbalanced data classification;class distribution techniques;under-sampling technique;DSMOTE method;imbalanced learning problem;diversity measure;separable measure;Iran University of Medical Science;UCI dataset;Accuracy;Classification algorithms;Vectors;Educational institutions;Euclidean distance;Data mining;Diversity measure;Separable Measure;Over-Sampling;Imbalanced Data;Classification problems}, </span>
<span class="sd">                            doi={10.1109/ICCKE.2014.6993409}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={Oct}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * The method is highly inefficient when the number of minority samples is high, time complexity is O(n^3), with 1000 minority samples it takes about 1e9 objective function evaluations to find 1 new sample points. Adding 1000 samples would take about 1e12 evaluations of the objective function, which is unfeasible. We introduce a new parameter, n_step, and during the search for the new sample at most n_step combinations of minority samples are tried.</span>
<span class="sd">        * Abnormality of minority points is defined in the paper as D_maj/D_min, high abnormality  means that the minority point is close to other minority points and very far from majority points. This is definitely not abnormality, I have implemented the opposite. </span>
<span class="sd">        * Nothing ensures that the fisher statistics and the variance from the geometric mean remain comparable, which might skew the optimization towards one of the sub-objectives.</span>
<span class="sd">        * MinMax normalization doesn&#39;t work, each attribute will have a 0 value, which will make the geometric mean of all attribute 0.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">]</span>
    
<div class="viewcode-block" id="DSMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DSMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">n_step</span><span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in nearest neighbors component</span>
<span class="sd">            rate (float): [0,1] rate of minority samples to turn into majority</span>
<span class="sd">            n_step (int): number of random configurations to check for new samples</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">rate</span><span class="p">,</span> <span class="s2">&quot;rate&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_step</span><span class="p">,</span> <span class="s2">&quot;n_step&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="o">=</span> <span class="n">rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="o">=</span> <span class="n">n_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="DSMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DSMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;rate&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_step&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">50</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="DSMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DSMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">mms</span><span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="n">X</span><span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">))</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># compute mean distances, the D_min is compenstaed for taking into consideration self-distances in the mean</span>
        <span class="n">D_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">D_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c1"># computing degree of abnormality</span>
        <span class="n">abnormality</span><span class="o">=</span> <span class="n">D_min</span><span class="o">/</span><span class="n">D_maj</span>
        
        <span class="c1"># sorting minority indices in decreasing order by abnormality</span>
        <span class="n">abnormality</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">abnormality</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">abnormality</span><span class="p">))),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">rate</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">abnormality</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="n">rate</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># moving the most abnormal points to the majority class</span>
            <span class="n">X_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_min</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">indices</span><span class="p">[:</span><span class="n">rate</span><span class="p">])]])</span>
            <span class="c1"># removing the most abnormal points form the minority class</span>
            <span class="n">X_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">indices</span><span class="p">[:</span><span class="n">rate</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># computing the mean and variance of points in the majority class</span>
        <span class="n">var_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">mean_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        
        <span class="c1"># this is the original objective function, however, using this</span>
        <span class="c1"># is very inefficient if the number of records increases above</span>
        <span class="c1"># approximately 1000</span>
        <span class="c1">#def objective(X):</span>
        <span class="c1">#    &quot;&quot;&quot;</span>
        <span class="c1">#    The objective function to be maximized</span>
        <span class="c1">#    </span>
        <span class="c1">#    Args:</span>
        <span class="c1">#        X (np.matrix): dataset</span>
        <span class="c1">#        </span>
        <span class="c1">#    Returns:</span>
        <span class="c1">#        float: the value of the objective function</span>
        <span class="c1">#    &quot;&quot;&quot;</span>
        <span class="c1">#    gm= gmean(X, axis= 0)</span>
        <span class="c1">#    gdiv= np.mean(np.linalg.norm(X - gm, axis= 1))</span>
        <span class="c1">#    fisher= (np.mean(X) - mean_maj)**2/(np.mean(np.var(X, axis= 0)) + var_maj)</span>
        <span class="c1">#    return gdiv + fisher</span>
        
        <span class="c1"># in order to make the code more efficient, we do maintain some variables</span>
        <span class="c1"># containing the main componentes of the objective function and apply</span>
        <span class="c1"># only small corrections based on the new values being added</span>
        <span class="c1"># the effect should be identical</span>
        
        <span class="c1"># records the sum of logarithms in X_min, used to compute the geometric mean</span>
        <span class="n">min_log_sum</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># contains the sum of values in X_min, coordinatewise</span>
        <span class="n">min_sum</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># contains the squares of sums of values in X_min, coordinatewise</span>
        <span class="n">min_sum2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X_min</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># contains the sum of all numbers in X_min</span>
        <span class="n">min_all_sum</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="n">min_norm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">n_added</span><span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">n_added</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">best_candidate</span><span class="o">=</span> <span class="kc">None</span>
            <span class="n">highest_score</span><span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># we try n_step combinations of minority samples</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">])):</span>
                <span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="mi">3</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
                <span class="n">gm</span><span class="o">=</span> <span class="n">gmean</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">])],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                
                <span class="c1"># computing the new objective function for the new point (gm) added</span>
                <span class="n">new_X_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_min</span><span class="p">,</span> <span class="n">gm</span><span class="p">])</span>
                
                <span class="c1"># updating the components of the objective function</span>
                <span class="n">new_min_log_sum</span><span class="o">=</span> <span class="n">min_log_sum</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">gm</span><span class="p">)</span>
                <span class="n">new_min_sum</span><span class="o">=</span> <span class="n">min_sum</span> <span class="o">+</span> <span class="n">gm</span>
                <span class="n">new_min_sum2</span><span class="o">=</span> <span class="n">min_sum2</span> <span class="o">+</span> <span class="n">gm</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">new_min_all_sum</span><span class="o">=</span> <span class="n">min_all_sum</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gm</span><span class="p">)</span>
                
                <span class="c1"># computing mean, var, gmean and mean of all elements with the new</span>
                <span class="c1"># sample (gm) </span>
                <span class="n">new_min_mean</span><span class="o">=</span> <span class="n">new_min_sum</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_X_min</span><span class="p">))</span>
                <span class="n">new_min_var</span><span class="o">=</span> <span class="n">new_min_sum2</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_X_min</span><span class="p">))</span> <span class="o">-</span> <span class="n">new_min_mean</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">new_min_gmean</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">new_min_log_sum</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_X_min</span><span class="p">)))</span>
                <span class="n">new_min_all_mean</span><span class="o">=</span> <span class="n">new_min_all_sum</span><span class="o">/</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">new_X_min</span><span class="p">))</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">new_min_norm</span><span class="o">=</span> <span class="n">min_norm</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">gm</span><span class="p">)</span>
                
                <span class="c1"># computing the new objective function value</span>
                <span class="n">inner_prod</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">new_X_min</span><span class="p">,</span> <span class="n">new_min_gmean</span><span class="p">)</span>
                <span class="n">gmean_norm</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">new_min_gmean</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="n">new_gdiv</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">new_min_norm</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">inner_prod</span> <span class="o">+</span> <span class="n">gmean_norm</span><span class="p">))</span>
                <span class="c1">#new_gdiv= np.mean(np.linalg.norm(new_X_min - new_min_gmean, axis= 1))</span>
                <span class="n">new_fisher</span><span class="o">=</span> <span class="p">(</span><span class="n">new_min_all_mean</span> <span class="o">-</span> <span class="n">mean_maj</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">new_min_var</span><span class="p">)</span> <span class="o">+</span> <span class="n">var_maj</span><span class="p">)</span>
                <span class="n">score</span><span class="o">=</span> <span class="n">new_gdiv</span> <span class="o">+</span> <span class="n">new_fisher</span>
                
                <span class="c1"># evaluate the objective function</span>
                <span class="c1">#score= objective(np.vstack([X_min, gm]))</span>
                <span class="c1"># check if the score is better than the best so far</span>
                <span class="k">if</span> <span class="n">score</span> <span class="o">&gt;</span> <span class="n">highest_score</span><span class="p">:</span>
                    <span class="n">highest_score</span><span class="o">=</span> <span class="n">score</span>
                    <span class="n">best_candidate</span><span class="o">=</span> <span class="n">gm</span>
                    <span class="n">cand_min_log_sum</span><span class="o">=</span> <span class="n">new_min_log_sum</span>
                    <span class="n">cand_min_sum</span><span class="o">=</span> <span class="n">new_min_sum</span>
                    <span class="n">cand_min_sum2</span><span class="o">=</span> <span class="n">new_min_sum2</span>
                    <span class="n">cand_min_all_sum</span><span class="o">=</span> <span class="n">new_min_all_sum</span>
                    <span class="n">cand_min_norm</span><span class="o">=</span> <span class="n">new_min_norm</span>
                    
            <span class="c1"># add the best candidate to the minority samples</span>
            <span class="n">X_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_min</span><span class="p">,</span> <span class="n">best_candidate</span><span class="p">])</span>
            <span class="n">n_added</span><span class="o">=</span> <span class="n">n_added</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="n">min_log_sum</span><span class="o">=</span> <span class="n">cand_min_log_sum</span>
            <span class="n">min_sum</span><span class="o">=</span> <span class="n">cand_min_sum</span>
            <span class="n">min_sum2</span><span class="o">=</span> <span class="n">cand_min_sum2</span>
            <span class="n">min_all_sum</span><span class="o">=</span> <span class="n">cand_min_all_sum</span>
            <span class="n">min_norm</span><span class="o">=</span> <span class="n">cand_min_norm</span>
        
        <span class="k">return</span> <span class="n">mms</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_min</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="DSMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DSMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;rate&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span><span class="p">,</span> 
                <span class="s1">&#39;n_step&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_step</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="G_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.G_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">G_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{g_smote, </span>
<span class="sd">                            author={Sandhan, T. and Choi, J. Y.}, </span>
<span class="sd">                            booktitle={2014 22nd International Conference on Pattern Recognition}, </span>
<span class="sd">                            title={Handling Imbalanced Datasets by Partially Guided Hybrid Sampling for Pattern Recognition}, </span>
<span class="sd">                            year={2014}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={1449-1453}, </span>
<span class="sd">                            keywords={Gaussian processes;learning (artificial intelligence);pattern classification;regression analysis;sampling methods;support vector machines;imbalanced datasets;partially guided hybrid sampling;pattern recognition;real-world domains;skewed datasets;dataset rebalancing;learning algorithm;extremely low minority class samples;classification tasks;extracted hidden patterns;support vector machine;logistic regression;nearest neighbor;Gaussian process classifier;Support vector machines;Proteins;Pattern recognition;Kernel;Databases;Gaussian processes;Vectors;Imbalanced dataset;protein classification;ensemble classifier;bootstrapping;Sat-image classification;medical diagnoses}, </span>
<span class="sd">                            doi={10.1109/ICPR.2014.258}, </span>
<span class="sd">                            ISSN={1051-4651}, </span>
<span class="sd">                            month={Aug}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * the non-linear approach is inefficient </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_componentwise</span><span class="p">]</span>
    
<div class="viewcode-block" id="G_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.G_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in nearest neighbors component</span>
<span class="sd">            method (str): &#39;linear&#39;/&#39;non-linear_2.0&#39; - the float can be any number: standard deviation in the Gaussian-kernel</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;non-linear&#39;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s1">&#39;Method parameter </span><span class="si">%s</span><span class="s1"> is not supported&#39;</span> <span class="o">%</span> <span class="n">method</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;non-linear&#39;</span><span class="p">):</span>
            <span class="n">parameter</span><span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">parameter</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Non-positive non-linear parameter </span><span class="si">%f</span><span class="s2"> is not supported&quot;</span> <span class="o">%</span> <span class="n">parameter</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="G_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.G_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="s1">&#39;non-linear_0.1&#39;</span><span class="p">,</span> <span class="s1">&#39;non-linear_1.0&#39;</span><span class="p">,</span> <span class="s1">&#39;non-linear_2.0&#39;</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="G_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.G_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
            <span class="c1"># finding H_l by linear decomposition</span>
            <span class="n">cov</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cov</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">w</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">cov</span><span class="p">)</span>
            <span class="n">H_l</span><span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">w</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># building a non-linear kernel matrix and finding H_n by its decomposition</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">kernel_matrix</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
            <span class="n">kernel_matrix</span><span class="o">=</span> <span class="n">kernel_matrix</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">kernel_matrix</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">w_k</span><span class="p">,</span> <span class="n">v_k</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">kernel_matrix</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">H_n</span><span class="o">=</span> <span class="n">v_k</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">w_k</span><span class="p">)]</span>
            <span class="k">def</span> <span class="nf">kernel</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="c1"># calculating difference vectors from all neighbors</span>
            <span class="n">P</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;linear&#39;</span><span class="p">:</span>
                <span class="c1"># calculating angles with the principal direction</span>
                <span class="n">thetas</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">H_l</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">H_l</span><span class="p">)))</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">))])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">thetas</span><span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># calculating angles of the difference vectors and the principal direction in feature space</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">)):</span>
                    <span class="c1"># calculating representation in feature space</span>
                    <span class="n">feature_vector</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">kernel</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">P</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span>
                    <span class="n">dp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">H_n</span><span class="p">,</span> <span class="n">feature_vector</span><span class="p">)</span>
                    <span class="n">thetas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dp</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">feature_vector</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">H_n</span><span class="p">))))</span>
                <span class="n">thetas</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">thetas</span><span class="p">)</span>
            
            <span class="c1"># using the neighbor with the difference along the most similar direction to the principal direction of the data</span>
            <span class="n">n</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">thetas</span><span class="p">)</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points_componentwise</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:][</span><span class="n">n</span><span class="p">]]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="G_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.G_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="NT_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NT_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">NT_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{nt_smote, </span>
<span class="sd">                            author={Xu, Y. H. and Li, H. and Le, L. P. and Tian, X. Y.}, </span>
<span class="sd">                            booktitle={2014 Seventh International Joint Conference on Computational Sciences and Optimization}, </span>
<span class="sd">                            title={Neighborhood Triangular Synthetic Minority Over-sampling Technique for Imbalanced Prediction on Small Samples of Chinese Tourism and Hospitality Firms}, </span>
<span class="sd">                            year={2014}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={534-538}, </span>
<span class="sd">                            keywords={financial management;pattern classification;risk management;sampling methods;travel industry;Chinese tourism;hospitality firms;imbalanced risk prediction;minority class samples;up-sampling approach;neighborhood triangular synthetic minority over-sampling technique;NT-SMOTE;nearest neighbor idea;triangular area sampling idea;single classifiers;data excavation principles;hospitality industry;missing financial indicators;financial data filtering;financial risk prediction;MDA;DT;LSVM;logit;probit;firm risk prediction;Joints;Optimization;imbalanced datasets;NT-SMOTE;neighborhood triangular;random sampling}, </span>
<span class="sd">                            doi={10.1109/CSO.2014.104}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={July}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_application</span><span class="p">]</span>
    
<div class="viewcode-block" id="NT_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NT_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="NT_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NT_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="NT_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NT_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># find two nearest minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
                
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="c1"># select point randomly</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">P_1</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="c1"># find two closest neighbors</span>
            <span class="n">P_2</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">P_3</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
            <span class="c1"># generate random point by sampling the specified triangle</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">P_3</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="p">((</span><span class="n">P_1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">P_2</span> <span class="o">-</span> <span class="n">P_1</span><span class="p">))</span> <span class="o">-</span> <span class="n">P_3</span><span class="p">)))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="NT_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NT_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="Lee"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Lee">[docs]</a><span class="k">class</span> <span class="nc">Lee</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @inproceedings{lee,</span>
<span class="sd">                             author = {Lee, Jaedong and Kim, Noo-ri and Lee, Jee-Hyong},</span>
<span class="sd">                             title = {An Over-sampling Technique with Rejection for Imbalanced Class Learning},</span>
<span class="sd">                             booktitle = {Proceedings of the 9th International Conference on Ubiquitous Information Management and Communication},</span>
<span class="sd">                             series = {IMCOM &#39;15},</span>
<span class="sd">                             year = {2015},</span>
<span class="sd">                             isbn = {978-1-4503-3377-1},</span>
<span class="sd">                             location = {Bali, Indonesia},</span>
<span class="sd">                             pages = {102:1--102:6},</span>
<span class="sd">                             articleno = {102},</span>
<span class="sd">                             numpages = {6},</span>
<span class="sd">                             url = {http://doi.acm.org/10.1145/2701126.2701181},</span>
<span class="sd">                             doi = {10.1145/2701126.2701181},</span>
<span class="sd">                             acmid = {2701181},</span>
<span class="sd">                             publisher = {ACM},</span>
<span class="sd">                             address = {New York, NY, USA},</span>
<span class="sd">                             keywords = {data distribution, data preprocessing, imbalanced problem, rejection rule, synthetic minority oversampling technique}</span>
<span class="sd">                            } </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="Lee.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Lee.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">rejection_level</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in nearest neighbor component</span>
<span class="sd">            rejection_level (float): the rejection level of generated samples, if the</span>
<span class="sd">                                        fraction of majority labels in the local environment</span>
<span class="sd">                                        is higher than this number, the generated point</span>
<span class="sd">                                        is rejected</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">rejection_level</span><span class="p">,</span> <span class="s2">&quot;rejection_level&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rejection_level</span><span class="o">=</span> <span class="n">rejection_level</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Lee.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Lee.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;rejection_level&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="Lee.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Lee.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors models to find neighbors of minority samples in the total data</span>
        <span class="c1"># and in the minority datasets</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="n">nn_min</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn_min</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist_min</span><span class="p">,</span> <span class="n">ind_min</span><span class="o">=</span> <span class="n">nn_min</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># do the sampling, we impleneted a continouos tweaking of rejection levels</span>
        <span class="c1"># in order to fix situations when no unrejectable data can be can be generated</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">passed</span><span class="o">=</span> <span class="mi">0</span>
        <span class="n">trial</span><span class="o">=</span> <span class="mi">0</span>
        <span class="n">rejection_level</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rejection_level</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="c1"># checking if we managed to generate a single data in 1000 trials</span>
            <span class="k">if</span> <span class="n">passed</span> <span class="o">==</span> <span class="n">trial</span> <span class="ow">and</span> <span class="n">passed</span> <span class="o">&gt;</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">rejection_level</span><span class="o">=</span> <span class="n">rejection_level</span> <span class="o">+</span> <span class="mf">0.1</span>
                <span class="n">trial</span><span class="o">=</span> <span class="mi">0</span>
                <span class="n">passed</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">trial</span><span class="o">=</span> <span class="n">trial</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># generating random point</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">random_neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind_min</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">random_point</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_neighbor_idx</span><span class="p">])</span>
            <span class="c1"># checking if the local environment is above the rejection level</span>
            <span class="n">dist_new</span><span class="p">,</span> <span class="n">ind_new</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">random_point</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind_new</span><span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">&lt;</span> <span class="n">rejection_level</span><span class="p">:</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">random_point</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">passed</span><span class="o">=</span> <span class="n">passed</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="Lee.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Lee.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;rejection_level&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">rejection_level</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SPY"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SPY">[docs]</a><span class="k">class</span> <span class="nc">SPY</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{spy, </span>
<span class="sd">                            author={Dang, X. T. and Tran, D. H. and Hirose, O. and Satou, K.}, </span>
<span class="sd">                            booktitle={2015 Seventh International Conference on Knowledge and Systems Engineering (KSE)}, </span>
<span class="sd">                            title={SPY: A Novel Resampling Method for Improving Classification Performance in Imbalanced Data}, </span>
<span class="sd">                            year={2015}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={280-285}, </span>
<span class="sd">                            keywords={decision making;learning (artificial intelligence);pattern classification;sampling methods;SPY;resampling method;decision-making process;biomedical data classification;class imbalance learning method;SMOTE;oversampling method;UCI machine learning repository;G-mean value;borderline-SMOTE;safe-level-SMOTE;Support vector machines;Training;Bioinformatics;Proteins;Protein engineering;Radio frequency;Sensitivity;Imbalanced dataset;Over-sampling;Under-sampling;SMOTE;borderline-SMOTE}, </span>
<span class="sd">                            doi={10.1109/KSE.2015.24}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={Oct}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">]</span>
    
<div class="viewcode-block" id="SPY.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SPY.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">threshold</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_neighbors (int): number of neighbors in nearest neighbor component</span>
<span class="sd">            threshold (float): threshold*n_neighbors gives the threshold z described in the paper</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">threshold</span><span class="p">,</span> <span class="s2">&quot;threshold&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="o">=</span> <span class="n">threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="c1"># random state takes no effect for this technique</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SPY.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SPY.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SPY.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SPY.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model</span>
        <span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="n">y_new</span><span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">z</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="o">*</span><span class="n">n_neighbors</span>
        
        <span class="c1"># checking the neighbors of each minority sample</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)):</span>
            <span class="n">majority_mask</span><span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span>
            <span class="n">x</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">majority_mask</span><span class="p">)</span>
            <span class="c1"># if the number of majority samples in the neighborhood is smaller than a threshold</span>
            <span class="c1"># their labels are changed to minority</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">z</span><span class="p">:</span>
                <span class="n">y_new</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:][</span><span class="n">majority_mask</span><span class="p">]]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span>
        
        <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y_new</span></div>
        
<div class="viewcode-block" id="SPY.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SPY.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;threshold&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">threshold</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SMOTE_PSOBAT"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_PSOBAT">[docs]</a><span class="k">class</span> <span class="nc">SMOTE_PSOBAT</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{smote_psobat, </span>
<span class="sd">                            author={Li, J. and Fong, S. and Zhuang, Y.}, </span>
<span class="sd">                            booktitle={2015 3rd International Symposium on Computational and Business Intelligence (ISCBI)}, </span>
<span class="sd">                            title={Optimizing SMOTE by Metaheuristics with Neural Network and Decision Tree}, </span>
<span class="sd">                            year={2015}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={26-32}, </span>
<span class="sd">                            keywords={data mining;particle swarm optimisation;pattern classification;data mining;classifier;metaherustics;SMOTE parameters;performance indicators;selection optimization;PSO;particle swarm optimization algorithm;BAT;bat-inspired algorithm;metaheuristic optimization algorithms;nearest neighbors;imbalanced dataset problem;synthetic minority over-sampling technique;decision tree;neural network;Classification algorithms;Neural networks;Decision trees;Training;Optimization;Particle swarm optimization;Data mining;SMOTE;Swarm Intelligence;parameter selection optimization}, </span>
<span class="sd">                            doi={10.1109/ISCBI.2015.12}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={Dec}}</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * The parameters of the memetic algorithms are not specified.</span>
<span class="sd">        * I have checked multiple paper describing the BAT algorithm, but the meaning of &quot;Generate a new solution by flying randomly&quot; is still unclear. </span>
<span class="sd">        * It is also unclear if best solutions are recorded for each bat, or the entire population.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_memetic</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE_PSOBAT.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_PSOBAT.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxit</span><span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">c1</span><span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">c2</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">c3</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span> <span class="mf">0.9</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span> <span class="s1">&#39;bat&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            maxit (int): maximum number of iterations</span>
<span class="sd">            c1 (float): intertia weight of PSO</span>
<span class="sd">            c2 (float): attraction of local maximums in PSO</span>
<span class="sd">            c3 (float): attraction of global maximum in PSO</span>
<span class="sd">            alpha (float): alpha parameter of the method</span>
<span class="sd">            gamma (float): gamma parameter of the method</span>
<span class="sd">            method (str): optimization technique to be used</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">maxit</span><span class="p">,</span> <span class="s2">&quot;maxit&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">c1</span><span class="p">,</span> <span class="s2">&quot;c1&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">c2</span><span class="p">,</span> <span class="s2">&quot;c2&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">c3</span><span class="p">,</span> <span class="s2">&quot;c3&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">gamma</span><span class="p">,</span> <span class="s2">&quot;gamma&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_isin</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;pso&#39;</span><span class="p">,</span> <span class="s1">&#39;bat&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">maxit</span><span class="o">=</span> <span class="n">maxit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="o">=</span> <span class="n">c1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="o">=</span> <span class="n">c2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c3</span><span class="o">=</span> <span class="n">c3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="o">=</span> <span class="n">gamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="o">=</span> <span class="n">method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMOTE_PSOBAT.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_PSOBAT.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">bat_pc</span><span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;maxit&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">50</span><span class="p">],</span> 
                                                     <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> 
                                                     <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> 
                                                     <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;bat&#39;</span><span class="p">]})</span>
        <span class="n">pso_pc</span><span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;maxit&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">50</span><span class="p">],</span> 
                                                     <span class="s1">&#39;c1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> 
                                                     <span class="s1">&#39;c2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> 
                                                     <span class="s1">&#39;c3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> 
                                                     <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;pso&#39;</span><span class="p">]})</span>
        <span class="n">bat_pc</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">pso_pc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bat_pc</span></div>
    
<div class="viewcode-block" id="SMOTE_PSOBAT.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_PSOBAT.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="n">proportion</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Evaluate given configuration</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                K (int): number of neighbors in nearest neighbors component</span>
<span class="sd">                proportion (float): proportion of missing data to generate</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float, float: kappa and accuracy scores</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="n">K</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            
            <span class="c1"># doing k-fold cross validation</span>
            <span class="n">kfold</span><span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
            <span class="n">preds</span><span class="o">=</span> <span class="p">[]</span>
            <span class="n">tests</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">kfold</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X_samp</span><span class="p">):</span>
                <span class="n">preds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_samp</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">y_samp</span><span class="p">[</span><span class="n">train</span><span class="p">])</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_samp</span><span class="p">[</span><span class="n">test</span><span class="p">]))</span>
                <span class="n">tests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_samp</span><span class="p">[</span><span class="n">test</span><span class="p">])</span>
            <span class="n">preds</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
            <span class="n">tests</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
            <span class="c1"># computing the kappa score</span>
            <span class="n">tp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">preds</span> <span class="o">==</span> <span class="n">tests</span><span class="p">,</span> <span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">))</span>
            <span class="n">fn</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">preds</span> <span class="o">!=</span> <span class="n">tests</span><span class="p">,</span> <span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">))</span>
            <span class="n">tn</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">preds</span> <span class="o">==</span> <span class="n">tests</span><span class="p">,</span> <span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">))</span>
            <span class="n">fp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">preds</span> <span class="o">!=</span> <span class="n">tests</span><span class="p">,</span> <span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">))</span>
            
            <span class="n">p_o</span><span class="o">=</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">tn</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span> <span class="o">+</span> <span class="n">tn</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span>
            <span class="n">p_e</span><span class="o">=</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span> <span class="o">+</span> <span class="n">tn</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">fp</span> <span class="o">+</span> <span class="n">tn</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">fn</span> <span class="o">+</span> <span class="n">tn</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span> <span class="o">+</span> <span class="n">tn</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            
            <span class="n">kappa</span><span class="o">=</span> <span class="p">(</span><span class="n">p_o</span> <span class="o">-</span> <span class="n">p_e</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p_e</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">p_o</span>
        
        <span class="k">def</span> <span class="nf">PSO</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            PSO optimization</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                int, float: the best K and proportion values</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># a reasonable range of nearest neighbors to use with SMOTE</span>
            <span class="n">k_range</span><span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="nb">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">),</span> <span class="mi">10</span><span class="p">])]</span>
            <span class="c1"># a reasonable range of proportions</span>
            <span class="n">proportion_range</span><span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>
            <span class="c1"># population size</span>
            <span class="n">n_pop</span><span class="o">=</span> <span class="mi">10</span>
            
            <span class="c1"># initial particles</span>
            <span class="n">ps</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">proportion_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">proportion_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">proportion_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="c1"># initial velocities</span>
            <span class="n">velocities</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="c1"># best configurations of particles</span>
            <span class="n">local_best</span><span class="o">=</span> <span class="p">[</span><span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="c1"># scores of best configurations of particles</span>
            <span class="n">local_scores</span><span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="c1"># global best configuration of particles</span>
            <span class="n">global_best</span><span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># global best score</span>
            <span class="n">global_scores</span><span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            
            <span class="c1"># executing the particle swarm optimization</span>
            <span class="n">not_changed</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxit</span><span class="p">):</span>
                <span class="c1"># if the configurations didn&#39;t change for 10 iterations, stop</span>
                <span class="k">if</span> <span class="n">not_changed</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)</span><span class="o">*</span><span class="mi">10</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="c1"># evaluating each of the configurations</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)):</span>
                    <span class="n">scores</span><span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="c1"># recording if the best scores didn&#39;t change</span>
                    <span class="n">not_changed</span><span class="o">=</span> <span class="n">not_changed</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="c1"># registering locally and globally best scores</span>
                    <span class="k">if</span> <span class="nb">min</span><span class="p">([</span><span class="n">local_scores</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mf">0.4</span> <span class="ow">and</span> <span class="n">local_scores</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">scores</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">local_scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">scores</span>
                        <span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">not_changed</span><span class="o">=</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.4</span> <span class="ow">and</span> <span class="n">local_scores</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="p">:</span>
                        <span class="n">local_scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">scores</span>
                        <span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">not_changed</span><span class="o">=</span> <span class="mi">0</span>
                    
                    <span class="k">if</span> <span class="nb">min</span><span class="p">([</span><span class="n">global_scores</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mf">0.4</span> <span class="ow">and</span> <span class="n">global_scores</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">scores</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">global_scores</span><span class="o">=</span> <span class="n">scores</span>
                        <span class="n">global_best</span><span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">not_changed</span><span class="o">=</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.4</span> <span class="ow">and</span> <span class="n">global_scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="p">:</span>
                        <span class="n">global_scores</span><span class="o">=</span> <span class="n">scores</span>
                        <span class="n">global_best</span><span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">not_changed</span><span class="o">=</span> <span class="mi">0</span>
    
                <span class="c1"># update velocities</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)):</span>
                    <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="o">*</span><span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">c2</span> <span class="o">+</span> <span class="p">(</span><span class="n">global_best</span> <span class="o">-</span> <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">c3</span>
                    <span class="c1"># clipping velocities if required</span>
                    <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">k_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
                    <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">proportion_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">proportion_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.0</span>
                    
                <span class="c1"># update positions</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ps</span><span class="p">)):</span>
                    <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># clipping positions according to the specified ranges</span>
                    <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">ps</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">proportion_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">proportion_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                
            <span class="k">return</span> <span class="n">global_best</span>
        
        <span class="k">def</span> <span class="nf">BAT</span><span class="p">():</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            BAT optimization</span>
<span class="sd">            </span>
<span class="sd">            Returns:</span>
<span class="sd">                int, float: the best K and proportion values</span>
<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="c1"># a reasonable range of nearest neighbors to use with SMOTE</span>
            <span class="n">k_range</span><span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">),</span> <span class="mi">10</span><span class="p">])]</span>
            <span class="c1"># a reasonable range of proportions</span>
            <span class="n">proportion_range</span><span class="o">=</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]</span>
            <span class="c1"># population size</span>
            <span class="n">n_pop</span><span class="o">=</span> <span class="mi">10</span>
            <span class="c1"># maximum frequency</span>
            <span class="n">f_max</span><span class="o">=</span> <span class="mi">10</span>
            
            <span class="c1"># initial bat positions</span>
            <span class="n">bats</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">proportion_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">proportion_range</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="n">proportion_range</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="c1"># initial velocities</span>
            <span class="n">velocities</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
            <span class="c1"># best configurations of particles</span>
            <span class="n">local_best</span><span class="o">=</span> <span class="p">[[[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()]]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bats</span><span class="p">))]</span>
            <span class="c1"># scores of best configurations of particles</span>
            <span class="n">global_best</span><span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">],</span> <span class="n">bats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>
            <span class="c1"># pulse frequencies</span>
            <span class="n">f</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span> <span class="n">n_pop</span><span class="p">)</span><span class="o">*</span><span class="n">f_max</span>
            <span class="c1"># pulse rates</span>
            <span class="n">r</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span> <span class="n">n_pop</span><span class="p">)</span>
            <span class="c1"># loudness</span>
            <span class="n">A</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span> <span class="n">n_pop</span><span class="p">)</span>
            
            <span class="c1"># gamma parameter according to the BAT paper</span>
            <span class="n">gamma</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span>
            <span class="c1"># alpha parameter according to the BAT paper</span>
            <span class="n">alpha</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
            
            <span class="c1"># initial best solution</span>
            <span class="n">bat_star</span><span class="o">=</span> <span class="n">bats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            
            <span class="n">not_changed</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxit</span><span class="p">):</span>
                <span class="n">not_changed</span><span class="o">=</span> <span class="n">not_changed</span> <span class="o">+</span> <span class="mi">1</span>
                
                <span class="k">if</span> <span class="n">not_changed</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">:</span>
                    <span class="k">break</span>
                
                <span class="c1"># update frequencies</span>
                <span class="n">f</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span> <span class="n">n_pop</span><span class="p">)</span><span class="o">*</span><span class="n">f_max</span>
                
                <span class="c1"># update velocities</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">velocities</span><span class="p">)):</span>
                    <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">bat_star</span><span class="p">)</span><span class="o">*</span><span class="n">f</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1"># update bats</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bats</span><span class="p">)):</span>
                    <span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">k_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                    <span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">proportion_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">proportion_range</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pop</span><span class="p">):</span>
                    <span class="c1"># generate local solution</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                        <span class="n">random_best_sol</span><span class="o">=</span> <span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="mi">5</span><span class="p">]))][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">random_best_sol</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">bat_star</span><span class="p">))</span><span class="o">*</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                
                <span class="c1"># evaluate and do local search</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_pop</span><span class="p">):</span>
                    <span class="n">scores</span><span class="o">=</span> <span class="n">evaluate</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]),</span> <span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    
                    <span class="c1"># checking if the scores are better than the global score</span>
                    <span class="c1"># implementation of the multi-objective criterion in the SMOTE-PSOBAT paper</span>
                    <span class="n">improved_global</span><span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="nb">min</span><span class="p">([</span><span class="n">global_best</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mf">0.4</span> <span class="ow">and</span> <span class="n">global_best</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">scores</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">improved_global</span><span class="o">=</span> <span class="kc">True</span>
                        <span class="n">not_changed</span><span class="o">=</span> <span class="mi">0</span>
                    <span class="k">elif</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.4</span> <span class="ow">and</span> <span class="n">global_best</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="p">:</span>
                        <span class="n">improved_global</span><span class="o">=</span> <span class="kc">True</span>
                        <span class="n">not_changed</span><span class="o">=</span> <span class="mi">0</span>
                    
                    <span class="c1"># checking if the scores are better than the local scores</span>
                    <span class="c1"># implementation of the multi-objective criterion in the SMOTE-PSOBAT paper</span>
                    <span class="n">improved_local</span><span class="o">=</span> <span class="kc">False</span>
                    <span class="k">if</span> <span class="nb">min</span><span class="p">([</span><span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span> <span class="o">&gt;</span> <span class="mf">0.4</span> <span class="ow">and</span> <span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">scores</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">improved_local</span><span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="n">scores</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.4</span> <span class="ow">and</span> <span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mf">0.4</span><span class="p">:</span>
                        <span class="n">improved_local</span><span class="o">=</span> <span class="kc">True</span>
                    
                    <span class="c1"># local search in the bet algorithm</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">improved_local</span><span class="p">:</span>
                        <span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">scores</span><span class="p">,</span> <span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()])</span>
                        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">alpha</span>
                        <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">gamma</span><span class="o">*</span><span class="n">t</span><span class="p">))</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="n">improved_global</span><span class="p">:</span>
                        <span class="n">global_best</span><span class="o">=</span> <span class="p">[</span><span class="n">scores</span><span class="p">,</span> <span class="n">bats</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()]</span>

                    <span class="c1"># ranking local solutions to keep track of the best 5</span>
                    <span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])[:</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="mi">5</span><span class="p">])]</span>
                    
                <span class="n">t</span><span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="mi">1</span>
        
            <span class="k">return</span> <span class="n">global_best</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;pso&#39;</span><span class="p">:</span>
            <span class="n">best_combination</span><span class="o">=</span> <span class="n">PSO</span><span class="p">()</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bat&#39;</span><span class="p">:</span>
            <span class="n">best_combination</span><span class="o">=</span> <span class="n">BAT</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Search method </span><span class="si">%s</span><span class="s2"> not supported yet.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="n">best_combination</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">best_combination</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMOTE_PSOBAT.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_PSOBAT.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;maxit&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxit</span><span class="p">,</span> 
                <span class="s1">&#39;c1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">c1</span><span class="p">,</span> 
                <span class="s1">&#39;c2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">c2</span><span class="p">,</span> 
                <span class="s1">&#39;c3&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">c3</span><span class="p">,</span> 
                <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> 
                <span class="s1">&#39;gamma&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span><span class="p">,</span> 
                <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="MDO"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MDO">[docs]</a><span class="k">class</span> <span class="nc">MDO</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @ARTICLE{mdo, </span>
<span class="sd">                        author={Abdi, L. and Hashemi, S.}, </span>
<span class="sd">                        journal={IEEE Transactions on Knowledge and Data Engineering}, </span>
<span class="sd">                        title={To Combat Multi-Class Imbalanced Problems by Means of Over-Sampling Techniques}, </span>
<span class="sd">                        year={2016}, </span>
<span class="sd">                        volume={28}, </span>
<span class="sd">                        number={1}, </span>
<span class="sd">                        pages={238-251}, </span>
<span class="sd">                        keywords={covariance analysis;learning (artificial intelligence);modelling;pattern classification;sampling methods;statistical distributions;minority class instance modelling;probability contour;covariance structure;MDO;Mahalanobis distance-based oversampling technique;data-oriented technique;model-oriented solution;machine learning algorithm;data skewness;multiclass imbalanced problem;Mathematical model;Training;Accuracy;Eigenvalues and eigenfunctions;Machine learning algorithms;Algorithm design and analysis;Benchmark testing;Multi-class imbalance problems;over-sampling techniques;Mahalanobis distance;Multi-class imbalance problems;over-sampling techniques;Mahalanobis distance}, </span>
<span class="sd">                        doi={10.1109/TKDE.2015.2458858}, </span>
<span class="sd">                        ISSN={1041-4347}, </span>
<span class="sd">                        month={Jan}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_dim_reduction</span><span class="p">]</span>
    
<div class="viewcode-block" id="MDO.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MDO.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">K2</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">K1_frac</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            K2 (int): number of neighbors</span>
<span class="sd">            K1_frac (float): the fraction of K2 to set K1</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">K2</span><span class="p">,</span> <span class="s2">&quot;K2&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">K1_frac</span><span class="p">,</span> <span class="s2">&quot;K1_frac&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="o">=</span> <span class="n">K2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K1_frac</span><span class="o">=</span> <span class="n">K1_frac</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="MDO.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MDO.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;K2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;K1_frac&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="MDO.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MDO.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># determining K1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">K1_frac</span><span class="p">)</span>
        <span class="n">K1</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">K1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)])</span>
        <span class="n">K2</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">K2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)])</span>
        
        <span class="c1"># Algorithm 2 - chooseSamples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">K2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># extracting the number of minority samples in local neighborhoods</span>
        <span class="n">n_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span>
        
        <span class="c1"># extracting selected samples from minority ones</span>
        <span class="n">X_sel</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">n_min</span> <span class="o">&gt;=</span> <span class="n">K1</span><span class="p">]</span>
        
        <span class="c1"># falling back to returning input data if all the input is considered noise</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_sel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;No samples selected&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># computing distribution</span>
        <span class="n">weights</span><span class="o">=</span> <span class="n">n_min</span><span class="p">[</span><span class="n">n_min</span> <span class="o">&gt;=</span> <span class="n">K1</span><span class="p">]</span><span class="o">/</span><span class="n">K2</span>
        <span class="n">weights</span><span class="o">=</span> <span class="n">weights</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span>
        
        <span class="c1"># Algorithm 1 - MDO over-sampling</span>
        <span class="n">mu</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X_sel</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">Z</span><span class="o">=</span> <span class="n">X_sel</span> <span class="o">-</span> <span class="n">mu</span>
        <span class="c1"># executing PCA</span>
        <span class="n">pca</span><span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">len</span><span class="p">(</span><span class="n">Z</span><span class="p">)]))</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
        <span class="n">T</span><span class="o">=</span> <span class="n">pca</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span>
        <span class="c1"># computing variances (step 13)</span>
        <span class="n">V</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="n">V</span><span class="p">[</span><span class="n">V</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">]</span><span class="o">=</span> <span class="mf">0.001</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="c1"># selecting a sample randomly according to the distribution</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_sel</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">weights</span><span class="p">)</span>
            
            <span class="c1"># finding vector in PCA space</span>
            <span class="n">X_temp</span><span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">X_temp_square</span><span class="o">=</span> <span class="n">X_temp</span><span class="o">**</span><span class="mi">2</span>
            
            <span class="c1"># computing alphas</span>
            <span class="n">alpha</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">X_temp_square</span><span class="o">/</span><span class="n">V</span><span class="p">)</span>
            <span class="n">alpha_V</span><span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">V</span>
            <span class="n">alpha_V</span><span class="p">[</span><span class="n">alpha_V</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">]</span><span class="o">=</span> <span class="mf">0.001</span>

            <span class="c1"># initializing a new vector</span>
            <span class="n">X_new</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_temp</span><span class="p">))</span>
            
            <span class="c1"># sampling components of the new vector</span>
            <span class="n">s</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_temp</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">r</span><span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">alpha_V</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">X_new</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">r</span>
                <span class="n">s</span><span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="p">(</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">alpha_V</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
            
            <span class="k">if</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">last_fea_val</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tmp</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">V</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">tmp</span><span class="o">=</span> <span class="mi">0</span>
                <span class="n">last_fea_val</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
            <span class="c1"># determine last component to fulfill the ellipse equation</span>
            <span class="n">X_new</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">last_fea_val</span>
            <span class="c1"># append to new samples</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">pca</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">+</span> <span class="n">mu</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="MDO.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.MDO.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;K2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">K2</span><span class="p">,</span> 
                <span class="s1">&#39;K1_frac&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">K1_frac</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="Random_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Random_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">Random_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{random_smote,</span>
<span class="sd">                            author=&quot;Dong, Yanjie</span>
<span class="sd">                            and Wang, Xuehua&quot;,</span>
<span class="sd">                            editor=&quot;Xiong, Hui</span>
<span class="sd">                            and Lee, W. B.&quot;,</span>
<span class="sd">                            title=&quot;A New Over-Sampling Approach: Random-SMOTE for Learning from Imbalanced Data Sets&quot;,</span>
<span class="sd">                            booktitle=&quot;Knowledge Science, Engineering and Management&quot;,</span>
<span class="sd">                            year=&quot;2011&quot;,</span>
<span class="sd">                            publisher=&quot;Springer Berlin Heidelberg&quot;,</span>
<span class="sd">                            address=&quot;Berlin, Heidelberg&quot;,</span>
<span class="sd">                            pages=&quot;343--352&quot;,</span>
<span class="sd">                            abstract=&quot;For imbalanced data sets, examples of minority class are sparsely distributed in sample space compared with the overwhelming amount of majority class. This presents a great challenge for learning from the minority class. Enlightened by SMOTE, a new over-sampling method, Random-SMOTE, which generates examples randomly in the sample space of minority class is proposed. According to the experiments on real data sets, Random-SMOTE is more effective compared with other random sampling approaches.&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-642-25975-3&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_componentwise</span><span class="p">]</span>
    
<div class="viewcode-block" id="Random_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Random_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">            </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Random_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Random_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="Random_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Random_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model to find closest neighbors of minority points</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)))</span>
            <span class="n">y_1_idx</span><span class="p">,</span> <span class="n">y_2_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">t</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points_componentwise</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">y_1_idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">y_2_idx</span><span class="p">])</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points_componentwise</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">t</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="Random_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Random_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="ISMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISMOTE">[docs]</a><span class="k">class</span> <span class="nc">ISMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{ismote,</span>
<span class="sd">                            author=&quot;Li, Hu</span>
<span class="sd">                            and Zou, Peng</span>
<span class="sd">                            and Wang, Xiang</span>
<span class="sd">                            and Xia, Rongze&quot;,</span>
<span class="sd">                            editor=&quot;Sun, Zengqi</span>
<span class="sd">                            and Deng, Zhidong&quot;,</span>
<span class="sd">                            title=&quot;A New Combination Sampling Method for Imbalanced Data&quot;,</span>
<span class="sd">                            booktitle=&quot;Proceedings of 2013 Chinese Intelligent Automation Conference&quot;,</span>
<span class="sd">                            year=&quot;2013&quot;,</span>
<span class="sd">                            publisher=&quot;Springer Berlin Heidelberg&quot;,</span>
<span class="sd">                            address=&quot;Berlin, Heidelberg&quot;,</span>
<span class="sd">                            pages=&quot;547--554&quot;,</span>
<span class="sd">                            abstract=&quot;Imbalanced data is commonly in the real world and brings a lot of challenges. In this paper, we propose a combination sampling method which resamples both minority class and majority class. Improved SMOTE (ISMOTE) is used to do over-sampling on minority class, while distance-based under-sampling (DUS) method is used to do under-sampling on majority class. We adjust the sampling times to search for the optimal results while maintain the dataset size unchanged. Experiments on UCI datasets show that the proposed method performs better than using single over-sampling or under-sampling method.&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-642-38466-0&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">]</span>
    
<div class="viewcode-block" id="ISMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">minority_weight</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            minority_weight (float): weight parameter according to the paper</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">minority_weight</span><span class="p">,</span> <span class="s2">&quot;minority_weight&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minority_weight</span><span class="o">=</span> <span class="n">minority_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="ISMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;minority_weight&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="ISMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># computing distances of majority samples from minority ones</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        
        <span class="c1"># sort majority instances in descending order by their mean distance from minority samples</span>
        <span class="n">ind_sorted</span><span class="p">,</span> <span class="n">dist_sorted</span><span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="c1"># remove the ones being farthest from the minority samples</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X_maj</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">ind_sorted</span><span class="p">[</span><span class="n">num_to_sample</span><span class="p">:])]</span>
        
        <span class="c1"># construct new dataset</span>
        <span class="n">X_new</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_min</span><span class="p">])</span>
        <span class="n">y_new</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X_new</span><span class="p">[</span><span class="n">y_new</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_new</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># do the oversampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)))</span>
            <span class="n">y_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            
            <span class="c1"># different generation scheme depending on the class label</span>
            <span class="k">if</span> <span class="n">y_new</span><span class="p">[</span><span class="n">y_idx</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">X_new</span><span class="p">[</span><span class="n">y_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_weight</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="n">X_new</span><span class="p">[</span><span class="n">y_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_weight</span><span class="p">))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_new</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y_new</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="ISMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ISMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;minority_weight&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_weight</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="VIS_RST"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.VIS_RST">[docs]</a><span class="k">class</span> <span class="nc">VIS_RST</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{vis_rst,</span>
<span class="sd">                            author=&quot;Borowska, Katarzyna</span>
<span class="sd">                            and Stepaniuk, Jaros{\l}aw&quot;,</span>
<span class="sd">                            editor=&quot;Saeed, Khalid</span>
<span class="sd">                            and Homenda, W{\l}adys{\l}aw&quot;,</span>
<span class="sd">                            title=&quot;Imbalanced Data Classification: A Novel Re-sampling Approach Combining Versatile Improved SMOTE and Rough Sets&quot;,</span>
<span class="sd">                            booktitle=&quot;Computer Information Systems and Industrial Management&quot;,</span>
<span class="sd">                            year=&quot;2016&quot;,</span>
<span class="sd">                            publisher=&quot;Springer International Publishing&quot;,</span>
<span class="sd">                            address=&quot;Cham&quot;,</span>
<span class="sd">                            pages=&quot;31--42&quot;,</span>
<span class="sd">                            abstract=&quot;In recent years, the problem of learning from imbalanced data has emerged as important and challenging. The fact that one of the classes is underrepresented in the data set is not the only reason of difficulties. The complex distribution of data, especially small disjuncts, noise and class overlapping, contributes to the significant depletion of classifier&#39;s performance. Hence, the numerous solutions were proposed. They are categorized into three groups: data-level techniques, algorithm-level methods and cost-sensitive approaches. This paper presents a novel data-level method combining Versatile Improved SMOTE and rough sets. The algorithm was applied to the two-class problems, data sets were characterized by the nominal attributes. We evaluated the proposed technique in comparison with other preprocessing methods. The impact of the additional cleaning phase was specifically verified.&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-319-45378-1&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Replication of DANGER samples will be removed by the last step of noise filtering.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">]</span>
    
<div class="viewcode-block" id="VIS_RST.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.VIS_RST.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="VIS_RST.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.VIS_RST.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="VIS_RST.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.VIS_RST.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># standardizing the data</span>
        <span class="n">ss</span><span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">y</span><span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model to determine boundary region</span>
        <span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        
        <span class="c1"># determining boundary region of majority samples</span>
        <span class="n">boundary</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_neighbors</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">))])</span>
        <span class="n">y_maj</span><span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        <span class="n">y_maj</span><span class="p">[</span><span class="n">boundary</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span>
        <span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span><span class="o">=</span> <span class="n">y_maj</span>
        
        <span class="c1"># extracting new minority and majority set</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="c1"># labeling minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># extracting labels</span>
        <span class="n">labels</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)):</span>
            <span class="n">min_class_neighbors</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">min_class_neighbors</span> <span class="o">==</span> <span class="n">n_neighbors</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;noise&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">min_class_neighbors</span> <span class="o">&lt;</span> <span class="n">n_neighbors</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;safe&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;danger&#39;</span><span class="p">)</span>
        
        <span class="c1"># extracting the number of different labels (noise is not used)</span>
        <span class="n">safe</span><span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">l</span> <span class="o">==</span> <span class="s1">&#39;safe&#39;</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>
        <span class="n">danger</span><span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">l</span> <span class="o">==</span> <span class="s1">&#39;danger&#39;</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">safe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mode</span><span class="o">=</span> <span class="s1">&#39;no_safe&#39;</span>
        <span class="k">elif</span> <span class="n">danger</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">):</span>
            <span class="n">mode</span><span class="o">=</span> <span class="s1">&#39;high_complexity&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mode</span><span class="o">=</span> <span class="s1">&#39;low_complexity&#39;</span>
        
        <span class="c1"># fitting nearest neighbors to find the neighbors of minority elements among minority elements</span>
        <span class="n">nn_min</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn_min</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist_min</span><span class="p">,</span> <span class="n">ind_min</span><span class="o">=</span> <span class="n">nn_min</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">mask</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="c1"># choosing a random minority sample</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)))</span>
            
            <span class="c1"># implementation of sampling rules depending on the mode</span>
            <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;high_complexity&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;noise&#39;</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;danger&#39;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="n">mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind_min</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]))</span>
            <span class="k">elif</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;low_complexity&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;noise&#39;</span><span class="p">:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="n">labels</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;danger&#39;</span><span class="p">:</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind_min</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]))</span>
                <span class="k">elif</span> <span class="ow">not</span> <span class="n">mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> 
                    <span class="n">mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind_min</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]))</span>
        
        <span class="n">X_samp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
        
        <span class="c1"># final noise removal by removing those minority samples generated and not belonging to the lower approximation</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist_check</span><span class="p">,</span> <span class="n">ind_check</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_samp</span><span class="p">)</span>
        <span class="n">num_maj_mask</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind_check</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span>
        <span class="n">X_samp</span><span class="o">=</span> <span class="n">X_samp</span><span class="p">[</span><span class="n">num_maj_mask</span><span class="p">]</span>
        
        <span class="k">return</span> <span class="n">ss</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">X_samp</span><span class="p">])),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_samp</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="VIS_RST.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.VIS_RST.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="GASMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.GASMOTE">[docs]</a><span class="k">class</span> <span class="nc">GASMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @Article{gasmote,</span>
<span class="sd">                        author=&quot;Jiang, Kun</span>
<span class="sd">                        and Lu, Jing</span>
<span class="sd">                        and Xia, Kuiliang&quot;,</span>
<span class="sd">                        title=&quot;A Novel Algorithm for Imbalance Data Classification Based on Genetic Algorithm Improved SMOTE&quot;,</span>
<span class="sd">                        journal=&quot;Arabian Journal for Science and Engineering&quot;,</span>
<span class="sd">                        year=&quot;2016&quot;,</span>
<span class="sd">                        month=&quot;Aug&quot;,</span>
<span class="sd">                        day=&quot;01&quot;,</span>
<span class="sd">                        volume=&quot;41&quot;,</span>
<span class="sd">                        number=&quot;8&quot;,</span>
<span class="sd">                        pages=&quot;3255--3266&quot;,</span>
<span class="sd">                        abstract=&quot;The classification of imbalanced data has been recognized as a crucial problem in machine learning and data mining. In an imbalanced dataset, there are significantly fewer training instances of one class compared to another class. Hence, the minority class instances are much more likely to be misclassified. In the literature, the synthetic minority over-sampling technique (SMOTE) has been developed to deal with the classification of imbalanced datasets. It synthesizes new samples of the minority class to balance the dataset, by re-sampling the instances of the minority class. Nevertheless, the existing algorithms-based SMOTE uses the same sampling rate for all instances of the minority class. This results in sub-optimal performance. To address this issue, we propose a novel genetic algorithm-based SMOTE (GASMOTE) algorithm. The GASMOTE algorithm uses different sampling rates for different minority class instances and finds the combination of optimal sampling rates. The experimental results on ten typical imbalance datasets show that, compared with SMOTE algorithm, GASMOTE can increase 5.9{\%} on F-measure value and 1.6{\%} on G-mean value, and compared with Borderline-SMOTE algorithm, GASMOTE can increase 3.7{\%} on F-measure value and 2.3{\%} on G-mean value. GASMOTE can be used as a new over-sampling technique to deal with imbalance dataset classification problem. We have particularly applied the GASMOTE algorithm to a practical engineering application: prediction of rockburst in the VCR rockburst datasets. The experiment results indicate that the GASMOTE algorithm can accurately predict the rockburst occurrence and hence provides guidance to the design and construction of safe deep mining engineering structures.&quot;,</span>
<span class="sd">                        issn=&quot;2191-4281&quot;,</span>
<span class="sd">                        doi=&quot;10.1007/s13369-016-2179-2&quot;,</span>
<span class="sd">                        url=&quot;https://doi.org/10.1007/s13369-016-2179-2&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_memetic</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="GASMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.GASMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">maxn</span><span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">n_pop</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">popl3</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">pm</span><span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span> <span class="n">pr</span><span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="n">Ge</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            maxn (int): maximum number of samples to generate per minority instances</span>
<span class="sd">            n_pop (int): size of population</span>
<span class="sd">            popl3 (int): number of crossovers</span>
<span class="sd">            pm (float): mutation probability</span>
<span class="sd">            pr (float): selection probability</span>
<span class="sd">            Ge (int): number of generations</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">maxn</span><span class="p">,</span> <span class="s2">&quot;maxn&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_pop</span><span class="p">,</span> <span class="s2">&quot;n_pop&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">pm</span><span class="p">,</span> <span class="s2">&quot;pm&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">pr</span><span class="p">,</span> <span class="s2">&quot;pr&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">Ge</span><span class="p">,</span> <span class="s2">&quot;Ge&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maxn</span><span class="o">=</span> <span class="n">maxn</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="o">=</span> <span class="n">n_pop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">popl3</span><span class="o">=</span><span class="n">popl3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pm</span><span class="o">=</span> <span class="n">pm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pr</span><span class="o">=</span> <span class="n">pr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ge</span><span class="o">=</span> <span class="n">Ge</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="GASMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.GASMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;maxn&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_pop&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">],</span> 
                                                    <span class="s1">&#39;popl3&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> 
                                                    <span class="s1">&#39;pm&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">],</span> 
                                                    <span class="s1">&#39;pr&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">],</span> 
                                                    <span class="s1">&#39;Ge&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="GASMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.GASMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model to find minority neighbors of minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">kfold</span><span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="mi">5</span><span class="p">]))</span>
        
        <span class="k">def</span> <span class="nf">fitness</span><span class="p">(</span><span class="n">conf</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Evluate fitness of configuration</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                conf (list(list)): configuration</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># generate new samples</span>
            <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conf</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                    <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]))</span>
            
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if no samples are generated</span>
                <span class="n">X_new</span><span class="o">=</span> <span class="n">X</span>
                <span class="n">y_new</span><span class="o">=</span> <span class="n">y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># construct dataset</span>
                <span class="n">X_new</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)])</span>
                <span class="n">y_new</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span>
            
            <span class="c1"># execute kfold cross validation</span>
            <span class="n">preds</span><span class="p">,</span> <span class="n">tests</span><span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">kfold</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X_new</span><span class="p">):</span>
                <span class="n">dt</span><span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_new</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">y_new</span><span class="p">[</span><span class="n">train</span><span class="p">])</span>
                <span class="n">preds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_new</span><span class="p">[</span><span class="n">test</span><span class="p">]))</span>
                <span class="n">tests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_new</span><span class="p">[</span><span class="n">test</span><span class="p">])</span>
            <span class="n">preds</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
            <span class="n">tests</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
            
            <span class="c1"># compute fitness measure</span>
            <span class="n">tp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="n">tests</span> <span class="o">==</span> <span class="n">preds</span><span class="p">))</span>
            <span class="n">tn</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="n">tests</span> <span class="o">==</span> <span class="n">preds</span><span class="p">))</span>
            <span class="n">fp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="n">tests</span> <span class="o">!=</span> <span class="n">preds</span><span class="p">))</span>
            <span class="n">fn</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="n">tests</span> <span class="o">!=</span> <span class="n">preds</span><span class="p">))</span>
            <span class="n">sens</span><span class="o">=</span> <span class="n">tp</span><span class="o">/</span><span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span><span class="p">)</span>
            <span class="n">spec</span><span class="o">=</span> <span class="n">tn</span><span class="o">/</span><span class="p">(</span><span class="n">fp</span> <span class="o">+</span> <span class="n">tn</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">sens</span><span class="o">*</span><span class="n">spec</span><span class="p">)</span>
        
        <span class="k">def</span> <span class="nf">crossover</span><span class="p">(</span><span class="n">conf_a</span><span class="p">,</span> <span class="n">conf_b</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Crossover</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                conf_a (list(list)): configuration to crossover</span>
<span class="sd">                conf_b (list(list)): configuration to crossover</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                list(list), list(list): the configurations after crossover</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">popl3</span><span class="p">):</span>
                <span class="n">k</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conf_a</span><span class="p">))</span>
                <span class="n">conf_a</span><span class="p">,</span> <span class="n">conf_b</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">conf_a</span><span class="p">[:</span><span class="n">k</span><span class="p">],</span> <span class="n">conf_b</span><span class="p">[</span><span class="n">k</span><span class="p">:]]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">conf_b</span><span class="p">[:</span><span class="n">k</span><span class="p">],</span> <span class="n">conf_a</span><span class="p">[</span><span class="n">k</span><span class="p">:]])</span>
            <span class="k">return</span> <span class="n">conf_a</span><span class="p">,</span> <span class="n">conf_b</span>
        
        <span class="k">def</span> <span class="nf">mutation</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">ge</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Mutation</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                conf (list(list)): configuration to mutate</span>
<span class="sd">                ge (int): iteration number</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">conf</span><span class="o">=</span> <span class="n">conf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pm</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conf</span><span class="p">)):</span>
                    <span class="n">r</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">**</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ge</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">Ge</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">conf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxn</span> <span class="o">-</span> <span class="n">conf</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">conf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">0</span><span class="p">)</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">conf</span>
        
        <span class="c1"># generate initial population</span>
        <span class="n">population</span><span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxn</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
        
        <span class="c1"># calculate fitness values</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">population</span><span class="p">:</span>
            <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">fitness</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># start iteration</span>
        <span class="n">ge</span><span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">ge</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ge</span><span class="p">:</span>
            <span class="c1"># sorting population in descending order by fitness scores</span>
            <span class="n">population</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            
            <span class="c1"># selection operation (Step 2)</span>
            <span class="n">pp</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">pr</span><span class="p">)</span>
            <span class="n">population_new</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">pp</span><span class="p">):</span>
                <span class="n">population_new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">population_new</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">population</span><span class="p">[:(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span> <span class="o">-</span> <span class="n">pp</span><span class="p">)])</span>
            <span class="n">population</span><span class="o">=</span> <span class="n">population_new</span>
            
            <span class="c1"># crossover</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
                <span class="n">conf_a</span><span class="p">,</span> <span class="n">conf_b</span><span class="o">=</span> <span class="n">crossover</span><span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span> <span class="n">population</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)][</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">conf_a</span><span class="p">,</span> <span class="n">fitness</span><span class="p">(</span><span class="n">conf_a</span><span class="p">)])</span>
                <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">conf_b</span><span class="p">,</span> <span class="n">fitness</span><span class="p">(</span><span class="n">conf_b</span><span class="p">)])</span>
            
            <span class="c1">#mutation</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="o">/</span><span class="mi">2</span><span class="p">)):</span>
                <span class="n">conf</span><span class="o">=</span> <span class="n">mutation</span><span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ge</span><span class="p">)</span>
                <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">conf</span><span class="p">,</span> <span class="n">fitness</span><span class="p">(</span><span class="n">conf</span><span class="p">)])</span>
                
            <span class="n">ge</span><span class="o">=</span> <span class="n">ge</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="c1"># sorting final population</span>
        <span class="n">population</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">population</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># get best configuration</span>
        <span class="n">conf</span><span class="o">=</span> <span class="n">population</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># generate final samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conf</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]))</span>
                
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>

<div class="viewcode-block" id="GASMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.GASMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;maxn&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxn</span><span class="p">,</span> 
                <span class="s1">&#39;n_pop&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">,</span> 
                <span class="s1">&#39;popl3&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">popl3</span><span class="p">,</span> 
                <span class="s1">&#39;pm&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pm</span><span class="p">,</span> 
                <span class="s1">&#39;pr&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pr</span><span class="p">,</span> 
                <span class="s1">&#39;Ge&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ge</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="A_SUWO"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.A_SUWO">[docs]</a><span class="k">class</span> <span class="nc">A_SUWO</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{a_suwo,</span>
<span class="sd">                        title = &quot;Adaptive semi-unsupervised weighted oversampling (A-SUWO) for imbalanced datasets&quot;,</span>
<span class="sd">                        journal = &quot;Expert Systems with Applications&quot;,</span>
<span class="sd">                        volume = &quot;46&quot;,</span>
<span class="sd">                        pages = &quot;405 - 416&quot;,</span>
<span class="sd">                        year = &quot;2016&quot;,</span>
<span class="sd">                        issn = &quot;0957-4174&quot;,</span>
<span class="sd">                        doi = &quot;https://doi.org/10.1016/j.eswa.2015.10.031&quot;,</span>
<span class="sd">                        url = &quot;http://www.sciencedirect.com/science/article/pii/S0957417415007356&quot;,</span>
<span class="sd">                        author = &quot;Iman Nekooeimehr and Susana K. Lai-Yuen&quot;,</span>
<span class="sd">                        keywords = &quot;Imbalanced dataset, Classification, Clustering, Oversampling&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Equation (7) misses a division by R_j.</span>
<span class="sd">        * It is not specified how to sample from clusters with 1 instances.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_based</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">]</span>
    
<div class="viewcode-block" id="A_SUWO.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.A_SUWO.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_clus_maj</span><span class="o">=</span> <span class="mi">7</span><span class="p">,</span> <span class="n">c_thres</span><span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            n_clus_maj (int): number of majority clusters</span>
<span class="sd">            c_thres (float): threshold on distances</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_clus_maj</span><span class="p">,</span> <span class="s2">&quot;n_clus_maj&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">c_thres</span><span class="p">,</span> <span class="s2">&quot;c_thres&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clus_maj</span><span class="o">=</span> <span class="n">n_clus_maj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c_thres</span><span class="o">=</span> <span class="n">c_thres</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="A_SUWO.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.A_SUWO.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_clus_maj&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> 
                                                    <span class="s1">&#39;c_thres&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="A_SUWO.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.A_SUWO.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_orig</span><span class="p">,</span> <span class="n">y_orig</span><span class="o">=</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span>
        
        <span class="c1"># fitting nearest neighbors to find neighbors of all samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># identifying as noise those samples which do not have neighbors of the same label</span>
        <span class="n">noise</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))]))[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># removing noise</span>
        <span class="n">X</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">noise</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">noise</span><span class="p">)</span>
        
        <span class="c1"># extarcting modified minority and majority datasets</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;All minority samples removed as noise&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X_orig</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y_orig</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">n_clus_maj</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clus_maj</span><span class="p">])</span>
        
        <span class="c1"># clustering majority samples</span>
        <span class="n">ac</span><span class="o">=</span> <span class="n">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="n">n_clus_maj</span><span class="p">)</span>
        <span class="n">ac</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        <span class="n">maj_clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ac</span><span class="o">.</span><span class="n">labels_</span> <span class="o">==</span> <span class="n">i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clus_maj</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">maj_clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X_orig</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y_orig</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># initialize minority clusters</span>
        <span class="n">min_clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))]</span>
        
        <span class="c1"># compute minority distance matrix of cluster</span>
        <span class="n">dm_min</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm_min</span><span class="p">)):</span>
            <span class="n">dm_min</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        
        <span class="c1"># compute distance matrix of minority and majority clusters</span>
        <span class="n">dm_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">maj_clusters</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">maj_clusters</span><span class="p">)):</span>
                <span class="n">dm_maj</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">min_clusters</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span> <span class="n">X_maj</span><span class="p">[</span><span class="n">maj_clusters</span><span class="p">[</span><span class="n">j</span><span class="p">]]))</span>
        
        <span class="c1"># compute threshold</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">d_med</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">T</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">d_med</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">c_thres</span>
        
        <span class="c1"># do the clustering of minority samples</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1"># finding minimum distance between minority clusters</span>
            <span class="n">pi</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">dm_min</span><span class="p">)</span>
            
            <span class="c1"># if the minimum distance is higher than the threshold, stop</span>
            <span class="k">if</span> <span class="n">pi</span> <span class="o">&gt;</span> <span class="n">T</span><span class="p">:</span>
                <span class="k">break</span>
            
            <span class="c1"># find cluster pair of minimum distance</span>
            <span class="n">min_dist_pair</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dm_min</span> <span class="o">==</span> <span class="n">pi</span><span class="p">)</span>
            <span class="n">min_i</span><span class="o">=</span> <span class="n">min_dist_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">min_j</span><span class="o">=</span> <span class="n">min_dist_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># Step 3 - find majority clusters closer than pi</span>
            <span class="n">A</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">dm_maj</span><span class="p">[</span><span class="n">min_i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pi</span><span class="p">,</span> <span class="n">dm_maj</span><span class="p">[</span><span class="n">min_j</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">pi</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># Step 4 - checking if there is a majority cluster between the minority ones</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dm_min</span><span class="p">[</span><span class="n">min_i</span><span class="p">,</span> <span class="n">min_j</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                <span class="n">dm_min</span><span class="p">[</span><span class="n">min_j</span><span class="p">,</span> <span class="n">min_i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Step 5</span>
                <span class="c1"># unifying minority clusters</span>
                <span class="n">min_clusters</span><span class="p">[</span><span class="n">min_i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">min_clusters</span><span class="p">[</span><span class="n">min_i</span><span class="p">],</span> <span class="n">min_clusters</span><span class="p">[</span><span class="n">min_j</span><span class="p">]])</span>
                <span class="c1"># removing one of them</span>
                <span class="n">min_clusters</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">min_clusters</span><span class="p">,</span> <span class="n">min_j</span><span class="p">)</span>
                
                <span class="c1"># updating the minority distance matrix</span>
                <span class="n">dm_min</span><span class="p">[</span><span class="n">min_i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dm_min</span><span class="p">[</span><span class="n">min_i</span><span class="p">],</span> <span class="n">dm_min</span><span class="p">[</span><span class="n">min_j</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">dm_min</span><span class="p">[:,</span><span class="n">min_i</span><span class="p">]</span><span class="o">=</span> <span class="n">dm_min</span><span class="p">[</span><span class="n">min_i</span><span class="p">]</span>
                <span class="c1"># removing jth row and column (merged in i)</span>
                <span class="n">dm_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm_min</span><span class="p">,</span> <span class="n">min_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">dm_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm_min</span><span class="p">,</span> <span class="n">min_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
                
                <span class="c1"># fixing the diagonal elements</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dm_min</span><span class="p">)):</span>
                    <span class="n">dm_min</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
                
                <span class="c1"># updating the minority-majority distance matrix</span>
                <span class="n">dm_maj</span><span class="p">[</span><span class="n">min_i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">dm_maj</span><span class="p">[</span><span class="n">min_i</span><span class="p">],</span> <span class="n">dm_maj</span><span class="p">[</span><span class="n">min_j</span><span class="p">]]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">dm_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">dm_maj</span><span class="p">,</span> <span class="n">min_j</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="c1"># adaptive sub-cluster sizing</span>
        <span class="n">eps</span><span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># going through all minority clusters</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">min_clusters</span><span class="p">:</span>
            <span class="c1"># checking if cluster size is higher than 1</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">k</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="mi">5</span><span class="p">])</span>
                <span class="n">kfold</span><span class="o">=</span> <span class="n">KFold</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
                <span class="n">preds</span><span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># executing k-fold cross validation with linear discriminant analysis</span>
                <span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">kfold</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">c</span><span class="p">]):</span>
                    <span class="n">X_train</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_min</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">train</span><span class="p">]])</span>
                    <span class="n">y_train</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">train</span><span class="p">]))])</span>
                    <span class="n">preds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LinearDiscriminantAnalysis</span><span class="p">()</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">test</span><span class="p">]))</span>
                <span class="n">preds</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
                <span class="c1"># extracting error rate</span>
                <span class="n">eps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">preds</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">preds</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">eps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span>
        
        <span class="c1"># sampling distribution over clusters</span>
        <span class="n">min_cluster_dist</span><span class="o">=</span> <span class="n">eps</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
        
        <span class="c1"># synthetic instance generation - determining within cluster distribution</span>
        <span class="c1"># finding majority neighbor distances of minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="o">=</span> <span class="n">dist</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">dist</span><span class="o">=</span> <span class="mf">1.0</span><span class="o">/</span><span class="n">dist</span>
        
        <span class="c1"># computing the THs</span>
        <span class="n">THs</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">min_clusters</span><span class="p">:</span>
            <span class="n">THs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span>
        
        <span class="c1"># determining within cluster distributions</span>
        <span class="n">within_cluster_dist</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">min_clusters</span><span class="p">):</span>
            <span class="n">Gamma</span><span class="o">=</span> <span class="n">dist</span><span class="p">[</span><span class="n">c</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">Gamma</span><span class="p">[</span><span class="n">Gamma</span> <span class="o">&gt;</span> <span class="n">THs</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span> <span class="n">THs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">within_cluster_dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Gamma</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Gamma</span><span class="p">))</span>
        
        <span class="c1"># extracting within cluster neighbors</span>
        <span class="n">within_cluster_neighbors</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">min_clusters</span><span class="p">:</span>
            <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="n">within_cluster_neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">c</span><span class="p">])[</span><span class="mi">1</span><span class="p">])</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="c1"># choose random cluster index</span>
            <span class="n">cluster_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">min_clusters</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">min_cluster_dist</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># if the cluster has at least two elemenets</span>
                <span class="n">sample_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">min_clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])),</span> <span class="n">p</span><span class="o">=</span> <span class="n">within_cluster_dist</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])</span>
                <span class="n">neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">within_cluster_neighbors</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
                <span class="n">point</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">min_clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">][</span><span class="n">sample_idx</span><span class="p">]]</span>
                <span class="n">neighbor</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">min_clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">][</span><span class="n">neighbor_idx</span><span class="p">]]</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">min_clusters</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>

<div class="viewcode-block" id="A_SUWO.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.A_SUWO.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_clus_maj&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clus_maj</span><span class="p">,</span> 
                <span class="s1">&#39;c_thres&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">c_thres</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SMOTE_FRST_2T"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_FRST_2T">[docs]</a><span class="k">class</span> <span class="nc">SMOTE_FRST_2T</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{smote_frst_2t,</span>
<span class="sd">                        title = &quot;Fuzzy-rough imbalanced learning for the diagnosis of High Voltage Circuit Breaker maintenance: The SMOTE-FRST-2T algorithm&quot;,</span>
<span class="sd">                        journal = &quot;Engineering Applications of Artificial Intelligence&quot;,</span>
<span class="sd">                        volume = &quot;48&quot;,</span>
<span class="sd">                        pages = &quot;134 - 139&quot;,</span>
<span class="sd">                        year = &quot;2016&quot;,</span>
<span class="sd">                        issn = &quot;0952-1976&quot;,</span>
<span class="sd">                        doi = &quot;https://doi.org/10.1016/j.engappai.2015.10.009&quot;,</span>
<span class="sd">                        url = &quot;http://www.sciencedirect.com/science/article/pii/S0952197615002389&quot;,</span>
<span class="sd">                        author = &quot;Ramentol, E. and Gondres, I. and Lajes, S. and Bello, R. and Caballero,Y. and Cornelis, C. and Herrera, F.&quot;,</span>
<span class="sd">                        keywords = &quot;High Voltage Circuit Breaker (HVCB), Imbalanced learning, Fuzzy rough set theory, Resampling methods&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Unlucky setting of parameters might result 0 points added, we have fixed this by increasing the gamma_S threshold if the number of samples accepted is low.</span>
<span class="sd">        * Similarly, unlucky setting of parameters might result all majority samples turned into minority.</span>
<span class="sd">        * In my opinion, in the algorithm presented in the paper the relations are incorrect. The authors talk about accepting samples having POS score below a threshold, and in the algorithm in both places POS &gt;= gamma is used.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_application</span><span class="p">]</span>
    
<div class="viewcode-block" id="SMOTE_FRST_2T.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_FRST_2T.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">gamma_S</span><span class="o">=</span> <span class="mf">0.7</span><span class="p">,</span> <span class="n">gamma_M</span><span class="o">=</span> <span class="mf">0.03</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_neighbors (int): number of neighbors in the SMOTE sampling</span>
<span class="sd">            gamma_S (float): threshold of synthesized samples</span>
<span class="sd">            gamma_M (float): threshold of majority samples</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">gamma_S</span><span class="p">,</span> <span class="s2">&quot;gamma_S&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">gamma_M</span><span class="p">,</span> <span class="s2">&quot;gamma_M&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_S</span><span class="o">=</span> <span class="n">gamma_S</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_M</span><span class="o">=</span> <span class="n">gamma_M</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SMOTE_FRST_2T.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_FRST_2T.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;gamma_S&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;gamma_M&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.03</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SMOTE_FRST_2T.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_FRST_2T.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Turning the ranges to 1 speeds up the positive membership calculations</span>
        <span class="n">mmscaler</span><span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="n">X</span><span class="o">=</span> <span class="n">mmscaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        
        <span class="c1"># extracting the attribute ranges</span>
        <span class="c1">#ranges= np.max(X, axis= 0) - np.min(X, axis= 0)</span>
        
        <span class="n">d</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        
        <span class="c1"># after MinMax scaling, the POS value can be calculated as follows</span>
        <span class="n">pos_cache</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span> <span class="s1">&#39;l1&#39;</span><span class="p">)</span>
        <span class="n">pos_cache</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">pos_cache</span>
        <span class="n">pos_cache</span><span class="o">=</span> <span class="n">pos_cache</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">pos_cache</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">pos_cache</span>
        
        <span class="c1"># initializing some lists containing the results</span>
        <span class="n">result_synth</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">result_maj</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">iteration</span><span class="o">=</span> <span class="mi">0</span>
        
        <span class="n">gamma_S</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_S</span>
        <span class="n">gamma_M</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_M</span>
        
        <span class="c1"># iterating until the dataset becomes balanced</span>
        <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_synth</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_maj</span><span class="p">))</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;iteration: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">iteration</span><span class="p">))</span>
            <span class="c1"># checking if the parameters aren&#39;t too conservative</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_synth</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">iteration</span><span class="p">:</span>
                <span class="n">gamma_S</span><span class="o">=</span> <span class="n">gamma_S</span><span class="o">*</span><span class="mf">1.1</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;gamma_S increased to </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">gamma_S</span><span class="p">)</span>
            
            <span class="c1"># determine proportion</span>
            <span class="n">diff</span><span class="o">=</span> <span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span> <span class="o">-</span> <span class="nb">sum</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">))</span>
            <span class="n">prop</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">1.1</span><span class="o">/</span><span class="n">diff</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">)</span>
            
            <span class="c1"># executing SMOTE to generate some minority samples</span>
            <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="n">prop</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">X_samp</span><span class="o">=</span> <span class="n">X_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">):]</span>
            
            <span class="n">new_synth</span><span class="o">=</span> <span class="p">[]</span>
            
            <span class="c1"># computing POS membership values for the new samples</span>
            <span class="n">pos_synth</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">X_samp</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span> <span class="s1">&#39;l1&#39;</span><span class="p">)</span>
            <span class="n">pos_synth</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">pos_synth</span>
            <span class="n">pos_synth</span><span class="o">=</span> <span class="n">pos_synth</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
            <span class="n">pos_synth</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">pos_synth</span>
            
            <span class="c1"># adding samples with POS membership smaller than gamma_S to the</span>
            <span class="c1"># minority set</span>
            <span class="n">min_pos</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos_synth</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">to_add</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_pos</span> <span class="o">&lt;</span> <span class="n">gamma_S</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">result_synth</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">X_samp</span><span class="p">[</span><span class="n">to_add</span><span class="p">])</span>
            <span class="n">new_synth</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">X_samp</span><span class="p">[</span><span class="n">to_add</span><span class="p">])</span>

            <span class="c1"># checking the minimum POS values of the majority samples</span>
            <span class="n">min_pos</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pos_cache</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">to_remove</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">min_pos</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_M</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            
            <span class="c1"># if the number of majority samples with POS membership smaller than</span>
            <span class="c1"># gamma_M is not extreme, then changing labels, otherwise decreasing </span>
            <span class="c1"># gamma_M</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
                <span class="n">to_remove</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
                <span class="n">gamma_M</span><span class="o">=</span> <span class="n">gamma_M</span><span class="o">*</span><span class="mf">0.9</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;gamma_M decreased to </span><span class="si">%f</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">gamma_M</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result_maj</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">X_maj</span><span class="p">[</span><span class="n">to_remove</span><span class="p">])</span>
                <span class="n">X_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">pos_cache</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">pos_cache</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># updating pos cache</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_synth</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">pos_cache_new</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">new_synth</span><span class="p">),</span> <span class="n">X_maj</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span> <span class="s1">&#39;l1&#39;</span><span class="p">)</span>
                <span class="n">pos_cache_new</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">pos_cache_new</span>
                <span class="n">pos_cache_new</span><span class="o">=</span> <span class="n">pos_cache_new</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                <span class="n">pos_cache_new</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">pos_cache_new</span>
                
                <span class="n">pos_cache</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">pos_cache</span><span class="p">,</span> <span class="n">pos_cache_new</span><span class="p">])</span>
            
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;minority added: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_add</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;, majority removed: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)))</span>
            
            <span class="n">iteration</span><span class="o">=</span> <span class="n">iteration</span> <span class="o">+</span> <span class="mi">1</span>
        
        <span class="c1"># packing the results</span>
        <span class="n">X_res</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_min</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_synth</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">X_res</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">result_synth</span><span class="p">)])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_maj</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">X_res</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">result_maj</span><span class="p">)])</span>
            
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;All majority samples removed&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">mmscaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="n">y</span>
        
        <span class="n">y_res</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_synth</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">result_maj</span><span class="p">))])</span>
        
        <span class="k">return</span> <span class="n">mmscaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">X_res</span><span class="p">),</span> <span class="n">y_res</span></div>

<div class="viewcode-block" id="SMOTE_FRST_2T.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SMOTE_FRST_2T.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;gamma_S&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_S</span><span class="p">,</span> 
                <span class="s1">&#39;gamma_M&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_M</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="AND_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AND_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">AND_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @inproceedings{and_smote,</span>
<span class="sd">                             author = {Yun, Jaesub and Ha, Jihyun and Lee, Jong-Seok},</span>
<span class="sd">                             title = {Automatic Determination of Neighborhood Size in SMOTE},</span>
<span class="sd">                             booktitle = {Proceedings of the 10th International Conference on Ubiquitous Information Management and Communication},</span>
<span class="sd">                             series = {IMCOM &#39;16},</span>
<span class="sd">                             year = {2016},</span>
<span class="sd">                             isbn = {978-1-4503-4142-4},</span>
<span class="sd">                             location = {Danang, Viet Nam},</span>
<span class="sd">                             pages = {100:1--100:8},</span>
<span class="sd">                             articleno = {100},</span>
<span class="sd">                             numpages = {8},</span>
<span class="sd">                             url = {http://doi.acm.org/10.1145/2857546.2857648},</span>
<span class="sd">                             doi = {10.1145/2857546.2857648},</span>
<span class="sd">                             acmid = {2857648},</span>
<span class="sd">                             publisher = {ACM},</span>
<span class="sd">                             address = {New York, NY, USA},</span>
<span class="sd">                             keywords = {SMOTE, imbalanced learning, synthetic data generation},</span>
<span class="sd">                            } </span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="AND_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AND_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">K</span><span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            K (int): maximum number of nearest neighbors</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">K</span><span class="p">,</span> <span class="s2">&quot;K&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="o">=</span> <span class="n">K</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="AND_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AND_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">21</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="AND_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AND_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="n">K</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">])</span>
        <span class="c1"># find K nearest neighbors of all samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">K</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="n">min_ind</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Executing the algorithm</span>
        <span class="n">kappa</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">min_ind</span><span class="p">)):</span>
            <span class="n">regions_min</span><span class="o">=</span> <span class="p">[]</span>
            <span class="n">regions_maj</span><span class="o">=</span> <span class="p">[]</span>
            
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">):</span>
                <span class="c1"># continueing if the label of the neighbors is minority</span>
                <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">min_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">j</span><span class="p">]]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                    <span class="k">continue</span>
                
                <span class="c1"># region coordinates</span>
                <span class="n">reg</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">min_ind</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ind</span><span class="p">[</span><span class="n">min_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="n">j</span><span class="p">]])</span>
                <span class="c1"># compute corner points</span>
                <span class="n">reg_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">reg</span><span class="p">])</span>
                <span class="n">reg_max</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">reg</span><span class="p">])</span>
                
                <span class="n">r_min</span><span class="o">=</span> <span class="p">[]</span>
                <span class="n">r_maj</span><span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># all the points in the region must be among the neighbors</span>
                <span class="c1"># what we do is counting how many of them are minority and majority samples</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">[</span><span class="n">min_ind</span><span class="p">[</span><span class="n">i</span><span class="p">]][:(</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)]:</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">reg_min</span> <span class="o">&lt;=</span> <span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">reg_max</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                            <span class="n">r_min</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">r_maj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                
                <span class="c1"># appending the coordinates of points to the minority and majority regions</span>
                <span class="n">regions_min</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_min</span><span class="p">)</span>
                <span class="n">regions_maj</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_maj</span><span class="p">)</span>
            
            <span class="c1"># taking the cumulative unions of minority and majority points</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">regions_min</span><span class="p">)):</span>
                <span class="n">regions_min</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">regions_min</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">regions_min</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
                <span class="n">regions_maj</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">regions_maj</span><span class="p">[</span><span class="n">j</span><span class="p">])</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">regions_maj</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">])))</span>
            
            <span class="c1"># computing the lengths of the increasing minority and majority sets</span>
            <span class="n">regions_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">regions_min</span><span class="p">])</span>
            <span class="n">regions_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">regions_maj</span><span class="p">])</span>
            
            <span class="c1"># computing the precision of minority classification (all points are supposed to</span>
            <span class="c1"># be classified as minority)</span>
            <span class="n">prec</span><span class="o">=</span> <span class="n">regions_min</span><span class="o">/</span><span class="p">(</span><span class="n">regions_min</span> <span class="o">+</span> <span class="n">regions_maj</span><span class="p">)</span>
            <span class="c1"># taking the difference</span>
            <span class="n">d</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">prec</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># finding the biggest drop (+1 because diff reduces length, +1 because of indexing begins with 0)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">k</span><span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">k</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>
            <span class="c1"># appending the coordinate of the biggest drop as the ideal neighborhood size</span>
            <span class="c1"># note that k indices the minority neighbors</span>
            <span class="n">kappa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        
        <span class="c1"># finding nearest minority neighbors of minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">kappa</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;No minority samples in nearest neighbors&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="c1"># choose random point</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">kappa</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:(</span><span class="n">kappa</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)])]))</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>

<div class="viewcode-block" id="AND_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AND_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;K&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">K</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="NRAS"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NRAS">[docs]</a><span class="k">class</span> <span class="nc">NRAS</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{nras,</span>
<span class="sd">                        title = &quot;Noise Reduction A Priori Synthetic Over-Sampling for class imbalanced data sets&quot;,</span>
<span class="sd">                        journal = &quot;Information Sciences&quot;,</span>
<span class="sd">                        volume = &quot;408&quot;,</span>
<span class="sd">                        pages = &quot;146 - 161&quot;,</span>
<span class="sd">                        year = &quot;2017&quot;,</span>
<span class="sd">                        issn = &quot;0020-0255&quot;,</span>
<span class="sd">                        doi = &quot;https://doi.org/10.1016/j.ins.2017.04.046&quot;,</span>
<span class="sd">                        url = &quot;http://www.sciencedirect.com/science/article/pii/S0020025517307089&quot;,</span>
<span class="sd">                        author = &quot;William A. Rivera&quot;,</span>
<span class="sd">                        keywords = &quot;NRAS, SMOTE, OUPS, Class imbalance, Classification&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_noise_removal</span><span class="p">]</span>
    
<div class="viewcode-block" id="NRAS.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NRAS.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">t</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            t (float): [0,1] fraction of n_neighbors as threshold</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">=</span> <span class="n">t</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="NRAS.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NRAS.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">],</span> 
                                                    <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="NRAS.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NRAS.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># standardization is needed to make the range of the propensity scores similar to that of the features</span>
        <span class="n">mms</span><span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">()</span>
        <span class="n">X_trans</span><span class="o">=</span> <span class="n">mms</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># determining propensity scores using logistic regression</span>
        <span class="n">lr</span><span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">(</span><span class="n">solver</span><span class="o">=</span> <span class="s1">&#39;lbfgs&#39;</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">lr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_trans</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">propensity</span><span class="o">=</span> <span class="n">lr</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_trans</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">lr</span><span class="o">.</span><span class="n">classes_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X_trans</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># adding propensity scores as a new feature</span>
        <span class="n">X_new</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">X_trans</span><span class="p">,</span> <span class="n">propensity</span><span class="p">])</span>
        <span class="n">X_min_new</span><span class="o">=</span> <span class="n">X_new</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># finding nearest neighbors of minority samples</span>
        <span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_new</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min_new</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">to_remove</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="c1"># finding the number of minority neighbors</span>
            <span class="n">t_hat</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t_hat</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="o">*</span><span class="n">n_neighbors</span><span class="p">:</span>
                <span class="c1"># removing the minority point if the number of minority neighbors is less then the threshold</span>
                <span class="c1"># to_remove indexes X_min</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="c1"># compensating the removal of the minority point</span>
                    <span class="n">num_to_sample</span><span class="o">=</span> <span class="n">num_to_sample</span> <span class="o">+</span> <span class="mi">1</span>
                    
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">):</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;all minority samples identified as noise&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># otherwise do the sampling</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_trans</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]))</span>
        
        <span class="c1"># remove noisy elements</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X_trans</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">mms</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_min</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)])),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>

<div class="viewcode-block" id="NRAS.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NRAS.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="AMSCO"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AMSCO">[docs]</a><span class="k">class</span> <span class="nc">AMSCO</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{amsco,</span>
<span class="sd">                        title = &quot;Adaptive multi-objective swarm fusion for imbalanced data classification&quot;,</span>
<span class="sd">                        journal = &quot;Information Fusion&quot;,</span>
<span class="sd">                        volume = &quot;39&quot;,</span>
<span class="sd">                        pages = &quot;1 - 24&quot;,</span>
<span class="sd">                        year = &quot;2018&quot;,</span>
<span class="sd">                        issn = &quot;1566-2535&quot;,</span>
<span class="sd">                        doi = &quot;https://doi.org/10.1016/j.inffus.2017.03.007&quot;,</span>
<span class="sd">                        url = &quot;http://www.sciencedirect.com/science/article/pii/S1566253517302087&quot;,</span>
<span class="sd">                        author = &quot;Jinyan Li and Simon Fong and Raymond K. Wong and Victor W. Chu&quot;,</span>
<span class="sd">                        keywords = &quot;Swarm fusion, Swarm intelligence algorithm, Multi-objective, Crossover rebalancing, Imbalanced data classification&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * It is not clear how the kappa threshold is used, I do use the RA score to drive all the evolution. Particularly:</span>
<span class="sd">            </span>
<span class="sd">            &quot;In the last phase of each iteration, the average Kappa value</span>
<span class="sd">            in current non-inferior set is compare with the latest threshold</span>
<span class="sd">            value, the threshold is then increase further if the average value</span>
<span class="sd">            increases, and vice versa. By doing so, the non-inferior region will</span>
<span class="sd">            be progressively reduced as the Kappa threshold lifts up.&quot;</span>
<span class="sd">        </span>
<span class="sd">        I don&#39;t see why would the Kappa threshold lift up if the kappa thresholds</span>
<span class="sd">        are decreased if the average Kappa decreases (&quot;vice versa&quot;).</span>
<span class="sd">    </span>
<span class="sd">        * Due to the interpretation of kappa threshold and the lack of detailed description of the SIS process, the implementation is not exactly what is described in the paper, but something very similar.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_changes_majority</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_memetic</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_classifier</span><span class="p">]</span>
    
<div class="viewcode-block" id="AMSCO.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AMSCO.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_pop</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span> <span class="mi">15</span><span class="p">,</span> <span class="n">omega</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">r1</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">r2</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">classifier</span><span class="o">=</span> <span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">),</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            n_pop (int): size of populations</span>
<span class="sd">            n_iter (int): optimization steps</span>
<span class="sd">            omega (float): intertia of PSO</span>
<span class="sd">            r1 (float): force towards local optimum</span>
<span class="sd">            r2 (float): force towards global optimum</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_pop</span><span class="p">,</span> <span class="s2">&quot;n_pop&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_iter</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="s2">&quot;omega&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="s2">&quot;r1&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">r2</span><span class="p">,</span> <span class="s2">&quot;r2&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="o">=</span> <span class="n">n_pop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="o">=</span> <span class="n">n_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="o">=</span> <span class="n">omega</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r1</span><span class="o">=</span> <span class="n">r1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r2</span><span class="o">=</span> <span class="n">r2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">=</span> <span class="n">classifier</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="AMSCO.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AMSCO.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># as the method is an overall optimization, 1 reasonable settings should</span>
        <span class="c1"># be enough</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;n_pop&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">15</span><span class="p">],</span> 
                                                    <span class="s1">&#39;omega&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">],</span> 
                                                    <span class="s1">&#39;r1&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">],</span> 
                                                    <span class="s1">&#39;r2&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">],</span> 
                                                    <span class="s1">&#39;classifier&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">DecisionTreeClassifier</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">)]})</span></div>
    
<div class="viewcode-block" id="AMSCO.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AMSCO.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>

        <span class="n">n_cross_val</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)])</span>
        
        <span class="k">def</span> <span class="nf">fitness</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculating fitness function</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                X_min (np.matrix): minority samples</span>
<span class="sd">                X_maj (np.matrix): majority samples</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                float, float: kappa, accuracy</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">kfold</span><span class="o">=</span> <span class="n">StratifiedKFold</span><span class="p">(</span><span class="n">n_cross_val</span><span class="p">)</span>
            
            <span class="c1"># prepare assembled dataset</span>
            <span class="n">X_ass</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">])</span>
            <span class="n">y_ass</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">))])</span>
            
            <span class="n">preds</span><span class="o">=</span> <span class="p">[]</span>
            <span class="n">tests</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">kfold</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">X_ass</span><span class="p">,</span> <span class="n">y_ass</span><span class="p">):</span>
                <span class="c1">#preds.append(KNeighborsClassifier(n_neighbors= 1).fit(X_ass[train], y_ass[train]).predict(X))</span>
                <span class="n">preds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_ass</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">y_ass</span><span class="p">[</span><span class="n">train</span><span class="p">])</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
                <span class="n">tests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
            <span class="n">preds</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span>
            <span class="n">tests</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">tests</span><span class="p">)</span>
            
            <span class="c1"># calculate kappa and accuracy scores</span>
            <span class="n">tp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">preds</span> <span class="o">==</span> <span class="n">tests</span><span class="p">,</span> <span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">))</span>
            <span class="n">fn</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">preds</span> <span class="o">!=</span> <span class="n">tests</span><span class="p">,</span> <span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">))</span>
            <span class="n">tn</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">preds</span> <span class="o">==</span> <span class="n">tests</span><span class="p">,</span> <span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">))</span>
            <span class="n">fp</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">preds</span> <span class="o">!=</span> <span class="n">tests</span><span class="p">,</span> <span class="n">tests</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">))</span>
            
            <span class="n">p_o</span><span class="o">=</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">tn</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span> <span class="o">+</span> <span class="n">tn</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span>
            <span class="n">p_e</span><span class="o">=</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span> <span class="o">+</span> <span class="n">tn</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">fp</span> <span class="o">+</span> <span class="n">tn</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">fn</span> <span class="o">+</span> <span class="n">tn</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span> <span class="o">+</span> <span class="n">tn</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            
            <span class="n">kappa</span><span class="o">=</span> <span class="p">(</span><span class="n">p_o</span> <span class="o">-</span> <span class="n">p_e</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">p_e</span><span class="p">)</span>
            <span class="n">accuracy</span><span class="o">=</span> <span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">tn</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">tp</span> <span class="o">+</span> <span class="n">fn</span> <span class="o">+</span> <span class="n">tn</span> <span class="o">+</span> <span class="n">fp</span><span class="p">)</span>
            
            <span class="k">return</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">accuracy</span>
        
        <span class="k">def</span> <span class="nf">OSMOTE</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Executing OSMOTE phase</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                X_min (np.matrix): minority samples</span>
<span class="sd">                X_maj (np.matrix): majority samples</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                np.matrix, np.matrix: new minority and majority datasets</span>
<span class="sd">            &quot;&quot;&quot;</span>
            
            <span class="c1"># initialize particles, first coordinate represents proportion parameter of SMOTE</span>
            <span class="c1"># the second coordinate represents the number of neighbors to take into consideration</span>
            <span class="n">particles</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">/</span><span class="mf">2.0</span><span class="o">+</span><span class="mf">0.5</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="c1"># velocities initialized</span>
            <span class="n">velocities</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="c1"># setting the limits of the search space</span>
            <span class="n">limits</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.25</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">4.0</span><span class="p">,</span> <span class="mi">10</span><span class="p">])]</span>
            <span class="c1"># local best results</span>
            <span class="n">local_best</span><span class="o">=</span> <span class="p">[</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="c1"># local best scores</span>
            <span class="n">local_score</span><span class="o">=</span> <span class="p">[(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span>
            <span class="c1"># global best result</span>
            <span class="n">global_best</span><span class="o">=</span> <span class="n">particles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># global best score</span>
            <span class="n">global_score</span><span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="c1"># best dataset</span>
            <span class="n">best_dataset</span><span class="o">=</span> <span class="kc">None</span>
            
            <span class="c1"># running the optimization</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">):</span>
                <span class="c1"># update velocities</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">velocities</span><span class="p">)):</span>
                    <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">omega</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">r1</span><span class="o">*</span><span class="p">(</span><span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">r2</span><span class="o">*</span><span class="p">(</span><span class="n">global_best</span> <span class="o">-</span> <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="c1"># clipping velocities using the upper bounds of the particle search space</span>
                    <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                    <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
                        
                <span class="c1"># update particles</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">particles</span><span class="p">)):</span>
                    <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">velocities</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="c1"># clipping the particle positions using the lower and upper bounds</span>
                    <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">limits</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                
                <span class="c1"># evaluate</span>
                <span class="n">scores</span><span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">particles</span><span class="p">)):</span>
                    <span class="c1"># apply SMOTE</span>
                    <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">])),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_min</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))]))</span>
                    <span class="c1"># evaluate</span>
                    <span class="n">scores</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fitness</span><span class="p">(</span><span class="n">X_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">):],</span> <span class="n">X_samp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)]))</span>
                    <span class="c1"># update scores according to the multiobjective setting</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">local_score</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">local_score</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">local_best</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">local_score</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">global_score</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">global_score</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">global_best</span><span class="o">=</span> <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">global_score</span><span class="o">=</span> <span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">best_dataset</span><span class="o">=</span> <span class="p">(</span><span class="n">X_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">):],</span> <span class="n">X_samp</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)])</span>

            <span class="k">return</span> <span class="n">best_dataset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">best_dataset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            
        <span class="k">def</span> <span class="nf">SIS</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            SIS procedure</span>
<span class="sd">            </span>
<span class="sd">            Args:</span>
<span class="sd">                X_min (np.matrix): minority dataset</span>
<span class="sd">                X_maj (np.matrix): majority dataset</span>
<span class="sd">                </span>
<span class="sd">            Returns:</span>
<span class="sd">                np.matrix, np.matrix: new minority and majority datasets</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">min_num</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
            <span class="n">max_num</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">min_num</span> <span class="o">&gt;=</span> <span class="n">max_num</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj</span>
            
            <span class="c1"># initiate particles</span>
            <span class="n">particles</span><span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">min_num</span><span class="p">,</span> <span class="n">max_num</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="n">scores</span><span class="o">=</span> <span class="p">[</span><span class="n">fitness</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">[</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="n">best_score</span><span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="n">best_dataset</span><span class="o">=</span> <span class="kc">None</span>
            
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">):</span>
                <span class="c1"># mutate and evaluate</span>
                <span class="c1"># the way mutation or applying PSO is not described in the paper in details</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">):</span>
                    <span class="c1"># removing some random elements</span>
                    <span class="n">to_remove</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">])),</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">])])))</span>
                    <span class="n">mutant</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">to_remove</span><span class="p">)</span>
                    <span class="c1"># adding some random elements</span>
                    <span class="n">diff</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">])))</span>
                    <span class="n">mutant</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">mutant</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">diff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">)]))))])</span>
                    <span class="c1"># evaluating the variant</span>
                    <span class="n">score</span><span class="o">=</span> <span class="n">fitness</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">[</span><span class="n">mutant</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">particles</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">mutant</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">scores</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">score</span>
                    <span class="k">if</span> <span class="n">score</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">best_score</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">best_score</span><span class="o">=</span> <span class="n">score</span>
                        <span class="n">best_dataset</span><span class="o">=</span> <span class="n">mutant</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">X_min</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">[</span><span class="n">best_dataset</span><span class="p">]</span>
        
        <span class="c1"># executing the main optimization procedure</span>
        <span class="n">current_min</span><span class="o">=</span> <span class="n">X_min</span>
        <span class="n">current_maj</span><span class="o">=</span> <span class="n">X_maj</span>
        <span class="k">for</span> <span class="n">it</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s1">&#39;staring iteration </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">it</span><span class="p">)</span>
            <span class="n">new_min</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span> <span class="n">OSMOTE</span><span class="p">(</span><span class="n">X_min</span><span class="p">,</span> <span class="n">current_maj</span><span class="p">)</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">new_maj</span><span class="o">=</span> <span class="n">SIS</span><span class="p">(</span><span class="n">current_min</span><span class="p">,</span> <span class="n">X_maj</span><span class="p">)</span>
            
            <span class="c1"># calculating fitness values of the four combinations</span>
            <span class="n">fitness_0</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">fitness</span><span class="p">(</span><span class="n">new_min</span><span class="p">,</span> <span class="n">current_maj</span><span class="p">))</span>
            <span class="n">fitness_1</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">fitness</span><span class="p">(</span><span class="n">current_min</span><span class="p">,</span> <span class="n">current_maj</span><span class="p">))</span>
            <span class="n">fitness_2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">fitness</span><span class="p">(</span><span class="n">new_min</span><span class="p">,</span> <span class="n">new_maj</span><span class="p">))</span>
            <span class="n">fitness_3</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">fitness</span><span class="p">(</span><span class="n">current_min</span><span class="p">,</span> <span class="n">new_maj</span><span class="p">))</span>
            
            <span class="c1"># selecting the new current_maj and current_min datasets</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s1">&#39;fitness scores: </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1"> </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fitness_0</span><span class="p">,</span> <span class="n">fitness_1</span><span class="p">,</span> <span class="n">fitness_2</span><span class="p">,</span> <span class="n">fitness_3</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">fitness_2</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">fitness_0</span><span class="p">,</span> <span class="n">fitness_1</span><span class="p">,</span> <span class="n">fitness_2</span><span class="p">,</span> <span class="n">fitness_3</span><span class="p">])</span> <span class="ow">or</span> <span class="n">fitness_3</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">fitness_0</span><span class="p">,</span> <span class="n">fitness_1</span><span class="p">,</span> <span class="n">fitness_2</span><span class="p">,</span> <span class="n">fitness_3</span><span class="p">]):</span>
                <span class="n">current_maj</span><span class="o">=</span> <span class="n">new_maj</span>
            <span class="k">if</span> <span class="n">fitness_0</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">fitness_0</span><span class="p">,</span> <span class="n">fitness_1</span><span class="p">,</span> <span class="n">fitness_2</span><span class="p">,</span> <span class="n">fitness_3</span><span class="p">])</span> <span class="ow">or</span> <span class="n">fitness_2</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">fitness_0</span><span class="p">,</span> <span class="n">fitness_1</span><span class="p">,</span> <span class="n">fitness_2</span><span class="p">,</span> <span class="n">fitness_3</span><span class="p">]):</span>
                <span class="n">current_min</span><span class="o">=</span> <span class="n">new_min</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">current_maj</span><span class="p">,</span> <span class="n">current_min</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">current_min</span><span class="p">))])</span></div>

<div class="viewcode-block" id="AMSCO.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.AMSCO.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;n_pop&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">,</span> 
                <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> 
                <span class="s1">&#39;omega&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> 
                <span class="s1">&#39;r1&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">r1</span><span class="p">,</span> 
                <span class="s1">&#39;r2&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">r2</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> 
                <span class="s1">&#39;classifier&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SSO"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SSO">[docs]</a><span class="k">class</span> <span class="nc">SSO</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @InProceedings{sso,</span>
<span class="sd">                            author=&quot;Rong, Tongwen</span>
<span class="sd">                            and Gong, Huachang</span>
<span class="sd">                            and Ng, Wing W. Y.&quot;,</span>
<span class="sd">                            editor=&quot;Wang, Xizhao</span>
<span class="sd">                            and Pedrycz, Witold</span>
<span class="sd">                            and Chan, Patrick</span>
<span class="sd">                            and He, Qiang&quot;,</span>
<span class="sd">                            title=&quot;Stochastic Sensitivity Oversampling Technique for Imbalanced Data&quot;,</span>
<span class="sd">                            booktitle=&quot;Machine Learning and Cybernetics&quot;,</span>
<span class="sd">                            year=&quot;2014&quot;,</span>
<span class="sd">                            publisher=&quot;Springer Berlin Heidelberg&quot;,</span>
<span class="sd">                            address=&quot;Berlin, Heidelberg&quot;,</span>
<span class="sd">                            pages=&quot;161--171&quot;,</span>
<span class="sd">                            abstract=&quot;Data level technique is proved to be effective in imbalance learning. The SMOTE is a famous oversampling technique generating synthetic minority samples by linear interpolation between adjacent minorities. However, it becomes inefficiency for datasets with sparse distributions. In this paper, we propose the Stochastic Sensitivity Oversampling (SSO) which generates synthetic samples following Gaussian distributions in the Q-union of minority samples. The Q-union is the union of Q-neighborhoods (hypercubes centered at minority samples) and such that new samples are synthesized around minority samples. Experimental results show that the proposed algorithm performs well on most of datasets, especially those with a sparse distribution.&quot;,</span>
<span class="sd">                            isbn=&quot;978-3-662-45652-1&quot;</span>
<span class="sd">                            }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * In the algorithm step 2d adds a constant to a vector. I have changed it to a componentwise adjustment, and also used the normalized STSM as I don&#39;t see any reason why it would be some reasonable, bounded value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_classifier</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_based</span><span class="p">]</span>
    
<div class="viewcode-block" id="SSO.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SSO.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            h (int): number of hidden units</span>
<span class="sd">            n_iter (int): optimization steps</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_iter</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="o">=</span> <span class="n">h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="o">=</span> <span class="n">n_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SSO.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SSO.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">],</span> 
                                                    <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">5</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SSO.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SSO.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># number of samples to generate in each iteration</span>
        <span class="n">samp_per_iter</span><span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">)])</span>
        
        <span class="c1"># executing the algorithm</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">):</span>
            <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
            
            <span class="c1"># applying kmeans clustering to find the hidden neurons</span>
            <span class="n">h</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)])</span>
            <span class="n">kmeans</span><span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="n">h</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
            <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            
            <span class="c1"># extracting the hidden center elements</span>
            <span class="n">u</span><span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span>
            
            <span class="c1"># extracting scale parameters as the distances of closest centers</span>
            <span class="n">nn_cent</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn_cent</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">dist_cent</span><span class="p">,</span> <span class="n">ind_cent</span><span class="o">=</span> <span class="n">nn_cent</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
            <span class="n">v</span><span class="o">=</span> <span class="n">dist_cent</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="c1"># computing the response of the hidden units</span>
            <span class="n">phi</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
            <span class="n">phi</span><span class="o">=</span> <span class="n">phi</span><span class="o">**</span><span class="mi">2</span>
            <span class="n">phi</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">phi</span><span class="o">/</span><span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            
            <span class="c1"># applying linear regression to find the best weights</span>
            <span class="n">lr</span><span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
            <span class="n">lr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="n">f</span><span class="o">=</span> <span class="n">lr</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">phi</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">w</span><span class="o">=</span> <span class="n">lr</span><span class="o">.</span><span class="n">coef_</span>
            
            <span class="k">def</span> <span class="nf">eq_6</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Equation 6 in the paper</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">tmp_sum</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">h</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
                    <span class="n">a</span><span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">Q</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">b</span><span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">Q</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">tmp_prod</span><span class="o">=</span> <span class="p">(</span><span class="n">sspecial</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">sspecial</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
                    <span class="n">tmp_sum</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">tmp_prod</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">tmp_sum</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">Q</span><span class="p">)</span><span class="o">**</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            
            <span class="k">def</span> <span class="nf">eq_8</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">                Equation 8 in the paper</span>
<span class="sd">                &quot;&quot;&quot;</span>
                <span class="n">res</span><span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
                    <span class="n">vi2</span><span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
                    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
                        <span class="n">vr2</span><span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
                        <span class="n">a1</span><span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">vi2</span><span class="o">*</span><span class="n">vr2</span><span class="o">*</span><span class="p">(</span><span class="n">vi2</span> <span class="o">+</span> <span class="n">vr2</span><span class="p">)))</span>
                        
                        <span class="n">a00_v</span><span class="o">=</span> <span class="p">(</span><span class="n">vi2</span> <span class="o">+</span> <span class="n">vr2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">Q</span><span class="p">)</span>
                        <span class="n">a01_v</span><span class="o">=</span> <span class="n">vi2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">vr2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="n">a0_v</span><span class="o">=</span> <span class="n">a00_v</span> <span class="o">-</span> <span class="n">a01_v</span>
                        <span class="n">a_v</span><span class="o">=</span> <span class="n">a0_v</span><span class="o">/</span><span class="n">a1</span>
                        
                        <span class="n">b_v</span><span class="o">=</span> <span class="p">((</span><span class="n">vi2</span> <span class="o">+</span> <span class="n">vr2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">Q</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">vi2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">vr2</span><span class="o">*</span><span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span><span class="o">/</span><span class="n">a1</span>
                        <span class="n">tmp_prod</span><span class="o">=</span> <span class="n">sspecial</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">a_v</span><span class="p">)</span> <span class="o">-</span> <span class="n">sspecial</span><span class="o">.</span><span class="n">erf</span><span class="p">(</span><span class="n">b_v</span><span class="p">)</span>
                        
                        <span class="n">tmp_a</span><span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">vi2</span><span class="o">*</span><span class="n">vr2</span><span class="o">*</span><span class="p">(</span><span class="n">vi2</span> <span class="o">+</span> <span class="n">vr2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">vi2</span> <span class="o">+</span> <span class="n">vr2</span><span class="p">))</span><span class="o">**</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                        <span class="n">tmp_b</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">u</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="n">u</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">vi2</span> <span class="o">+</span> <span class="n">vr2</span><span class="p">))</span>
                        <span class="n">res</span><span class="o">=</span> <span class="n">res</span> <span class="o">+</span> <span class="n">tmp_a</span><span class="o">*</span><span class="n">tmp_b</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">tmp_prod</span><span class="p">)</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">w</span><span class="p">[</span><span class="n">r</span><span class="p">]</span>
                    
                <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">Q</span><span class="p">))</span><span class="o">**</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">res</span>
            
            <span class="c1"># applying nearest neighbors to extract Q values</span>
            <span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)])</span>
            <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
            
            <span class="n">Q</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">[:,</span><span class="n">n_neighbors</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
            
            <span class="c1"># calculating the sensitivity factors</span>
            <span class="n">I_1</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">eq_6</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_min</span><span class="p">])</span>
            <span class="n">I_2</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">eq_8</span><span class="p">(</span><span class="n">Q</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">X_min</span><span class="p">])</span>
            
            <span class="n">stsm</span><span class="o">=</span> <span class="n">f</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">I_1</span> <span class="o">+</span> <span class="n">I_2</span>
            
            <span class="c1"># calculating the sampling weights</span>
            <span class="n">weights</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stsm</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">stsm</span><span class="p">))</span>
        
            <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
            <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
            <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samp_per_iter</span><span class="p">):</span>
                <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">weights</span><span class="p">)</span>
                <span class="n">X_new</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_new</span><span class="p">)):</span>
                    <span class="n">lam</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">]))</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">weights</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
                    <span class="n">X_new</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">=</span> <span class="n">X_new</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">+</span> <span class="n">Q</span><span class="o">*</span><span class="n">lam</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_new</span><span class="p">)</span>
            
            <span class="n">samples</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="n">X</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">samples</span><span class="p">])</span>
            <span class="n">y</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span>
                    
        <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>

<div class="viewcode-block" id="SSO.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SSO.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;h&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">h</span><span class="p">,</span> 
                <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="NDO_sampling"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NDO_sampling">[docs]</a><span class="k">class</span> <span class="nc">NDO_sampling</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{ndo_sampling, </span>
<span class="sd">                            author={Zhang, L. and Wang, W.}, </span>
<span class="sd">                            booktitle={2011 International Conference of Information Technology, Computer Engineering and Management Sciences}, </span>
<span class="sd">                            title={A Re-sampling Method for Class Imbalance Learning with Credit Data}, </span>
<span class="sd">                            year={2011}, </span>
<span class="sd">                            volume={1}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={393-397}, </span>
<span class="sd">                            keywords={data handling;sampling methods;resampling method;class imbalance learning;credit rating;imbalance problem;synthetic minority over-sampling technique;sample distribution;synthetic samples;credit data set;Training;Measurement;Support vector machines;Logistics;Testing;Noise;Classification algorithms;class imbalance;credit rating;SMOTE;sample distribution}, </span>
<span class="sd">                            doi={10.1109/ICM.2011.34}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={Sept}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_application</span><span class="p">]</span>
    
<div class="viewcode-block" id="NDO_sampling.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NDO_sampling.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">T</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            T (float): threshold parameter</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="o">=</span> <span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="NDO_sampling.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NDO_sampling.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="NDO_sampling.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NDO_sampling.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># fitting nearest neighbors model to find the neighbors of minority samples among all elements</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">+</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># calculating the distances between samples in the same and different classes</span>
        <span class="n">d_intra</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">d_exter</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)):</span>
            <span class="n">min_mask</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">maj_mask</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">min_mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d_intra</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:][</span><span class="n">min_mask</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">maj_mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d_exter</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">:][</span><span class="n">maj_mask</span><span class="p">]))</span>
        <span class="n">d_intra_mean</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d_intra</span><span class="p">))</span>
        <span class="n">d_exter_mean</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">d_exter</span><span class="p">))</span>
        
        <span class="c1"># calculating the alpha value</span>
        <span class="n">alpha</span><span class="o">=</span> <span class="n">d_intra_mean</span><span class="o">/</span><span class="n">d_exter_mean</span>
        
        <span class="c1"># deciding if SMOTE is enough</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SMOTE</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="c1"># create sample close to the initial minority point</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">:</span>
                <span class="c1"># create another sample close to the neighboring minority point</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">X</span><span class="p">[</span><span class="n">random_idx</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">/</span><span class="mf">2.0</span><span class="p">)</span>
                    
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>

<div class="viewcode-block" id="NDO_sampling.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.NDO_sampling.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<span class="k">class</span> <span class="nc">RBFNeuron</span><span class="p">(</span><span class="n">RandomStateMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class abstracts a neuron of an RBF network</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">O</span><span class="p">,</span> <span class="n">ranges</span><span class="p">,</span> <span class="n">range_mins</span><span class="p">,</span> <span class="n">init_conn_mask</span><span class="p">,</span> <span class="n">init_conn_weights</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the neuron</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            c (np.array): center of the hidden unit</span>
<span class="sd">            I (float): upper bound on the absolute values of input weights</span>
<span class="sd">            O (float): upper bound on the absolute values of output weights</span>
<span class="sd">            ranges (np.array): ranges widths of parameters</span>
<span class="sd">            range_min (np.array): lower bounds of parameter ranges</span>
<span class="sd">            init_conn_mask (np.array): initial input connections</span>
<span class="sd">            init_conn_weights (np.array): initial weights of input connections</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">=</span> <span class="n">c</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">=</span> <span class="n">I</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">O</span><span class="o">=</span> <span class="n">O</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_conn_mask</span><span class="o">=</span> <span class="n">init_conn_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_conn_weights</span><span class="o">=</span> <span class="n">init_conn_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="o">=</span> <span class="n">ranges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_mins</span><span class="o">=</span> <span class="n">range_mins</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">O</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span> <span class="n">init_conn_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_weights</span><span class="o">=</span> <span class="n">init_conn_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
    
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clones the neuron</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            RBFNeuron: an identical neuron</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span><span class="o">=</span> <span class="n">RBFNeuron</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">O</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_mins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_conn_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_conn_weights</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">beta</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span>
        <span class="n">r</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">r</span><span class="o">.</span><span class="n">input_weights</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_weights</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">r</span><span class="o">.</span><span class="n">r</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span>
        
        <span class="k">return</span> <span class="n">r</span>
    
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the system on dataset X</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): dataset to evaluate on</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.array: the output of the network</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wX</span><span class="o">=</span> <span class="n">X</span><span class="p">[:,</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">]</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">input_weights</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">wX</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">mutate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mutates the neuron</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">:</span>
            <span class="c1"># centre creep</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.4</span><span class="p">:</span>
            <span class="c1"># radius creep</span>
            <span class="n">tmp</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">=</span> <span class="n">tmp</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.6</span><span class="p">:</span>
            <span class="c1"># randomize centers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">c</span><span class="p">))</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_mins</span>
        <span class="k">elif</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.8</span><span class="p">:</span>
            <span class="c1"># randomize radii </span>
            <span class="bp">self</span><span class="o">.</span><span class="n">r</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># randomize output weight</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">O</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">add_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a random input connection to the neuron</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">d</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">tolist</span><span class="p">())))))])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_weights</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">input_weights</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">])</span>
            
    <span class="k">def</span> <span class="nf">delete_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deletes a random input connection</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">input_weights</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">input_weights</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
    
<span class="k">class</span> <span class="nc">RBF</span><span class="p">(</span><span class="n">RandomStateMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RBF network abstraction</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">m_min</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">O</span><span class="p">,</span> <span class="n">init_conn_mask</span><span class="p">,</span> <span class="n">init_conn_weights</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes the RBF network</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.matrix): dataset to work with</span>
<span class="sd">            m_min (int): minimum number of hidden neurons</span>
<span class="sd">            m_max (int): maximum number of hidden neurons</span>
<span class="sd">            I (float): maximum absolute value of input weights</span>
<span class="sd">            O (float): maximum absolute value of output weights</span>
<span class="sd">            init_conn_mask (np.array): initial input connections</span>
<span class="sd">            init_conn_weights (np.array): initial input weights</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">=</span> <span class="n">X</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_min</span><span class="o">=</span> <span class="n">m_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_max</span><span class="o">=</span> <span class="n">m_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">=</span> <span class="n">I</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">O</span><span class="o">=</span> <span class="n">O</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_conn_mask</span><span class="o">=</span> <span class="n">init_conn_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_conn_weights</span><span class="o">=</span> <span class="n">init_conn_weights</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">range_mins</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_mins</span>
        
        <span class="c1"># adding initial neurons</span>
        <span class="n">num_neurons</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="n">m_min</span><span class="p">,</span> <span class="n">m_max</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_neurons</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">create_new_node</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">beta_0</span><span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">O</span>
    
    <span class="k">def</span> <span class="nf">clone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clones the entire network</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            RBF: the cloned network</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span><span class="o">=</span> <span class="n">RBF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">O</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_conn_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_conn_weights</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">neurons</span><span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="p">]</span>
        <span class="n">r</span><span class="o">.</span><span class="n">range_mins</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_mins</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">r</span><span class="o">.</span><span class="n">ranges</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">r</span><span class="o">.</span><span class="n">beta_0</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_0</span>
        
        <span class="k">return</span> <span class="n">r</span>
    
    <span class="k">def</span> <span class="nf">create_new_node</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new node.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            RBFNeuron: a new hidden neuron</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">RBFNeuron</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">))],</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">O</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ranges</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">range_mins</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_conn_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_conn_weights</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">update_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the data to work with</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="o">=</span> <span class="n">X</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="p">:</span>
            <span class="n">n</span><span class="o">.</span><span class="n">X</span><span class="o">=</span> <span class="n">X</span>
    
    <span class="k">def</span> <span class="nf">improve_centers</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Improves the center locations by kmeans clustering</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kmeans</span><span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="p">),</span> <span class="n">init</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">c</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="p">]),</span> <span class="n">n_init</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_iter</span><span class="o">=</span> <span class="mi">30</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">c</span><span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">cluster_centers_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    
    <span class="k">def</span> <span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the target function</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float: the target function value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">beta_0</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">X</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">neurons</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">L_star</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">f</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">L_star</span>
    
    <span class="k">def</span> <span class="nf">mutation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mutates the neurons</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            RBF: a new, mutated RBF network</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rbf</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">:</span>
            <span class="n">n</span><span class="o">.</span><span class="n">mutate</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">rbf</span>
            
    <span class="k">def</span> <span class="nf">structural_mutation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies structural mutation</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            RBF: a new, structurally mutated network</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># in the binary case the removal of output connections is the same as</span>
        <span class="c1"># removing hidden nodes</span>
        <span class="n">rbf</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="n">r</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">rbf</span><span class="o">.</span><span class="n">m_max</span><span class="p">:</span>
                <span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rbf</span><span class="o">.</span><span class="n">create_new_node</span><span class="p">())</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">rbf</span><span class="o">.</span><span class="n">m_min</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">))]</span><span class="o">.</span><span class="n">delete_connection</span><span class="p">()</span>
            <span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">))]</span><span class="o">.</span><span class="n">add_connection</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="n">rbf</span>
            
    <span class="k">def</span> <span class="nf">recombine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rbf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recombines two networks</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rbf (RBF): another network</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            RBF: the result of recombination</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the order of neurons doesn&#39;t matter, so the logic can be simplified</span>
        <span class="n">new</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">new_neurons_0</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">neurons</span><span class="p">)))</span>
            <span class="n">new_neurons_1</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">)))</span>
            <span class="n">new</span><span class="o">.</span><span class="n">neurons</span><span class="o">=</span> <span class="p">[</span><span class="n">n</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">new_neurons_0</span><span class="p">]</span>
            <span class="n">new</span><span class="o">.</span><span class="n">neurons</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">n</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">new_neurons_1</span><span class="p">])</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">neurons</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_max</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">new</span><span class="o">.</span><span class="n">neurons</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">neurons</span><span class="p">))]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">neurons</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">:</span>
                    <span class="n">new</span><span class="o">.</span><span class="n">neurons</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">rbf</span><span class="o">.</span><span class="n">neurons</span><span class="p">))]</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">new</span>

<div class="viewcode-block" id="DSRBF"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DSRBF">[docs]</a><span class="k">class</span> <span class="nc">DSRBF</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{dsrbf,</span>
<span class="sd">                        title = &quot;A dynamic over-sampling procedure based on sensitivity for multi-class problems&quot;,</span>
<span class="sd">                        journal = &quot;Pattern Recognition&quot;,</span>
<span class="sd">                        volume = &quot;44&quot;,</span>
<span class="sd">                        number = &quot;8&quot;,</span>
<span class="sd">                        pages = &quot;1821 - 1833&quot;,</span>
<span class="sd">                        year = &quot;2011&quot;,</span>
<span class="sd">                        issn = &quot;0031-3203&quot;,</span>
<span class="sd">                        doi = &quot;https://doi.org/10.1016/j.patcog.2011.02.019&quot;,</span>
<span class="sd">                        url = &quot;http://www.sciencedirect.com/science/article/pii/S0031320311000823&quot;,</span>
<span class="sd">                        author = &quot;Francisco Fernández-Navarro and César Hervás-Martínez and Pedro Antonio Gutiérrez&quot;,</span>
<span class="sd">                        keywords = &quot;Classification, Multi-class, Sensitivity, Accuracy, Memetic algorithm, Imbalanced datasets, Over-sampling method, SMOTE&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * It is not entirely clear why J-1 output is supposed where J is the number of classes.</span>
<span class="sd">        * The fitness function is changed to a balanced mean loss, as I found that it just ignores classification on minority samples (class label +1) in the binary case.</span>
<span class="sd">        * The iRprop+ optimization is not implemented.</span>
<span class="sd">        * The original paper proposes using SMOTE incrementally. Instead of that, this implementation applies SMOTE to generate all samples needed in the sampling epochs and the evolution of RBF networks is used to select the sampling providing the best results.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_classifier</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_memetic</span><span class="p">]</span>
    
<div class="viewcode-block" id="DSRBF.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DSRBF.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">m_min</span><span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="n">m_max</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">I</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">O</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_pop</span><span class="o">=</span> <span class="mi">500</span><span class="p">,</span> <span class="n">n_init_pop</span><span class="o">=</span> <span class="mi">5000</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span> <span class="mi">40</span><span class="p">,</span> <span class="n">n_sampling_epoch</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in the SMOTE sampling</span>
<span class="sd">            m_min (int): minimum number of hidden units</span>
<span class="sd">            m_max (int): maximum number of hidden units</span>
<span class="sd">            I (float): input weight range</span>
<span class="sd">            O (float): output weight range</span>
<span class="sd">            n_pop (int): size of population</span>
<span class="sd">            n_init_pop (int): size of initial population</span>
<span class="sd">            n_iter (int): number of iterations</span>
<span class="sd">            n_sampling_epoch (int): resampling after this many iterations</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">m_min</span><span class="p">,</span> <span class="s2">&quot;m_min&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">m_max</span><span class="p">,</span> <span class="s2">&quot;m_max&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="s2">&quot;I&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_pop</span><span class="p">,</span> <span class="s2">&quot;n_pop&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_init_pop</span><span class="p">,</span> <span class="s2">&quot;n_pop&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_iter</span><span class="p">,</span> <span class="s2">&quot;n_iter&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_sampling_epoch</span><span class="p">,</span> <span class="s2">&quot;n_sampling_epoch&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_min</span><span class="o">=</span> <span class="n">m_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_max</span><span class="o">=</span> <span class="n">m_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="o">=</span> <span class="n">I</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">O</span><span class="o">=</span> <span class="n">O</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="o">=</span> <span class="n">n_pop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_init_pop</span><span class="o">=</span> <span class="n">n_init_pop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="o">=</span> <span class="n">n_iter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_sampling_epoch</span><span class="o">=</span> <span class="n">n_sampling_epoch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="DSRBF.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DSRBF.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># as the technique optimizes, it is unnecessary to check various combinations</span>
        <span class="c1"># except one specifying a decent workspace with a large number of iterations</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;m_min&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">4</span><span class="p">],</span> 
                                                    <span class="s1">&#39;m_max&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">10</span><span class="p">],</span> 
                                                    <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_pop&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">100</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_init_pop&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1000</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">40</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_sampling_epoch&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">8</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="DSRBF.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DSRBF.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Standardizing the data to let the network work with comparable attributes</span>
        <span class="n">ss</span><span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="n">X</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">X_orig</span><span class="o">=</span> <span class="n">X</span>
        <span class="n">y_orig</span><span class="o">=</span> <span class="n">y</span>
        
        <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># generate initial connections and weights randomly</span>
        <span class="n">init_conn_mask</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">init_conn_weights</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">random_sample</span><span class="p">(</span><span class="n">size</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">init_conn_mask</span><span class="p">))</span>
        
        <span class="c1"># setting epoch lengths</span>
        <span class="n">epoch_len</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">n_sampling_epoch</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_orig</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_min</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X_orig</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y_orig</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">m_max</span><span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_orig</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_max</span><span class="p">)</span>
        
        <span class="c1"># generating initial population</span>
        <span class="n">population</span><span class="o">=</span> <span class="p">[</span><span class="n">RBF</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_min</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">O</span><span class="p">,</span> <span class="n">init_conn_mask</span><span class="p">,</span> <span class="n">init_conn_weights</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_init_pop</span><span class="p">)]</span>
        <span class="n">population</span><span class="o">=</span> <span class="p">[[</span><span class="n">p</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">population</span><span class="p">]</span>
        <span class="n">population</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">([[</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">population</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">population</span><span class="o">=</span> <span class="n">population</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">]</span>
        
        <span class="c1"># executing center improval in the hidden units</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">population</span><span class="p">:</span>
            <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">improve_centers</span><span class="p">()</span>
        
        <span class="c1"># executing the optimization process</span>
        <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Iteration </span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2">, loss: </span><span class="si">%f</span><span class="s2">, data size </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">iteration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> <span class="n">population</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">3</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">population</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])))</span>
            <span class="c1"># evaluating non-evaluated elements</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">population</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                    <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            
            <span class="c1"># sorting the population by the loss values</span>
            <span class="n">population</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">population</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="n">population</span><span class="o">=</span> <span class="n">population</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">]</span>
            
            <span class="c1"># determining the number of elements to be changed</span>
            <span class="n">p_best</span><span class="o">=</span> <span class="n">population</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">p_parametric_mut</span><span class="o">=</span> <span class="n">population</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
            <span class="n">p_structural_mut</span><span class="o">=</span> <span class="n">population</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.9</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
            <span class="n">p_recombination</span><span class="o">=</span> <span class="n">population</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">)]</span>
            
            <span class="c1"># executing mutation</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_parametric_mut</span><span class="p">:</span>
                <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mutation</span><span class="p">(),</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
            
            <span class="c1"># executing structural mutation</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_structural_mut</span><span class="p">:</span>
                <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">structural_mutation</span><span class="p">(),</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
            
            <span class="c1"># executing recombination</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">p_recombination</span><span class="p">:</span>
                <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">recombine</span><span class="p">(</span><span class="n">p_recombination</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p_recombination</span><span class="p">))][</span><span class="mi">0</span><span class="p">]),</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
            
            <span class="c1"># do the sampling</span>
            <span class="k">if</span> <span class="n">iteration</span> <span class="o">%</span> <span class="n">epoch_len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X_orig</span><span class="p">,</span> <span class="n">y_orig</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">):</span>
                    <span class="n">tmp</span><span class="o">=</span> <span class="p">[</span><span class="n">population</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clone</span><span class="p">(),</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">update_data</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
                    <span class="n">tmp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">improve_centers</span><span class="p">()</span>
                    <span class="n">population</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
        
        <span class="c1"># evaluate unevaluated elements of the population</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">population</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">:</span>
                <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        
        <span class="c1"># sorting the population</span>
        <span class="n">population</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">population</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">])[:</span><span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">]</span>
            
        <span class="k">return</span> <span class="n">ss</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">p_best</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">p_best</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span></div>

<div class="viewcode-block" id="DSRBF.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.DSRBF.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;m_min&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_min</span><span class="p">,</span> 
                <span class="s1">&#39;m_max&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_max</span><span class="p">,</span> 
                <span class="s1">&#39;I&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">I</span><span class="p">,</span> 
                <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">O</span><span class="p">,</span> 
                <span class="s1">&#39;n_pop&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_pop</span><span class="p">,</span> 
                <span class="s1">&#39;n_init_pop&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_init_pop</span><span class="p">,</span> 
                <span class="s1">&#39;n_iter&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_iter</span><span class="p">,</span> 
                <span class="s1">&#39;n_sampling_epoch&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_sampling_epoch</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="Gaussian_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Gaussian_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">Gaussian_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{gaussian_smote,</span>
<span class="sd">                      title={Gaussian-Based SMOTE Algorithm for Solving Skewed Class Distributions},</span>
<span class="sd">                      author={Hansoo Lee and Jonggeun Kim and Sungshin Kim},</span>
<span class="sd">                      journal={Int. J. Fuzzy Logic and Intelligent Systems},</span>
<span class="sd">                      year={2017},</span>
<span class="sd">                      volume={17},</span>
<span class="sd">                      pages={229-234}</span>
<span class="sd">                    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="Gaussian_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Gaussian_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            sigma (float): variance</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater</span><span class="p">(</span><span class="n">sigma</span><span class="p">,</span> <span class="s2">&quot;sigma&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="o">=</span> <span class="n">sigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Gaussian_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Gaussian_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="Gaussian_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Gaussian_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># standardization applied to make sigma compatible with the data</span>
        <span class="n">ss</span><span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
        <span class="n">X_ss</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># fitting nearest neighbors model to find the minority neighbors of minority samples</span>
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X_ss</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">random_neighbor</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:])</span>
            <span class="n">s0</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_neighbor</span><span class="p">])</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">s0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">))</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">ss</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">))]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>

<div class="viewcode-block" id="Gaussian_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Gaussian_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="kmeans_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.kmeans_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">kmeans_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{kmeans_smote,</span>
<span class="sd">                        title = &quot;Improving imbalanced learning through a heuristic oversampling method based on k-means and SMOTE&quot;,</span>
<span class="sd">                        journal = &quot;Information Sciences&quot;,</span>
<span class="sd">                        volume = &quot;465&quot;,</span>
<span class="sd">                        pages = &quot;1 - 20&quot;,</span>
<span class="sd">                        year = &quot;2018&quot;,</span>
<span class="sd">                        issn = &quot;0020-0255&quot;,</span>
<span class="sd">                        doi = &quot;https://doi.org/10.1016/j.ins.2018.06.056&quot;,</span>
<span class="sd">                        url = &quot;http://www.sciencedirect.com/science/article/pii/S0020025518304997&quot;,</span>
<span class="sd">                        author = &quot;Georgios Douzas and Fernando Bacao and Felix Last&quot;,</span>
<span class="sd">                        keywords = &quot;Class-imbalanced learning, Oversampling, Classification, Clustering, Supervised learning, Within-class imbalance&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">]</span>
    
<div class="viewcode-block" id="kmeans_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.kmeans_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">irt</span><span class="o">=</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors</span>
<span class="sd">            n_clusters (int): number of clusters</span>
<span class="sd">            irt (float): imbalanced ratio threshold</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="s2">&quot;n_clusters&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">irt</span><span class="p">,</span> <span class="s2">&quot;irt&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">irt</span><span class="o">=</span> <span class="n">irt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="kmeans_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.kmeans_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">50</span><span class="p">],</span> 
                                                    <span class="s1">&#39;irt&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="kmeans_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.kmeans_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># applying kmeans clustering to all data</span>
        <span class="n">n_clusters</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)])</span>
        <span class="n">kmeans</span><span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="n">n_clusters</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># extracting clusters</span>
        <span class="n">labels</span><span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span>
        <span class="n">clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span> <span class="o">==</span> <span class="n">l</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">)]</span>
        
        <span class="c1"># cluster filtering</span>
        <span class="n">filt_clusters</span><span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">clusters</span> <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">irt</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filt_clusters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;number of clusters after filtering is 0&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># Step 2 in the paper</span>
        <span class="n">sparsity</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">nearest_neighbors</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">cluster_minority_ind</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">filt_clusters</span><span class="p">:</span>
            <span class="c1"># extract minority indices in the cluster</span>
            <span class="n">minority_ind</span><span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="n">y</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
            <span class="n">cluster_minority_ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minority_ind</span><span class="p">)</span>
            <span class="c1"># compute distance matrix of minority samples in the cluster</span>
            <span class="n">dm</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">minority_ind</span><span class="p">])</span>
            <span class="n">min_count</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">minority_ind</span><span class="p">)</span>
            <span class="c1"># compute the average of distances</span>
            <span class="n">avg_min_dist</span><span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span> <span class="o">-</span> <span class="n">dm</span><span class="o">.</span><span class="n">trace</span><span class="p">())</span><span class="o">/</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minority_ind</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">minority_ind</span><span class="p">))</span>
            <span class="c1"># compute sparsity (Step 4)</span>
            <span class="n">sparsity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">avg_min_dist</span><span class="o">**</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="n">min_count</span><span class="p">)</span>
            <span class="c1"># extract the nearest neighbors graph</span>
            <span class="n">nearest_neighbors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">minority_ind</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">minority_ind</span><span class="p">])</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">minority_ind</span><span class="p">]))</span>
        
        <span class="c1"># Step 5 - compute density of sampling</span>
        <span class="n">weights</span><span class="o">=</span> <span class="n">sparsity</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sparsity</span><span class="p">)</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="c1"># choose random cluster index and random minority element</span>
            <span class="n">clust_ind</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">weights</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">weights</span><span class="p">)</span>
            <span class="n">idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_minority_ind</span><span class="p">[</span><span class="n">clust_ind</span><span class="p">]))</span>
            <span class="n">base_idx</span><span class="o">=</span> <span class="n">cluster_minority_ind</span><span class="p">[</span><span class="n">clust_ind</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span>
            <span class="c1"># choose random neighbor</span>
            <span class="n">neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">cluster_minority_ind</span><span class="p">[</span><span class="n">clust_ind</span><span class="p">][</span><span class="n">nearest_neighbors</span><span class="p">[</span><span class="n">clust_ind</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">idx</span><span class="p">][</span><span class="mi">1</span><span class="p">:]])</span>
            <span class="c1"># sample</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">base_idx</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">neighbor_idx</span><span class="p">]))</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>

<div class="viewcode-block" id="kmeans_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.kmeans_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> 
                <span class="s1">&#39;irt&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">irt</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="Supervised_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Supervised_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">Supervised_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{supervised_smote,</span>
<span class="sd">                        author = {Hu, Jun AND He, Xue AND Yu, Dong-Jun AND Yang, Xi-Bei AND Yang, Jing-Yu AND Shen, Hong-Bin},</span>
<span class="sd">                        journal = {PLOS ONE},</span>
<span class="sd">                        publisher = {Public Library of Science},</span>
<span class="sd">                        title = {A New Supervised Over-Sampling Algorithm with Application to Protein-Nucleotide Binding Residue Prediction},</span>
<span class="sd">                        year = {2014},</span>
<span class="sd">                        month = {09},</span>
<span class="sd">                        volume = {9},</span>
<span class="sd">                        url = {https://doi.org/10.1371/journal.pone.0107676},</span>
<span class="sd">                        pages = {1-10},</span>
<span class="sd">                        abstract = {Protein-nucleotide interactions are ubiquitous in a wide variety of biological processes. Accurately identifying interaction residues solely from protein sequences is useful for both protein function annotation and drug design, especially in the post-genomic era, as large volumes of protein data have not been functionally annotated. Protein-nucleotide binding residue prediction is a typical imbalanced learning problem, where binding residues are extremely fewer in number than non-binding residues. Alleviating the severity of class imbalance has been demonstrated to be a promising means of improving the prediction performance of a machine-learning-based predictor for class imbalance problems. However, little attention has been paid to the negative impact of class imbalance on protein-nucleotide binding residue prediction. In this study, we propose a new supervised over-sampling algorithm that synthesizes additional minority class samples to address class imbalance. The experimental results from protein-nucleotide interaction datasets demonstrate that the proposed supervised over-sampling algorithm can relieve the severity of class imbalance and help to improve prediction performance. Based on the proposed over-sampling algorithm, a predictor, called TargetSOS, is implemented for protein-nucleotide binding residue prediction. Cross-validation tests and independent validation tests demonstrate the effectiveness of TargetSOS. The web-server and datasets used in this study are freely available at http://www.csbio.sjtu.edu.cn/bioinf/TargetSOS/.},</span>
<span class="sd">                        number = {9},</span>
<span class="sd">                        doi = {10.1371/journal.pone.0107676}</span>
<span class="sd">                    }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_classifier</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_application</span><span class="p">]</span>
    
<div class="viewcode-block" id="Supervised_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Supervised_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">th_lower</span><span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">th_upper</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">classifier</span><span class="o">=</span> <span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            th_lower (float): lower bound of the confidence interval</span>
<span class="sd">            th_upper (float): upper bound of the confidence interval</span>
<span class="sd">            classifier (obj): classifier used to estimate class memberships</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">th_lower</span><span class="p">,</span> <span class="s2">&quot;th_lower&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_in_range</span><span class="p">(</span><span class="n">th_upper</span><span class="p">,</span> <span class="s2">&quot;th_upper&quot;</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">th_lower</span><span class="o">=</span> <span class="n">th_lower</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">th_upper</span><span class="o">=</span> <span class="n">th_upper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">=</span> <span class="n">classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="Supervised_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Supervised_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;th_lower&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.8</span><span class="p">],</span> 
                                                    <span class="s1">&#39;th_upper&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;classifier&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">RandomForestClassifier</span><span class="p">(</span><span class="n">n_estimators</span><span class="o">=</span> <span class="mi">50</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="mi">5</span><span class="p">)]})</span></div>
    
<div class="viewcode-block" id="Supervised_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Supervised_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># training the classifier</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="n">th_lower</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">th_lower</span>
        
        <span class="c1"># do the sampling</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="n">n_trials</span><span class="o">=</span> <span class="mi">1</span>
        <span class="n">n_success</span><span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">n_trials</span><span class="o">=</span> <span class="n">n_trials</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)),</span> <span class="mi">2</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)]</span>
            <span class="n">sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">probs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">sample</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="c1"># extract probability</span>
            <span class="n">prob</span><span class="o">=</span> <span class="n">probs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">classes_</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">prob</span> <span class="o">&gt;=</span> <span class="n">th_lower</span> <span class="ow">and</span> <span class="n">prob</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">th_upper</span><span class="p">:</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
                <span class="n">n_success</span><span class="o">=</span> <span class="n">n_success</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="c1"># decreasing lower threshold if needed</span>
            <span class="k">if</span> <span class="n">n_success</span><span class="o">/</span><span class="n">n_trials</span> <span class="o">&lt;</span> <span class="mf">0.02</span><span class="p">:</span>
                <span class="n">th_lower</span><span class="o">=</span> <span class="n">th_lower</span> <span class="o">*</span> <span class="mf">0.9</span>
                <span class="n">n_success</span><span class="o">=</span> <span class="mi">1</span>
                <span class="n">n_trials</span><span class="o">=</span> <span class="mi">1</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>

<div class="viewcode-block" id="Supervised_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.Supervised_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;th_lower&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">th_lower</span><span class="p">,</span> 
                <span class="s1">&#39;th_upper&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">th_upper</span><span class="p">,</span>
                <span class="s1">&#39;classifier&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="p">,</span>
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="SN_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SN_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">SN_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @Article{sn_smote,</span>
<span class="sd">                        author=&quot;Garc{\&#39;i}a, V.</span>
<span class="sd">                        and S{\&#39;a}nchez, J. S.</span>
<span class="sd">                        and Mart{\&#39;i}n-F{\&#39;e}lez, R.</span>
<span class="sd">                        and Mollineda, R. A.&quot;,</span>
<span class="sd">                        title=&quot;Surrounding neighborhood-based SMOTE for learning from imbalanced data sets&quot;,</span>
<span class="sd">                        journal=&quot;Progress in Artificial Intelligence&quot;,</span>
<span class="sd">                        year=&quot;2012&quot;,</span>
<span class="sd">                        month=&quot;Dec&quot;,</span>
<span class="sd">                        day=&quot;01&quot;,</span>
<span class="sd">                        volume=&quot;1&quot;,</span>
<span class="sd">                        number=&quot;4&quot;,</span>
<span class="sd">                        pages=&quot;347--362&quot;,</span>
<span class="sd">                        abstract=&quot;Many traditional approaches to pattern classification assume that the problem classes share similar prior probabilities. However, in many real-life applications, this assumption is grossly violated. Often, the ratios of prior probabilities between classes are extremely skewed. This situation is known as the class imbalance problem. One of the strategies to tackle this problem consists of balancing the classes by resampling the original data set. The SMOTE algorithm is probably the most popular technique to increase the size of the minority class by generating synthetic instances. From the idea of the original SMOTE, we here propose the use of three approaches to surrounding neighborhood with the aim of generating artificial minority instances, but taking into account both the proximity and the spatial distribution of the examples. Experiments over a large collection of databases and using three different classifiers demonstrate that the new surrounding neighborhood-based SMOTE procedures significantly outperform other existing over-sampling algorithms.&quot;,</span>
<span class="sd">                        issn=&quot;2192-6360&quot;,</span>
<span class="sd">                        doi=&quot;10.1007/s13748-012-0027-5&quot;,</span>
<span class="sd">                        url=&quot;https://doi.org/10.1007/s13748-012-0027-5&quot;</span>
<span class="sd">                        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">]</span>
    
<div class="viewcode-block" id="SN_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SN_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (float): number of neighbors</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="SN_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SN_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="SN_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SN_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># the search for the k nearest centroid neighbors is limited for the nearest</span>
        <span class="c1"># 10*n_neighbors neighbors</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">*</span><span class="mi">10</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># determining k nearest centroid neighbors</span>
        <span class="n">ncn</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">ncn_nums</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        
        <span class="c1"># extracting nearest centroid neighbors</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)):</span>
            <span class="c1"># the first NCN neighbor is the first neighbor</span>
            <span class="n">ncn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="c1"># iterating through all neighbors and finding the one with smaller</span>
            <span class="c1"># centroid distance to X_min[i] than the previous set of neighbors</span>
            <span class="n">n_cent</span><span class="o">=</span> <span class="mi">1</span>
            <span class="n">centroid</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">ncn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]]</span>
            <span class="n">cent_dist</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">centroid</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">j</span><span class="o">=</span> <span class="mi">2</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">and</span> <span class="n">n_cent</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">:</span>
                <span class="n">new_cent_dist</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">((</span><span class="n">centroid</span> <span class="o">+</span> <span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]])</span><span class="o">/</span><span class="p">(</span><span class="n">n_cent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                
                <span class="c1"># checking if new nearest centroid neighbor found</span>
                <span class="k">if</span> <span class="n">new_cent_dist</span> <span class="o">&lt;</span> <span class="n">cent_dist</span><span class="p">:</span>
                    <span class="n">centroid</span><span class="o">=</span> <span class="n">centroid</span> <span class="o">+</span> <span class="n">X_min</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span>
                    <span class="n">ncn</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">n_cent</span><span class="p">]</span><span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">n_cent</span><span class="o">=</span> <span class="n">n_cent</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">cent_dist</span><span class="o">=</span> <span class="n">new_cent_dist</span>
                <span class="n">j</span><span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
            
            <span class="c1"># registering the number of nearest centroid neighbors found</span>
            <span class="n">ncn_nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">n_cent</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))</span>
            <span class="n">random_neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ncn</span><span class="p">[</span><span class="n">random_idx</span><span class="p">][:</span><span class="n">ncn_nums</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]])</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">random_idx</span><span class="p">],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">random_neighbor_idx</span><span class="p">]))</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>

<div class="viewcode-block" id="SN_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.SN_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="CCR"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CCR">[docs]</a><span class="k">class</span> <span class="nc">CCR</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{ccr,</span>
<span class="sd">                    author = {Koziarski, Michał and Wozniak, Michal},</span>
<span class="sd">                    year = {2017},</span>
<span class="sd">                    month = {12},</span>
<span class="sd">                    pages = {727–736},</span>
<span class="sd">                    title = {CCR: A combined cleaning and resampling algorithm for imbalanced data classification},</span>
<span class="sd">                    volume = {27},</span>
<span class="sd">                    journal = {International Journal of Applied Mathematics and Computer Science}</span>
<span class="sd">                    }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * Adapted from https://github.com/michalkoziarski/CCR</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">]</span>
    
<div class="viewcode-block" id="CCR.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CCR.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">energy</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">scaling</span><span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            energy (float): energy parameter</span>
<span class="sd">            scaling (float): scaling factor</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">energy</span><span class="p">,</span> <span class="s2">&quot;energy&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">scaling</span><span class="p">,</span> <span class="s2">&quot;scaling&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="o">=</span> <span class="n">energy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span><span class="o">=</span> <span class="n">scaling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="CCR.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CCR.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;energy&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.0025</span><span class="p">,</span> <span class="mf">0.005</span><span class="p">,</span> <span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.025</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mf">25.0</span><span class="p">,</span> <span class="mf">50.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;scaling&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="CCR.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CCR.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="k">def</span> <span class="nf">taxicab_sample</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
            <span class="n">sample</span> <span class="o">=</span> <span class="p">[]</span>
        
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">spread</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample</span><span class="p">])</span>
                <span class="n">sample</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spread</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">sample</span><span class="p">)</span>
        
        <span class="n">minority</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        <span class="n">majority</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">]</span>

        <span class="n">energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span> <span class="o">*</span> <span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span><span class="p">)</span>

        <span class="n">distances</span><span class="o">=</span> <span class="n">pairwise_distances</span><span class="p">(</span><span class="n">minority</span><span class="p">,</span> <span class="n">majority</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;l1&#39;</span><span class="p">)</span>

        <span class="n">radii</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minority</span><span class="p">))</span>
        <span class="n">translations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">majority</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minority</span><span class="p">)):</span>
            <span class="n">minority_point</span><span class="o">=</span> <span class="n">minority</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">remaining_energy</span><span class="o">=</span> <span class="n">energy</span>
            <span class="n">r</span><span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">sorted_distances</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">current_majority</span><span class="o">=</span> <span class="mi">0</span>

            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">current_majority</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">majority</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">current_majority</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">radius_change</span><span class="o">=</span> <span class="n">remaining_energy</span> <span class="o">/</span> <span class="p">(</span><span class="n">current_majority</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">radius_change</span><span class="o">=</span> <span class="n">remaining_energy</span> <span class="o">/</span> <span class="n">current_majority</span>

                    <span class="n">r</span><span class="o">+=</span> <span class="n">radius_change</span>
                    <span class="k">break</span>

                <span class="n">radius_change</span><span class="o">=</span> <span class="n">remaining_energy</span> <span class="o">/</span> <span class="p">(</span><span class="n">current_majority</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sorted_distances</span><span class="p">[</span><span class="n">current_majority</span><span class="p">]]</span> <span class="o">&gt;=</span> <span class="n">r</span> <span class="o">+</span> <span class="n">radius_change</span><span class="p">:</span>
                    <span class="n">r</span><span class="o">+=</span> <span class="n">radius_change</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">current_majority</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">last_distance</span><span class="o">=</span> <span class="mf">0.0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">last_distance</span><span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sorted_distances</span><span class="p">[</span><span class="n">current_majority</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>

                    <span class="n">radius_change</span><span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sorted_distances</span><span class="p">[</span><span class="n">current_majority</span><span class="p">]]</span> <span class="o">-</span> <span class="n">last_distance</span>
                    <span class="n">r</span><span class="o">+=</span> <span class="n">radius_change</span>
                    <span class="n">remaining_energy</span><span class="o">-=</span> <span class="n">radius_change</span> <span class="o">*</span> <span class="p">(</span><span class="n">current_majority</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
                    <span class="n">current_majority</span><span class="o">+=</span> <span class="mi">1</span>

            <span class="n">radii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">current_majority</span><span class="p">):</span>
                <span class="n">majority_point</span><span class="o">=</span> <span class="n">majority</span><span class="p">[</span><span class="n">sorted_distances</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">sorted_distances</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span>

                <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="mf">1e-20</span><span class="p">:</span>
                    <span class="n">majority_point</span><span class="o">+=</span> <span class="p">(</span><span class="mf">1e-6</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">majority_point</span><span class="p">))</span> <span class="o">+</span> <span class="mf">1e-6</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">majority_point</span><span class="p">))</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">minority_point</span> <span class="o">-</span> <span class="n">majority_point</span><span class="p">))</span>

                <span class="n">translation</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="n">d</span><span class="p">)</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="p">(</span><span class="n">majority_point</span> <span class="o">-</span> <span class="n">minority_point</span><span class="p">)</span>
                <span class="n">translations</span><span class="p">[</span><span class="n">sorted_distances</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">translation</span>

        <span class="n">majority</span><span class="o">=</span> <span class="n">majority</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">majority</span> <span class="o">+=</span> <span class="n">translations</span>

        <span class="n">appended</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minority</span><span class="p">)):</span>
            <span class="n">minority_point</span> <span class="o">=</span> <span class="n">minority</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">synthetic_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">radii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">radii</span><span class="p">))</span> <span class="o">*</span> <span class="n">num_to_sample</span><span class="p">))</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">radii</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">synthetic_samples</span><span class="p">):</span>
                <span class="n">appended</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">minority_point</span> <span class="o">+</span> <span class="n">taxicab_sample</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">minority_point</span><span class="p">),</span> <span class="n">r</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">appended</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No samples were added&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">appended</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">appended</span><span class="p">))])</span></div>

<div class="viewcode-block" id="CCR.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.CCR.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;energy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">energy</span><span class="p">,</span> 
                <span class="s1">&#39;scaling&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaling</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="ANS"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ANS">[docs]</a><span class="k">class</span> <span class="nc">ANS</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @article{ans,</span>
<span class="sd">                     author = {Siriseriwan, W and Sinapiromsaran, Krung},</span>
<span class="sd">                     year = {2017},</span>
<span class="sd">                     month = {09},</span>
<span class="sd">                     pages = {565-576},</span>
<span class="sd">                     title = {Adaptive neighbor synthetic minority oversampling technique under 1NN outcast handling},</span>
<span class="sd">                     volume = {39},</span>
<span class="sd">                     booktitle = {Songklanakarin Journal of Science and Technology}</span>
<span class="sd">                     }</span>
<span class="sd">    </span>
<span class="sd">    Notes:</span>
<span class="sd">        * The method is not prepared for the case when there is no c satisfying the condition in line 25 of the algorithm, fixed.</span>
<span class="sd">        * The method is not prepared for empty Pused sets, fixed.</span>
<span class="sd">    &quot;&quot;&quot;</span>    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_sample_ordinary</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_density_based</span><span class="p">]</span>
    
<div class="viewcode-block" id="ANS.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ANS.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="ANS.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ANS.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="ANS.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ANS.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;The number of minority samples (</span><span class="si">%d</span><span class="s2">) is not enough for sampling&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># outcast extraction algorithm</span>
        
        <span class="c1"># maximum C value</span>
        <span class="n">C_max</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.25</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        
        <span class="c1"># finding the first minority neighbor of minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        
        <span class="c1"># extracting the distances of first minority neighbors from minority samples</span>
        <span class="n">first_pos_neighbor_distances</span><span class="o">=</span> <span class="n">dist</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># fitting another nearest neighbors model to extract majority samples in</span>
        <span class="c1"># the neighborhoods of minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        
        <span class="c1"># extracting the number of majority samples in the neighborhood of minority samples</span>
        <span class="n">out_border</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">)):</span>
            <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">first_pos_neighbor_distances</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">return_distance</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">out_border</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">))</span>
            
        <span class="n">out_border</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_border</span><span class="p">)</span>
        
        <span class="c1"># finding the optimal C value by comparing the number of outcast minority</span>
        <span class="c1"># samples when traversing the range [1, C_max]</span>
        <span class="n">n_oc_m1</span><span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">C</span><span class="o">=</span> <span class="mi">0</span>
        <span class="n">best_diff</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">C_max</span><span class="p">):</span>
            <span class="n">n_oc</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">out_border</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n_oc</span> <span class="o">-</span> <span class="n">n_oc_m1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">best_diff</span><span class="p">:</span>
                <span class="n">best_diff</span><span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n_oc</span> <span class="o">-</span> <span class="n">n_oc_m1</span><span class="p">)</span>
                <span class="n">C</span><span class="o">=</span> <span class="n">n_oc</span>
            <span class="n">n_oc_m1</span><span class="o">=</span> <span class="n">n_oc</span>
        
        <span class="c1"># determining the set of minority samples Pused</span>
        <span class="n">Pused</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">out_border</span> <span class="o">&lt;</span> <span class="n">C</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># Adaptive neighbor SMOTE algorithm</span>
        
        <span class="c1"># checking if there are minority samples left</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Pused</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Pused is empty&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># finding the maximum distances of first positive neighbors</span>
        <span class="n">eps</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">first_pos_neighbor_distances</span><span class="p">[</span><span class="n">Pused</span><span class="p">])</span>
        
        <span class="c1"># fitting nearest neighbors model to find nearest minority samples in</span>
        <span class="c1"># the neighborhoods of minority samples</span>
        <span class="n">nn</span><span class="o">=</span> <span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">)</span>
        <span class="n">nn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">Pused</span><span class="p">])</span>
        <span class="n">ind</span><span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">radius_neighbors</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">Pused</span><span class="p">],</span> <span class="n">eps</span><span class="p">,</span> <span class="n">return_distance</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># extracting the number of positive samples in the neighborhoods</span>
        <span class="n">Np</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">Np</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;all samples have only 1 neighbor in the given radius&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># determining the distribution used to generate samples</span>
        <span class="n">distribution</span><span class="o">=</span> <span class="n">Np</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">Np</span><span class="p">)</span>
        
        <span class="c1"># generating samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Pused</span><span class="p">)),</span> <span class="n">p</span><span class="o">=</span> <span class="n">distribution</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">random_idx</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">random_neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">random_idx</span><span class="p">])</span>
                <span class="k">while</span> <span class="n">random_neighbor_idx</span> <span class="o">==</span> <span class="n">random_idx</span><span class="p">:</span>
                    <span class="n">random_neighbor_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">random_idx</span><span class="p">])</span>
                <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">Pused</span><span class="p">[</span><span class="n">random_idx</span><span class="p">]],</span> <span class="n">X_min</span><span class="p">[</span><span class="n">Pused</span><span class="p">[</span><span class="n">random_neighbor_idx</span><span class="p">]]))</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>

<div class="viewcode-block" id="ANS.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.ANS.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="cluster_SMOTE"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.cluster_SMOTE">[docs]</a><span class="k">class</span> <span class="nc">cluster_SMOTE</span><span class="p">(</span><span class="n">OverSampling</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    References:</span>
<span class="sd">        * BibTex::</span>
<span class="sd">            </span>
<span class="sd">            @INPROCEEDINGS{cluster_SMOTE, </span>
<span class="sd">                            author={Cieslak, D. A. and Chawla, N. V. and Striegel, A.}, </span>
<span class="sd">                            booktitle={2006 IEEE International Conference on Granular Computing}, </span>
<span class="sd">                            title={Combating imbalance in network intrusion datasets}, </span>
<span class="sd">                            year={2006}, </span>
<span class="sd">                            volume={}, </span>
<span class="sd">                            number={}, </span>
<span class="sd">                            pages={732-737}, </span>
<span class="sd">                            keywords={Intelligent networks;Intrusion detection;Telecommunication traffic;Data mining;Computer networks;Data security;Machine learning;Counting circuits;Computer security;Humans}, </span>
<span class="sd">                            doi={10.1109/GRC.2006.1635905}, </span>
<span class="sd">                            ISSN={}, </span>
<span class="sd">                            month={May}}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">categories</span><span class="o">=</span> <span class="p">[</span><span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span><span class="p">,</span>
                 <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_uses_clustering</span><span class="p">]</span>
    
<div class="viewcode-block" id="cluster_SMOTE.__init__"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.cluster_SMOTE.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">proportion</span><span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">n_neighbors</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_clusters</span><span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            proportion (float): proportion of the difference of n_maj and n_min to sample</span>
<span class="sd">                                    e.g. 1.0 means that after sampling the number of minority</span>
<span class="sd">                                    samples will be equal to the number of majority samples</span>
<span class="sd">            n_neighbors (int): number of neighbors in SMOTE</span>
<span class="sd">            n_clusters (int): number of clusters</span>
<span class="sd">            n_jobs (int): number of parallel jobs</span>
<span class="sd">            random_state (int/RandomState/None): initializer of random_state, like in sklearn</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">proportion</span><span class="p">,</span> <span class="s2">&quot;proportion&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="s2">&quot;n_neighbors&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_greater_or_equal</span><span class="p">(</span><span class="n">n_clusters</span><span class="p">,</span> <span class="s2">&quot;n_components&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_n_jobs</span><span class="p">(</span><span class="n">n_jobs</span><span class="p">,</span> <span class="s1">&#39;n_jobs&#39;</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="o">=</span> <span class="n">proportion</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="n">n_neighbors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="o">=</span> <span class="n">n_clusters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">set_random_state</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span></div>
        
<div class="viewcode-block" id="cluster_SMOTE.parameter_combinations"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.cluster_SMOTE.parameter_combinations">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">parameter_combinations</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates reasonable paramter combinations.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(dict): a list of meaningful paramter combinations</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">generate_parameter_combinations</span><span class="p">({</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.75</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> 
                                                    <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">]})</span></div>
    
<div class="viewcode-block" id="cluster_SMOTE.sample"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.cluster_SMOTE.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the class paramters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running sampling via </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptor</span><span class="p">())</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">]</span>
        
        <span class="c1"># determining the number of samples to generate</span>
        <span class="n">num_to_sample</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_instances_to_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">majority_label</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="n">num_to_sample</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;Sampling is not needed&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="n">kmeans</span><span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">]),</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>
        <span class="n">kmeans</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">)</span>
        <span class="n">cluster_labels</span><span class="o">=</span> <span class="n">kmeans</span><span class="o">.</span><span class="n">labels_</span>
        <span class="n">unique_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">)</span>
        
        <span class="c1"># creating nearest neighbors objects for each cluster</span>
        <span class="n">cluster_indices</span><span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">c</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">unique_labels</span><span class="p">]</span>
        <span class="n">cluster_nns</span><span class="o">=</span> <span class="p">[</span><span class="n">NearestNeighbors</span><span class="p">(</span><span class="n">n_neighbors</span><span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">])]))</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_min</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">))]</span>
        
        <span class="k">if</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cluster_indices</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="s2">&quot;All clusters contain 1 element&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># generating the samples</span>
        <span class="n">samples</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">num_to_sample</span><span class="p">:</span>
            <span class="n">cluster_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">random_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]))</span>
            <span class="n">sample_a</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]][</span><span class="n">random_idx</span><span class="p">]</span>
            <span class="n">dist</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span> <span class="n">cluster_nns</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">]</span><span class="o">.</span><span class="n">kneighbors</span><span class="p">(</span><span class="n">sample_a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
            <span class="n">sample_b_idx</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">cluster_indices</span><span class="p">[</span><span class="n">cluster_idx</span><span class="p">][</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]])</span>
            <span class="n">sample_b</span><span class="o">=</span> <span class="n">X_min</span><span class="p">[</span><span class="n">sample_b_idx</span><span class="p">]</span>
            <span class="n">samples</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_between_points</span><span class="p">(</span><span class="n">sample_a</span><span class="p">,</span> <span class="n">sample_b</span><span class="p">))</span>
            
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">samples</span><span class="p">)]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">minority_label</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">samples</span><span class="p">))])</span></div>
        
<div class="viewcode-block" id="cluster_SMOTE.get_params"><a class="viewcode-back" href="../../oversamplers.html#smote_variants.cluster_SMOTE.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the current sampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;proportion&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">proportion</span><span class="p">,</span> 
                <span class="s1">&#39;n_neighbors&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_neighbors</span><span class="p">,</span> 
                <span class="s1">&#39;n_clusters&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_clusters</span><span class="p">,</span> 
                <span class="s1">&#39;n_jobs&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_jobs</span><span class="p">,</span>
                <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_random_state_init</span><span class="p">}</span></div></div>

<div class="viewcode-block" id="MulticlassOversampling"><a class="viewcode-back" href="../../multiclass_oversampling.html#smote_variants.MulticlassOversampling">[docs]</a><span class="k">class</span> <span class="nc">MulticlassOversampling</span><span class="p">(</span><span class="n">StatisticsMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Carries out multiclass oversampling</span>
<span class="sd">    </span>
<span class="sd">    Example::</span>
<span class="sd">        </span>
<span class="sd">        import smote_variants as sv</span>
<span class="sd">        import sklearn.datasets as datasets</span>
<span class="sd">        </span>
<span class="sd">        dataset= datasets.load_wine()</span>
<span class="sd">        </span>
<span class="sd">        oversampler= sv.MulticlassOversampling(sv.distance_SMOTE())</span>
<span class="sd">        </span>
<span class="sd">        X_samp, y_samp= oversampler.sample(dataset[&#39;data&#39;], dataset[&#39;target&#39;])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
<div class="viewcode-block" id="MulticlassOversampling.__init__"><a class="viewcode-back" href="../../multiclass_oversampling.html#smote_variants.MulticlassOversampling.__init__">[docs]</a>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oversampler</span><span class="o">=</span> <span class="n">SMOTE</span><span class="p">(</span><span class="n">random_state</span><span class="o">=</span> <span class="mi">2</span><span class="p">),</span> <span class="n">strategy</span><span class="o">=</span> <span class="s2">&quot;equalize_1_vs_many_successive&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the multiclass oversampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            oversampler (obj): an oversampling object</span>
<span class="sd">            strategy (str/obj): a multiclass oversampling strategy, currently &#39;equalize_1_vs_many_successive&#39;/&#39;equalize_1_vs_many&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="o">=</span> <span class="n">oversampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="o">=</span> <span class="n">strategy</span></div>
    
<div class="viewcode-block" id="MulticlassOversampling.sample_equalize_1_vs_many"><a class="viewcode-back" href="../../multiclass_oversampling.html#smote_variants.MulticlassOversampling.sample_equalize_1_vs_many">[docs]</a>    <span class="k">def</span> <span class="nf">sample_equalize_1_vs_many</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation by oversampling each minority class to the</span>
<span class="sd">        cardinality of the majority class using all original samples in each run.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running multiclass oversampling with strategy </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;proportion&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="o">.</span><span class="n">get_params</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multiclass oversampling strategy </span><span class="si">%s</span><span class="s2"> cannot be used with oversampling techniques without proportion parameter&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">))</span>
        
        <span class="c1"># extract class label statistics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># sort labels by number of samples</span>
        <span class="n">class_labels</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">class_labels</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">class_labels</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        
        <span class="n">majority_class_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># determining the majority class data</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="n">majority_class_label</span><span class="p">]</span>
        
        <span class="c1"># dict to store the results</span>
        <span class="n">results</span><span class="o">=</span> <span class="p">{}</span>
        <span class="n">results</span><span class="p">[</span><span class="n">majority_class_label</span><span class="p">]</span><span class="o">=</span> <span class="n">X_maj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># running oversampling for all minority classes against all oversampled classes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_labels</span><span class="p">)):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;Sampling minority class with label: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            
            <span class="c1"># extract current minority class</span>
            <span class="n">minority_class_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="n">minority_class_label</span><span class="p">]</span>
            <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">!=</span> <span class="n">minority_class_label</span><span class="p">]</span>
            
            <span class="c1"># prepare data to pass to oversampling</span>
            <span class="n">X_training</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_min</span><span class="p">])</span>
            <span class="n">y_training</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span>
            
            <span class="c1"># prepare parameters by properly setting the proportion value</span>
            <span class="n">params</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
            
            <span class="n">num_to_generate</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="n">majority_class_label</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">num_to_gen_to_all</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;proportion&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">num_to_generate</span><span class="o">/</span><span class="n">num_to_gen_to_all</span>
            
            <span class="c1"># instantiating new oversampling object with the proper proportion parameter</span>
            <span class="n">oversampler</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
            
            <span class="c1"># executing the sampling</span>
            <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">oversampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X_training</span><span class="p">,</span> <span class="n">y_training</span><span class="p">)</span>
            
            <span class="c1"># registaring the newly oversampled minority class in the output set</span>
            <span class="n">results</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span> <span class="n">X_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X_training</span><span class="p">):][</span><span class="n">y_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X_training</span><span class="p">):]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        
        <span class="c1"># constructing the output set</span>
        <span class="n">X_final</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">y_final</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_labels</span><span class="p">)):</span>
            <span class="n">X_final</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_final</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]])</span>
            <span class="n">y_final</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y_final</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]))])</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">X_final</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">y_final</span><span class="p">])</span></div>
    
<div class="viewcode-block" id="MulticlassOversampling.sample_equalize_1_vs_many_successive"><a class="viewcode-back" href="../../multiclass_oversampling.html#smote_variants.MulticlassOversampling.sample_equalize_1_vs_many_successive">[docs]</a>    <span class="k">def</span> <span class="nf">sample_equalize_1_vs_many_successive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation by oversampling each minority class successively to the</span>
<span class="sd">        cardinality of the majority class, incorporating the results of previous</span>
<span class="sd">        oversamplings.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span><span class="s2">&quot;Running multiclass oversampling with strategy </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;proportion&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="o">.</span><span class="n">get_params</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multiclass oversampling strategy </span><span class="si">%s</span><span class="s2"> cannot be used with oversampling techniques without proportion parameter&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">))</span>
        
        <span class="c1"># extract class label statistics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">class_label_statistics</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        
        <span class="c1"># sort labels by number of samples</span>
        <span class="n">class_labels</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="n">class_labels</span><span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">class_labels</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        
        <span class="n">majority_class_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        
        <span class="c1"># determining the majority class data</span>
        <span class="n">X_maj</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="n">majority_class_label</span><span class="p">]</span>
        
        <span class="c1"># dict to store the results</span>
        <span class="n">results</span><span class="o">=</span> <span class="p">{}</span>
        <span class="n">results</span><span class="p">[</span><span class="n">majority_class_label</span><span class="p">]</span><span class="o">=</span> <span class="n">X_maj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        
        <span class="c1"># running oversampling for all minority classes against all oversampled classes</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_labels</span><span class="p">)):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;Sampling minority class with label: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            
            <span class="c1"># extract current minority class</span>
            <span class="n">minority_class_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">X_min</span><span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">y</span> <span class="o">==</span> <span class="n">minority_class_label</span><span class="p">]</span>
            
            <span class="c1"># prepare data to pass to oversampling</span>
            <span class="n">X_training</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_min</span><span class="p">])</span>
            <span class="n">y_training</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_maj</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">X_min</span><span class="p">))])</span>
            
            <span class="c1"># prepare parameters by properly setting the proportion value</span>
            <span class="n">params</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
            
            <span class="n">num_to_generate</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="n">majority_class_label</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
            <span class="n">num_to_gen_to_all</span><span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="n">majority_class_label</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">class_stats</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
            
            <span class="n">params</span><span class="p">[</span><span class="s1">&#39;proportion&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">num_to_generate</span><span class="o">/</span><span class="n">num_to_gen_to_all</span>
            
            <span class="c1"># instantiating new oversampling object with the proper proportion parameter</span>
            <span class="n">oversampler</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">params</span><span class="p">)</span>
            
            <span class="c1"># executing the sampling</span>
            <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">oversampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X_training</span><span class="p">,</span> <span class="n">y_training</span><span class="p">)</span>
            
            <span class="c1"># adding the newly oversampled minority class to the majority data</span>
            <span class="n">X_maj</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_maj</span><span class="p">,</span> <span class="n">X_samp</span><span class="p">[</span><span class="n">y_samp</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]])</span>
            
            <span class="c1"># registaring the newly oversampled minority class in the output set</span>
            <span class="n">results</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span> <span class="n">X_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X_training</span><span class="p">):][</span><span class="n">y_samp</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X_training</span><span class="p">):]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># constructing the output set        </span>
        <span class="n">X_final</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">y_final</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_labels</span><span class="p">)):</span>
            <span class="n">X_final</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X_final</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]])</span>
            <span class="n">y_final</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y_final</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="n">class_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]))])</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">X</span><span class="p">,</span> <span class="n">X_final</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="n">y_final</span><span class="p">])</span></div>
        
<div class="viewcode-block" id="MulticlassOversampling.sample"><a class="viewcode-back" href="../../multiclass_oversampling.html#smote_variants.MulticlassOversampling.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the sample generation according to the oversampling strategy.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): training set</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            (np.ndarray, np.array): the extended training set and target labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;equalize_1_vs_many_successive&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_equalize_1_vs_many_successive</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s2">&quot;equalize_1_vs_many&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_equalize_1_vs_many</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Multiclass oversampling startegy </span><span class="si">%s</span><span class="s2"> not implemented.&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="MulticlassOversampling.get_params"><a class="viewcode-back" href="../../multiclass_oversampling.html#smote_variants.MulticlassOversampling.get_params">[docs]</a>    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the multiclass oversampling object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;oversampler&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="p">,</span> <span class="s1">&#39;strategy&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">strategy</span><span class="p">}</span></div></div>

<span class="k">class</span> <span class="nc">OversamplingClassifier</span><span class="p">(</span><span class="n">BaseEstimator</span><span class="p">,</span> <span class="n">ClassifierMixin</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class wraps an oversampler and a classifier, making it compatible</span>
<span class="sd">    with sklearn based pipelines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">oversampler</span><span class="p">,</span> <span class="n">classifier</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the wrapper.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            oversampler (obj): an oversampler object</span>
<span class="sd">            classifier (obj): an sklearn-compatible classifier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="o">=</span> <span class="n">oversampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">=</span> <span class="n">classifier</span>
        
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Carries out oversampling and fits the classifier.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): feature vectors</span>
<span class="sd">            y (np.array): target values</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            obj: the object itself</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="bp">self</span>
    
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Carries out the predictions.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): feature vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Carries out the predictions with probability estimations.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): feature vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the dictionary of parameters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            deep (bool): wether to return parameters with deep discovery</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the dictionary of parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;oversampler&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">oversampler</span><span class="p">,</span> <span class="s1">&#39;classifier&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifier</span><span class="p">}</span>
    
    <span class="k">def</span> <span class="nf">set_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">parameters</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the parameters.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            parameters (dict): the parameters to set.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            obj: the object itself</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">for</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">parameters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameter</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            
        <span class="k">return</span> <span class="bp">self</span>

<span class="k">class</span> <span class="nc">MLPClassifierWrapper</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper over MLPClassifier of sklearn to provide easier parameterization</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">activation</span><span class="o">=</span> <span class="s1">&#39;relu&#39;</span><span class="p">,</span> <span class="n">hidden_layer_fraction</span><span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span> <span class="mf">0.0001</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the MLPClassifier</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            activation (str): name of the activation function</span>
<span class="sd">            hidden_layer_fraction (float): fraction of the hidden neurons of the number of input dimensions</span>
<span class="sd">            alpha (float): alpha parameter of the MLP classifier</span>
<span class="sd">            random_state (int/np.random.RandomState/None): initializer of the random state</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="o">=</span> <span class="n">activation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_fraction</span><span class="o">=</span> <span class="n">hidden_layer_fraction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="o">=</span> <span class="n">alpha</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">=</span> <span class="n">random_state</span>
    
    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fit the model to the data</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): features</span>
<span class="sd">            y (np.array): target labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            obj: the MLPClassifierWrapper object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hidden_layer_size</span><span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_fraction</span><span class="p">)])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">=</span> <span class="n">MLPClassifier</span><span class="p">(</span><span class="n">activation</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span> 
                                  <span class="n">hidden_layer_sizes</span><span class="o">=</span> <span class="p">(</span><span class="n">hidden_layer_size</span><span class="p">,),</span>
                                  <span class="n">alpha</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span>
                                  <span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
        
    <span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predicts the labels of the unseen data</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): unseen features</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.array: predicted labels</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">predict_proba</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Predicts the class probabilities of the unseen data</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            X (np.ndarray): unseen features</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            np.matrix: predicted class probabilities</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the parameters of the classifier.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: the parameters of the object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;activation&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">activation</span><span class="p">,</span> <span class="s1">&#39;hidden_layer_fraction&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">hidden_layer_fraction</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="s1">&#39;random_state&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">}</span>
    
    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a copy of the classifier.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            obj: a copy of the classifier</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">MLPClassifierWrapper</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>

<span class="k">class</span> <span class="nc">Folding</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cache-able folding of dataset for cross-validation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataset</span><span class="p">,</span> <span class="n">validator</span><span class="p">,</span> <span class="n">cache_path</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of Folding object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            dataset (dict): dataset dictionary with keys &#39;data&#39;, &#39;target&#39; and &#39;DESCR&#39;</span>
<span class="sd">            validator (obj): cross-validator object</span>
<span class="sd">            cache_path (str): path to cache directory</span>
<span class="sd">            random_state (int/np.random.RandomState/None): initializer of the random state</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="o">=</span> <span class="n">dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_name</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="o">=</span> <span class="n">validator</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="o">=</span> <span class="n">cache_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">=</span> <span class="s1">&#39;folding_&#39;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_name</span> <span class="o">+</span> <span class="s1">&#39;.pickle&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_size</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_n_attr</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imbalanced_ratio</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">=</span> <span class="n">random_state</span>
    
    <span class="k">def</span> <span class="nf">do_folding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the folding or reads it from file if already available</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            list(tuple): list of tuples of X_train, y_train, X_test, y_test objects</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="o">.</span><span class="n">random_state</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;folding&#39;</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">))):</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; doing folding </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
                
                <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="o">=</span> <span class="p">{}</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="p">[</span><span class="s1">&#39;folding&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="p">[</span><span class="s1">&#39;db_size&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="p">[</span><span class="s1">&#39;db_n_attr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="p">[</span><span class="s1">&#39;imbalanced_ratio&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
                
                <span class="n">X</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span>
                <span class="n">y</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">validator</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="p">[</span><span class="s1">&#39;folding&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">X</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">train</span><span class="p">],</span> <span class="n">X</span><span class="p">[</span><span class="n">test</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">test</span><span class="p">]))</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; dumping to file </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
                    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; reading from file </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;rb&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">folding</span>
    
    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;db_name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_name</span><span class="p">}</span>
    
    <span class="k">def</span> <span class="nf">descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>
        
<span class="k">class</span> <span class="nc">Sampling</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cache-able sampling of dataset folds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folding</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">sampler_parameters</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of the sampling object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            folding (obj): Folding object</span>
<span class="sd">            sampler (class): class of a sampler object</span>
<span class="sd">            sampler_parameters (dict): a parameter combination for the sampler object</span>
<span class="sd">            scaler (obj): scaler object</span>
<span class="sd">            random_state (int/np.random.RandomState/None): initializer of the random state</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="o">=</span> <span class="n">folding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_name</span><span class="o">=</span> <span class="n">folding</span><span class="o">.</span><span class="n">db_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">=</span> <span class="n">sampler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="o">=</span> <span class="n">sampler_parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span><span class="o">=</span> <span class="n">scaler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="o">=</span> <span class="n">folding</span><span class="o">.</span><span class="n">cache_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardized_filename</span><span class="p">(</span><span class="s1">&#39;sampling&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">=</span> <span class="n">random_state</span>
        
    <span class="k">def</span> <span class="nf">standardized_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">db_name</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sampler</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">sampler_parameters</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        standardizes the filename</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            filename (str): filename</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            str: standardized name</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">hashlib</span>
        
        <span class="n">db_name</span><span class="o">=</span> <span class="p">(</span><span class="n">db_name</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_name</span><span class="p">)</span>
        
        <span class="n">sampler</span><span class="o">=</span> <span class="p">(</span><span class="n">sampler</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">sampler_parameters</span><span class="o">=</span> <span class="n">sampler_parameters</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_parameters</span>
        <span class="n">sampler_parameter_str</span><span class="o">=</span> <span class="n">hashlib</span><span class="o">.</span><span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">sampler_parameters</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
        
        <span class="n">filename</span><span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">prefix</span><span class="p">,</span> <span class="n">db_name</span><span class="p">,</span> <span class="n">sampler</span><span class="p">,</span> <span class="n">sampler_parameter_str</span><span class="p">])</span> <span class="o">+</span> <span class="s1">&#39;.pickle&#39;</span>
        <span class="n">filename</span><span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s1">&#39;[&quot;</span><span class="se">\\</span><span class="s1">,:()</span><span class="si">{}</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>
        <span class="n">filename</span><span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">filename</span><span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;: &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">filename</span><span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">filename</span><span class="o">=</span> <span class="n">filename</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">filename</span>
    
    <span class="k">def</span> <span class="nf">cache_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">mkl</span>
            <span class="n">mkl</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; mkl thread number set to 1 successfully&quot;</span><span class="p">))</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; setting mkl thread number didn&#39;t succeed&quot;</span><span class="p">))</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)):</span>
            <span class="c1"># if the sampled dataset does not exist</span>
            <span class="n">is_extensive</span><span class="o">=</span> <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_extensive</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">categories</span>
            <span class="n">has_proportion</span><span class="o">=</span> <span class="s1">&#39;proportion&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_parameters</span>
            <span class="n">higher_prop_sampling_available</span><span class="o">=</span> <span class="kc">None</span>
            
            <span class="k">if</span> <span class="n">is_extensive</span> <span class="ow">and</span> <span class="n">has_proportion</span><span class="p">:</span>
                <span class="n">proportion</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="p">[</span><span class="s1">&#39;proportion&#39;</span><span class="p">]</span>
                <span class="n">all_pc</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">parameter_combinations</span><span class="p">()</span>
                <span class="n">all_proportions</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">([</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;proportion&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">all_pc</span><span class="p">])</span>
                <span class="n">all_proportions</span><span class="o">=</span> <span class="n">all_proportions</span><span class="p">[</span><span class="n">all_proportions</span> <span class="o">&gt;</span> <span class="n">proportion</span><span class="p">]</span>
                
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">all_proportions</span><span class="p">:</span>
                    <span class="n">tmp_par</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">tmp_par</span><span class="p">[</span><span class="s1">&#39;proportion&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">p</span>
                    <span class="n">tmp_filename</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardized_filename</span><span class="p">(</span><span class="s1">&#39;sampling&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">db_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="vm">__name__</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">tmp_par</span><span class="p">))</span>
                    
                    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="p">)):</span>
                        <span class="n">higher_prop_sampling_available</span><span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tmp_filename</span><span class="p">)</span>
                        <span class="k">break</span>
            
            <span class="k">if</span> <span class="ow">not</span> <span class="n">is_extensive</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">has_proportion</span> <span class="ow">or</span> <span class="p">(</span><span class="n">is_extensive</span> <span class="ow">and</span> <span class="n">has_proportion</span> <span class="ow">and</span> <span class="n">higher_prop_sampling_available</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; doing sampling&quot;</span><span class="p">)</span>
                <span class="n">begin</span><span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
                <span class="n">sampling</span><span class="o">=</span> <span class="p">[]</span>
                <span class="n">folds</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="o">.</span><span class="n">do_folding</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="p">[</span><span class="s1">&#39;random_state&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
                <span class="k">for</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="ow">in</span> <span class="n">folds</span><span class="p">[</span><span class="s1">&#39;folding&#39;</span><span class="p">]:</span>
                    <span class="n">s</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="p">(</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;scaler&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span><span class="p">)</span>
                    <span class="c1">#if not self.scaler is None and not hasattr(s, &#39;transform&#39;):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">X_train</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
                    <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">sample_with_timing</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s1">&#39;transform&#39;</span><span class="p">):</span>
                        <span class="n">X_test_trans</span><span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">X_test_trans</span><span class="o">=</span> <span class="n">X_test</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    
                    <span class="c1">#if not self.scaler is None and not hasattr(s, &#39;transform&#39;):</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">X_samp</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">scaler</span><span class="o">.</span><span class="n">inverse_transform</span><span class="p">(</span><span class="n">X_samp</span><span class="p">)</span>
                    
                    <span class="n">sampling</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="p">,</span> <span class="n">X_test_trans</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
                <span class="n">runtime</span><span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">higher_prop</span><span class="p">,</span> <span class="n">higher_prop_filename</span><span class="o">=</span> <span class="n">higher_prop_sampling_available</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; reading and resampling from file </span><span class="si">%s</span><span class="s2"> to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">higher_prop_filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)))</span>
                <span class="n">tmp_results</span><span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="n">higher_prop_filename</span><span class="p">),</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
                <span class="n">tmp_sampling</span><span class="o">=</span> <span class="n">tmp_results</span><span class="p">[</span><span class="s1">&#39;sampling&#39;</span><span class="p">]</span>
                <span class="n">tmp_runtime</span><span class="o">=</span> <span class="n">tmp_results</span><span class="p">[</span><span class="s1">&#39;runtime&#39;</span><span class="p">]</span>
                
                <span class="n">sampling</span><span class="o">=</span> <span class="p">[]</span>
                <span class="n">folds</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="o">.</span><span class="n">do_folding</span><span class="p">()</span>
                <span class="n">nums</span><span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span> <span class="k">for</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">folds</span><span class="p">[</span><span class="s1">&#39;folding&#39;</span><span class="p">]]</span>
                <span class="n">i</span><span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="ow">in</span> <span class="n">tmp_sampling</span><span class="p">:</span>
                    <span class="n">new_num</span><span class="o">=</span> <span class="nb">int</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span> <span class="o">-</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">/</span><span class="n">higher_prop</span><span class="o">*</span><span class="n">proportion</span><span class="p">)</span>
                    <span class="n">sampling</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">X_train</span><span class="p">[:(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_num</span><span class="p">)],</span> <span class="n">y_train</span><span class="p">[:(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">new_num</span><span class="p">)],</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="p">))</span>
                    <span class="n">i</span><span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">runtime</span><span class="o">=</span> <span class="n">tmp_runtime</span><span class="o">/</span><span class="n">p</span><span class="o">*</span><span class="n">proportion</span>
                
            <span class="n">results</span><span class="o">=</span> <span class="p">{}</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sampling&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">sampling</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;runtime&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">runtime</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;db_size&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">folds</span><span class="p">[</span><span class="s1">&#39;db_size&#39;</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;db_n_attr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">folds</span><span class="p">[</span><span class="s1">&#39;db_n_attr&#39;</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;imbalanced_ratio&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">folds</span><span class="p">[</span><span class="s1">&#39;imbalanced_ratio&#39;</span><span class="p">]</span>
            
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; dumping to file </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>
        
    <span class="k">def</span> <span class="nf">do_sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_sampling</span><span class="p">()</span>
        <span class="n">results</span><span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">),</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">results</span>
    
    <span class="k">def</span> <span class="nf">get_params</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">deep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;folding&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">folding</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span> <span class="s1">&#39;sampler_name&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39;sampler_parameters&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="p">}</span>
    
    <span class="k">def</span> <span class="nf">descriptor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>

<span class="k">class</span> <span class="nc">Evaluation</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cache-able evaluation of classifier on sampling</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling</span><span class="p">,</span> <span class="n">classifiers</span><span class="p">,</span> <span class="n">n_threads</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constructor of an Evaluation object</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            sampling (obj): Sampling object</span>
<span class="sd">            classifiers (list(obj)): classifier objects</span>
<span class="sd">            n_threads (int/None): number of threads</span>
<span class="sd">            random_state (int/np.random.RandomState/None): random state initializer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">=</span> <span class="n">sampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="o">=</span> <span class="n">classifiers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_threads</span><span class="o">=</span> <span class="n">n_threads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="o">=</span> <span class="n">sampling</span><span class="o">.</span><span class="n">cache_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">standardized_filename</span><span class="p">(</span><span class="s1">&#39;eval&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="o">=</span> <span class="n">random_state</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">classifiers</span><span class="p">)):</span>
            <span class="n">label</span><span class="o">=</span> <span class="nb">str</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">get_params</span><span class="p">(),</span> <span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_params</span><span class="p">()))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">calculate_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">all_pred</span><span class="p">,</span> <span class="n">all_test</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates metrics of binary classifiction</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            all_pred (np.matrix): predicted probabilities</span>
<span class="sd">            all_test (np.matrix): true labels</span>
<span class="sd">            </span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: all metrics of binary classification</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span><span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">all_pred</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">all_pred_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">all_pred</span><span class="p">)</span>
    
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">all_test</span><span class="p">,</span> <span class="n">all_pred_labels</span><span class="p">),</span> <span class="p">(</span><span class="n">all_test</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">all_test</span><span class="p">,</span> <span class="n">all_pred_labels</span><span class="p">),</span> <span class="p">(</span><span class="n">all_test</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">all_test</span><span class="p">,</span> <span class="n">all_pred_labels</span><span class="p">)),</span> <span class="p">(</span><span class="n">all_test</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">all_test</span><span class="p">,</span> <span class="n">all_pred_labels</span><span class="p">)),</span> <span class="p">(</span><span class="n">all_test</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;acc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sens&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ppv&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;npv&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fpr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fdr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ppv&#39;</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fnr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sens&#39;</span><span class="p">]</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;bacc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;gacc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;f1&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;mcc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ltp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lfp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">])))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lfn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">])))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ltn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ln&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;uc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ltp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lfp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lfn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ltn&#39;</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ln&#39;</span><span class="p">])</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;informedness&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sens&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;markedness&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ppv&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;npv&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;log_loss&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">log_loss</span><span class="p">(</span><span class="n">all_test</span><span class="p">,</span> <span class="n">all_pred</span><span class="p">)</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;auc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">all_test</span><span class="p">,</span> <span class="n">all_pred</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">test_labels</span><span class="p">,</span> <span class="n">preds</span><span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">all_test</span><span class="p">,</span> <span class="n">all_pred</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">test_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_labels</span><span class="p">)</span>
            <span class="n">th</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">test_labels</span><span class="p">))</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;p_top20&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">test_labels</span><span class="p">[:</span><span class="n">th</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">th</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;brier&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">all_pred</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">all_test</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;acc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sens&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ppv&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;npv&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fpr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">1</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fdr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">1</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fnr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">1</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;bacc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;gacc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;f1&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;mcc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ltp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lfp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lfn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ltn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ln&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;uc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;informedness&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;markedness&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;log_loss&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;auc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;p_top20&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">0</span>
            <span class="n">results</span><span class="p">[</span><span class="s1">&#39;brier&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">1</span>
        
        <span class="k">return</span> <span class="n">results</span>
    
    <span class="k">def</span> <span class="nf">do_evaluation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does the evaluation or reads it from file</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            dict: all metrics</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_threads</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">mkl</span>
                <span class="n">mkl</span><span class="o">.</span><span class="n">set_num_threads</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_threads</span><span class="p">)</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; mkl thread number set to </span><span class="si">%d</span><span class="s2"> successfully&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_threads</span><span class="p">))</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; setting mkl thread number didn&#39;t succeed&quot;</span><span class="p">))</span>
        
        <span class="n">evaluations</span><span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)):</span>
            <span class="n">evaluations</span><span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">),</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
        
        <span class="n">already_evaluated</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">l</span> <span class="ow">in</span> <span class="n">evaluations</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">])</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">already_evaluated</span><span class="p">):</span>
            <span class="n">samp</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">do_sampling</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">evaluations</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        
        <span class="c1"># setting random states</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">)):</span>
            <span class="n">clf_params</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
            <span class="k">if</span> <span class="s1">&#39;random_state&#39;</span> <span class="ow">in</span> <span class="n">clf_params</span><span class="p">:</span>
                <span class="n">clf_params</span><span class="p">[</span><span class="s1">&#39;random_state&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">clf_params</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">CalibratedClassifierCV</span><span class="p">):</span>
                <span class="n">clf_params</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">base_estimator</span><span class="o">.</span><span class="n">get_params</span><span class="p">()</span>
                <span class="n">clf_params</span><span class="p">[</span><span class="s1">&#39;random_state&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">base_estimator</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">base_estimator</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="o">**</span><span class="n">clf_params</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">)):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">already_evaluated</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; do the evaluation </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">db_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
                <span class="n">all_preds</span><span class="p">,</span> <span class="n">all_tests</span><span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
                <span class="n">minority_class_label</span><span class="o">=</span> <span class="kc">None</span>
                <span class="n">majority_class_label</span><span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span> <span class="ow">in</span> <span class="n">samp</span><span class="p">[</span><span class="s1">&#39;sampling&#39;</span><span class="p">]:</span>
                    <span class="n">class_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span>
                    <span class="n">min_class_size</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">y_train</span> <span class="o">==</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">class_labels</span><span class="p">])</span>
                    
                    <span class="n">ss</span><span class="o">=</span> <span class="n">StandardScaler</span><span class="p">()</span>
                    <span class="n">X_train_trans</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_train</span><span class="p">)</span>
                    <span class="n">nonzero_var_idx</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ss</span><span class="o">.</span><span class="n">var_</span> <span class="o">&gt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">X_test_trans</span><span class="o">=</span> <span class="n">ss</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
                    
                    <span class="n">enough_minority_samples</span><span class="o">=</span> <span class="n">min_class_size</span> <span class="o">&gt;</span> <span class="mi">4</span>
                    <span class="n">y_train_big_enough</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">4</span>
                    <span class="n">two_classes</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_labels</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span>
                    <span class="n">at_least_one_feature</span><span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nonzero_var_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
                    
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">enough_minority_samples</span><span class="p">:</span>
                        <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; not enough minority samples: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">min_class_size</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">y_train_big_enough</span><span class="p">:</span>
                        <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; number of minority training samples is not enough: </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">y_train</span><span class="p">)))</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">two_classes</span><span class="p">:</span>
                        <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; there is only 1 class in training data&quot;</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">at_least_one_feature</span><span class="p">:</span>
                        <span class="n">_logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; no information in features&quot;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">all_tests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_test</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">minority_class_label</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">majority_class_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="n">class_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">y_train</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">y_test</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">y_test</span><span class="p">):</span>
                                <span class="n">minority_class_label</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                                <span class="n">majority_class_label</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">minority_class_label</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                                <span class="n">majority_class_label</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        
                        <span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train_trans</span><span class="p">[:,</span><span class="n">nonzero_var_idx</span><span class="p">],</span> <span class="n">y_train</span><span class="p">)</span>
                        <span class="n">all_preds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test_trans</span><span class="p">[:,</span><span class="n">nonzero_var_idx</span><span class="p">]))</span>
                
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_tests</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">all_preds</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_preds</span><span class="p">)</span>
                    <span class="n">all_tests</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">all_tests</span><span class="p">)</span>
                    
                    <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span><span class="n">all_preds</span><span class="p">,</span> <span class="n">all_tests</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_metrics</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                    
                <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;runtime&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">samp</span><span class="p">[</span><span class="s1">&#39;runtime&#39;</span><span class="p">]</span>
                <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;sampler&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;classifier&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;sampler_parameters&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="p">)</span>
                <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;classifier_parameters&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">classifiers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>
                <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;sampler_categories&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">categories</span><span class="p">)</span>
                <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;db_name&#39;</span><span class="p">]</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span><span class="o">.</span><span class="n">folding</span><span class="o">.</span><span class="n">db_name</span>
                <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;db_size&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">samp</span><span class="p">[</span><span class="s1">&#39;db_size&#39;</span><span class="p">]</span>
                <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;db_n_attr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">samp</span><span class="p">[</span><span class="s1">&#39;db_n_attr&#39;</span><span class="p">]</span>
                <span class="n">evaluations</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">labels</span><span class="p">[</span><span class="n">i</span><span class="p">]][</span><span class="s1">&#39;imbalanced_ratio&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">samp</span><span class="p">[</span><span class="s1">&#39;imbalanced_ratio&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">already_evaluated</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot; dumping to file </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">))</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">evaluations</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;wb&quot;</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">evaluations</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

<span class="k">def</span> <span class="nf">trans</span><span class="p">(</span><span class="n">X</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transformation function used to aggregate the evaluation results.</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        X (pd.DataFrame): a grouping of a data frame containing evaluation results</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">&#39;auc&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s1">&#39;auc&#39;</span><span class="p">]),</span> 
                         <span class="s1">&#39;brier&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s1">&#39;brier&#39;</span><span class="p">]),</span> 
                         <span class="s1">&#39;acc&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s1">&#39;acc&#39;</span><span class="p">]),</span> 
                         <span class="s1">&#39;f1&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s1">&#39;f1&#39;</span><span class="p">]),</span>
                         <span class="s1">&#39;p_top20&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s1">&#39;p_top20&#39;</span><span class="p">]),</span> 
                         <span class="s1">&#39;gacc&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s1">&#39;gacc&#39;</span><span class="p">]),</span> 
                         <span class="s1">&#39;runtime&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="s1">&#39;runtime&#39;</span><span class="p">]),</span>
                         <span class="s1">&#39;db_size&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">[</span><span class="s1">&#39;db_size&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                         <span class="s1">&#39;db_n_attr&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">[</span><span class="s1">&#39;db_n_attr&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                         <span class="s1">&#39;imbalanced_ratio&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">[</span><span class="s1">&#39;imbalanced_ratio&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                         <span class="s1">&#39;sampler_categories&#39;</span><span class="p">:</span> <span class="n">X</span><span class="p">[</span><span class="s1">&#39;sampler_categories&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                         <span class="s1">&#39;classifier_parameters_auc&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;auc&#39;</span><span class="p">)[</span><span class="s1">&#39;classifier_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;classifier_parameters_acc&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;acc&#39;</span><span class="p">)[</span><span class="s1">&#39;classifier_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;classifier_parameters_gacc&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;gacc&#39;</span><span class="p">)[</span><span class="s1">&#39;classifier_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;classifier_parameters_f1&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;f1&#39;</span><span class="p">)[</span><span class="s1">&#39;classifier_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;classifier_parameters_p_top20&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;p_top20&#39;</span><span class="p">)[</span><span class="s1">&#39;classifier_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;classifier_parameters_brier&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;brier&#39;</span><span class="p">)[</span><span class="s1">&#39;classifier_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;sampler_parameters_auc&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;auc&#39;</span><span class="p">)[</span><span class="s1">&#39;sampler_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;sampler_parameters_acc&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;acc&#39;</span><span class="p">)[</span><span class="s1">&#39;sampler_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;sampler_parameters_gacc&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;gacc&#39;</span><span class="p">)[</span><span class="s1">&#39;sampler_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;sampler_parameters_f1&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;f1&#39;</span><span class="p">)[</span><span class="s1">&#39;sampler_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;sampler_parameters_p_top20&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;p_top20&#39;</span><span class="p">)[</span><span class="s1">&#39;sampler_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                         <span class="s1">&#39;sampler_parameters_brier&#39;</span><span class="p">:</span> <span class="n">X</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s1">&#39;p_top20&#39;</span><span class="p">)[</span><span class="s1">&#39;sampler_parameters&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                         <span class="p">},</span> <span class="n">index</span><span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">_clone_classifiers</span><span class="p">(</span><span class="n">classifiers</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Clones a set of classifiers</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        classifiers (list): a list of classifier objects</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">results</span><span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">classifiers</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">MLPClassifierWrapper</span><span class="p">):</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">clone</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">results</span>
    
<span class="k">def</span> <span class="nf">_cache_samplings</span><span class="p">(</span><span class="n">folding</span><span class="p">,</span> <span class="n">samplers</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">max_n_sampler_par_comb</span><span class="o">=</span> <span class="mi">35</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;create sampling objects&quot;</span><span class="p">)</span>
    <span class="n">sampling_objs</span><span class="o">=</span> <span class="p">[]</span>
    
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">random_state</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">random_state</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">random_state</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">random_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">random_state</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span>
    
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">samplers</span><span class="p">:</span>
    
        <span class="n">sampling_par_comb</span><span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">parameter_combinations</span><span class="p">()</span>
        <span class="n">sampling_par_comb</span><span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sampling_par_comb</span><span class="p">,</span> <span class="nb">min</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">sampling_par_comb</span><span class="p">),</span> <span class="n">max_n_sampler_par_comb</span><span class="p">]),</span> <span class="n">replace</span><span class="o">=</span> <span class="kc">False</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">spc</span> <span class="ow">in</span> <span class="n">sampling_par_comb</span><span class="p">:</span>
            <span class="n">sampling_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Sampling</span><span class="p">(</span><span class="n">folding</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">spc</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">random_state</span><span class="p">))</span>
            
    <span class="c1"># sorting sampling objects to optimize execution</span>
    <span class="k">def</span> <span class="nf">key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sampler</span><span class="p">,</span> <span class="n">ADG</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sampler</span><span class="p">,</span> <span class="n">AMSCO</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">sampler</span><span class="p">,</span> <span class="n">DSRBF</span><span class="p">):</span>
            <span class="k">if</span> <span class="s1">&#39;proportion&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">30</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="p">[</span><span class="s1">&#39;proportion&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">30</span>
        <span class="k">elif</span> <span class="s1">&#39;proportion&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">sampler_parameters</span><span class="p">[</span><span class="s1">&#39;proportion&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">OverSampling</span><span class="o">.</span><span class="n">cat_memetic</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">sampler</span><span class="o">.</span><span class="n">categories</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">20</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">10</span>
    
    <span class="n">sampling_objs</span><span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">sampling_objs</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span> <span class="n">key</span><span class="p">)))</span>
    
    <span class="c1"># executing sampling in parallel</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;executing </span><span class="si">%d</span><span class="s2"> sampling in parallel&quot;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">sampling_objs</span><span class="p">))</span>
    <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span> <span class="mi">1</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">cache_sampling</span><span class="p">)()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sampling_objs</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">sampling_objs</span>
            
<span class="k">def</span> <span class="nf">_cache_evaluations</span><span class="p">(</span><span class="n">sampling_objs</span><span class="p">,</span> <span class="n">classifiers</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="c1"># create evaluation objects</span>
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;create classifier jobs&quot;</span><span class="p">)</span>
    <span class="n">evaluation_objs</span><span class="o">=</span> <span class="p">[]</span>
    
    <span class="n">num_threads</span><span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">n_jobs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">n_jobs</span> <span class="ow">is</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">1</span>
    
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sampling_objs</span><span class="p">:</span>
        <span class="n">evaluation_objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Evaluation</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">_clone_classifiers</span><span class="p">(</span><span class="n">classifiers</span><span class="p">),</span> <span class="n">num_threads</span><span class="p">,</span> <span class="n">random_state</span><span class="p">))</span>
    
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;executing </span><span class="si">%d</span><span class="s2"> evaluation jobs in parallel&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">evaluation_objs</span><span class="p">)))</span>
    <span class="c1"># execute evaluation in parallel</span>
    <span class="n">evals</span><span class="o">=</span> <span class="n">Parallel</span><span class="p">(</span><span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span> <span class="mi">1</span><span class="p">)(</span><span class="n">delayed</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">do_evaluation</span><span class="p">)()</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">evaluation_objs</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">evals</span>

<span class="k">def</span> <span class="nf">_read_db_results</span><span class="p">(</span><span class="n">cache_path_db</span><span class="p">):</span>
    <span class="n">results</span><span class="o">=</span> <span class="p">[]</span>
    <span class="n">evaluation_files</span><span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_path_db</span><span class="p">,</span> <span class="s1">&#39;eval*.pickle&#39;</span><span class="p">))</span>
    
    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">evaluation_files</span><span class="p">:</span>
        <span class="n">eval_results</span><span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">eval_results</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>
    
    <span class="k">return</span> <span class="n">results</span>

<span class="k">def</span> <span class="nf">read_oversampling_results</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span> <span class="n">cache_path</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">all_results</span><span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads the results of the evaluation</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        datasets (list): list of datasets and/or dataset loaders - a dataset is a dict with &#39;data&#39;, &#39;target&#39; and &#39;name&#39; keys</span>
<span class="sd">        cache_path (str): path to a cache directory</span>
<span class="sd">        all_results (bool): True to return all results, False to return an aggregation</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: all results or the aggregated results if all_results is False</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">results</span><span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">dataset_spec</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
        
        <span class="c1"># loading dataset if needed and determining dataset name</span>
        <span class="n">dataset</span><span class="o">=</span> <span class="n">dataset_spec</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset_spec</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">dataset_spec</span>
        <span class="n">dataset_name</span><span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">dataset</span> <span class="k">else</span> <span class="n">dataset_spec</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">dataset_name</span>

        <span class="c1"># determining dataset specific cache path</span>
        <span class="n">cache_path_db</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_path</span><span class="p">,</span> <span class="n">dataset_name</span><span class="p">)</span>
        
        <span class="c1"># reading the results</span>
        <span class="n">res</span><span class="o">=</span> <span class="n">_read_db_results</span><span class="p">(</span><span class="n">cache_path_db</span><span class="p">)</span>
        
        <span class="c1"># concatenating the results</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;concatenating results&quot;</span><span class="p">)</span>
        <span class="n">db_res</span><span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
        <span class="n">db_res</span><span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">db_res</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;aggregating the results&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">all_results</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">db_res</span><span class="o">=</span> <span class="n">db_res</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span> <span class="p">[</span><span class="s1">&#39;db_name&#39;</span><span class="p">,</span> <span class="s1">&#39;classifier&#39;</span><span class="p">,</span> <span class="s1">&#39;sampler&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;level_3&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">db_res</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
    
<div class="viewcode-block" id="evaluate_oversamplers"><a class="viewcode-back" href="../../model_selection.html#smote_variants.evaluate_oversamplers">[docs]</a><span class="k">def</span> <span class="nf">evaluate_oversamplers</span><span class="p">(</span><span class="n">datasets</span><span class="p">,</span>
                          <span class="n">samplers</span><span class="p">,</span>
                          <span class="n">classifiers</span><span class="p">,</span>
                          <span class="n">cache_path</span><span class="p">,</span>
                          <span class="n">validator</span><span class="o">=</span> <span class="n">RepeatedStratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span> <span class="mi">3</span><span class="p">),</span>
                          <span class="n">scaler</span><span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="n">all_results</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                          <span class="n">remove_sampling_cache</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                          <span class="n">max_samp_par_comb</span><span class="o">=</span> <span class="mi">35</span><span class="p">,</span>
                          <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                          <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates oversampling techniques using various classifiers on various datasets</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        datasets (list): list of datasets and/or dataset loaders - a dataset is a dict with &#39;data&#39;, &#39;target&#39; and &#39;name&#39; keys</span>
<span class="sd">        samplers (list): list of oversampling classes/objects</span>
<span class="sd">        classifiers (list): list of classifier objects</span>
<span class="sd">        cache_path (str): path to a cache directory</span>
<span class="sd">        validator (obj): validator object</span>
<span class="sd">        scaler (obj): scaler object</span>
<span class="sd">        all_results (bool): True to return all results, False to return an aggregation</span>
<span class="sd">        remove_sampling_cache (bool): True to remove sampling objects after evaluation</span>
<span class="sd">        max_samp_par_comb (int): maximum number of sampler parameter combinations to be tested</span>
<span class="sd">        n_jobs (int): number of parallel jobs</span>
<span class="sd">        random_state (int/np.random.RandomState/None): initializer of the random state</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: all results or the aggregated results if all_results is False</span>
<span class="sd">        </span>
<span class="sd">    Example::</span>
<span class="sd">        </span>
<span class="sd">        import smote_variants as sv</span>
<span class="sd">        import imbalanced_datasets as imbd</span>
<span class="sd">        </span>
<span class="sd">        from sklearn.tree import DecisionTreeClassifier</span>
<span class="sd">        from sklearn.neighbors import KNeighborsClassifier</span>
<span class="sd">        </span>
<span class="sd">        datasets= [imbd.load_glass2, imbd.load_ecoli4]</span>
<span class="sd">        oversamplers= [sv.SMOTE_ENN, sv.NEATER, sv.Lee]</span>
<span class="sd">        classifiers= [KNeighborsClassifier(n_neighbors= 3),</span>
<span class="sd">                      KNeighborsClassifier(n_neighbors= 5),</span>
<span class="sd">                      DecisionTreeClassifier()]</span>
<span class="sd">        </span>
<span class="sd">        cache_path= &#39;/home/&lt;user&gt;/smote_validation/&#39;</span>
<span class="sd">        </span>
<span class="sd">        results= evaluate_oversamplers(datasets,</span>
<span class="sd">                                       oversamplers,</span>
<span class="sd">                                       classifiers,</span>
<span class="sd">                                       cache_path)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">cache_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;cache_path is not specified&#39;</span><span class="p">)</span>
    
    <span class="n">results</span><span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">dataset_spec</span> <span class="ow">in</span> <span class="n">datasets</span><span class="p">:</span>
        <span class="c1"># loading dataset if needed and determining dataset name</span>
        <span class="n">dataset</span><span class="o">=</span> <span class="n">dataset_spec</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dataset_spec</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">dataset_spec</span>
        <span class="n">dataset_name</span><span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="s1">&#39;name&#39;</span> <span class="ow">in</span> <span class="n">dataset</span> <span class="k">else</span> <span class="n">dataset_spec</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">dataset_name</span>
        
        <span class="n">dataset_original_target</span><span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">class_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">min_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">maj_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">maj_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">min_ind</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">min_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">maj_ind</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">maj_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span> <span class="n">min_ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span> <span class="n">maj_ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">cache_path_db</span><span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_path</span><span class="p">,</span> <span class="n">dataset_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">cache_path_db</span><span class="p">):</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;creating cache directory&quot;</span><span class="p">)</span>
            <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">cache_path_db</span><span class="p">)</span>
        
        <span class="c1"># checking of samplings and evaluations are available</span>
        <span class="n">samplings_available</span><span class="o">=</span> <span class="kc">False</span>
        <span class="n">evaluations_available</span><span class="o">=</span> <span class="kc">False</span>
        
        <span class="n">samplings</span><span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_path_db</span><span class="p">,</span> <span class="s1">&#39;sampling*.pickle&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">samplings</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">samplings_available</span><span class="o">=</span> <span class="kc">True</span>
            
        <span class="n">evaluations</span><span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_path_db</span><span class="p">,</span> <span class="s1">&#39;eval*.pickle&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">evaluations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">evaluations_available</span><span class="o">=</span> <span class="kc">True</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;dataset: </span><span class="si">%s</span><span class="s2">, samplings_available: </span><span class="si">%s</span><span class="s2">, evaluations_available: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dataset_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">samplings_available</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">evaluations_available</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">remove_sampling_cache</span> <span class="ow">and</span> <span class="n">evaluations_available</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">samplings_available</span><span class="p">:</span>
            <span class="c1"># remove_sampling_cache is enabled and evaluations are available, they are being read</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;reading result from cache, sampling and evaluation is not executed&quot;</span><span class="p">)</span>
            <span class="n">res</span><span class="o">=</span> <span class="n">_read_db_results</span><span class="p">(</span><span class="n">cache_path_db</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;doing the folding&quot;</span><span class="p">)</span>
            <span class="n">folding</span><span class="o">=</span> <span class="n">Folding</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">validator</span><span class="p">,</span> <span class="n">cache_path_db</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
            <span class="n">folding</span><span class="o">.</span><span class="n">do_folding</span><span class="p">()</span>
            
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;do the samplings&quot;</span><span class="p">)</span>
            <span class="n">sampling_objs</span><span class="o">=</span> <span class="n">_cache_samplings</span><span class="p">(</span><span class="n">folding</span><span class="p">,</span> <span class="n">samplers</span><span class="p">,</span> <span class="n">scaler</span><span class="p">,</span> <span class="n">max_samp_par_comb</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
            
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;do the evaluations&quot;</span><span class="p">)</span>
            <span class="n">res</span><span class="o">=</span> <span class="n">_cache_evaluations</span><span class="p">(</span><span class="n">sampling_objs</span><span class="p">,</span> <span class="n">classifiers</span><span class="p">,</span> <span class="n">n_jobs</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)</span>
        
        <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">dataset_original_target</span>
        
        <span class="c1"># removing samplings once everything is done</span>
        <span class="k">if</span> <span class="n">remove_sampling_cache</span><span class="p">:</span>
            <span class="n">filenames</span><span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_path_db</span><span class="p">,</span> <span class="s1">&#39;sampling*&#39;</span><span class="p">))</span>
            <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;removing unnecessary sampling files&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">filenames</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;concatenating the results&quot;</span><span class="p">)</span>
        <span class="n">db_res</span><span class="o">=</span> <span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
        <span class="n">db_res</span><span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">db_res</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        
        <span class="c1">#def filter_results(x):</span>
        <span class="c1">#    if &quot;&#39;p&#39;&quot; in x and &#39;p&#39; in eval(x) and eval(x)[&#39;p&#39;] == 2:</span>
        <span class="c1">#        return True</span>
        <span class="c1">#    else:</span>
        <span class="c1">#        return False</span>
        
        <span class="c1">#db_res= db_res[db_res[&#39;classifier_parameters&#39;].apply(lambda x: filter_results(x))]</span>
        
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">db_res</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cache_path_db</span><span class="p">,</span> <span class="s1">&#39;results.pickle&#39;</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">))</span>
        
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;aggregating the results&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">all_results</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">db_res</span><span class="o">=</span> <span class="n">db_res</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">by</span><span class="o">=</span> <span class="p">[</span><span class="s1">&#39;db_name&#39;</span><span class="p">,</span> <span class="s1">&#39;classifier&#39;</span><span class="p">,</span> <span class="s1">&#39;sampler&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;level_3&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">db_res</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">results</span><span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span> <span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="model_selection"><a class="viewcode-back" href="../../model_selection.html#smote_variants.model_selection">[docs]</a><span class="k">def</span> <span class="nf">model_selection</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span>
                      <span class="n">samplers</span><span class="p">,</span>
                      <span class="n">classifiers</span><span class="p">,</span>
                      <span class="n">cache_path</span><span class="p">,</span>
                      <span class="n">score</span><span class="o">=</span> <span class="s1">&#39;auc&#39;</span><span class="p">,</span>
                      <span class="n">validator</span><span class="o">=</span> <span class="n">RepeatedStratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span> <span class="mi">3</span><span class="p">),</span>
                      <span class="n">remove_sampling_cache</span><span class="o">=</span> <span class="kc">False</span><span class="p">,</span> 
                      <span class="n">max_samp_par_comb</span><span class="o">=</span> <span class="mi">35</span><span class="p">,</span>
                      <span class="n">n_jobs</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                      <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates oversampling techniques on various classifiers and a dataset</span>
<span class="sd">    and returns the oversampling and classifier objects giving the best performance</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        dataset (dict): a dataset is a dict with &#39;data&#39;, &#39;target&#39; and &#39;name&#39; keys</span>
<span class="sd">        samplers (list): list of oversampling classes/objects</span>
<span class="sd">        classifiers (list): list of classifier objects</span>
<span class="sd">        cache_path (str): path to a cache directory</span>
<span class="sd">        score (str): &#39;auc&#39;/&#39;acc&#39;/&#39;gacc&#39;/&#39;f1&#39;/&#39;brier&#39;/&#39;p_top20&#39;</span>
<span class="sd">        validator (obj): validator object</span>
<span class="sd">        all_results (bool): True to return all results, False to return an aggregation</span>
<span class="sd">        remove_sampling_cache (bool): True to remove sampling objects after evaluation</span>
<span class="sd">        max_samp_par_comb (int): maximum number of sampler parameter combinations to be tested</span>
<span class="sd">        n_jobs (int): number of parallel jobs</span>
<span class="sd">        random_state (int/np.random.RandomState/None): initializer of the random state</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        obj, obj: the best performing sampler object and the best performing classifier object</span>
<span class="sd">        </span>
<span class="sd">    Example::</span>
<span class="sd">        </span>
<span class="sd">        import smote_variants as sv</span>
<span class="sd">        import imbalanced_datasets as imbd</span>
<span class="sd">        </span>
<span class="sd">        from sklearn.tree import DecisionTreeClassifier</span>
<span class="sd">        from sklearn.neighbors import KNeighborsClassifier</span>
<span class="sd">        </span>
<span class="sd">        datasets= imbd.load_glass2()</span>
<span class="sd">        oversamplers= [sv.SMOTE_ENN, sv.NEATER, sv.Lee]</span>
<span class="sd">        classifiers= [KNeighborsClassifier(n_neighbors= 3),</span>
<span class="sd">                      KNeighborsClassifier(n_neighbors= 5),</span>
<span class="sd">                      DecisionTreeClassifier()]</span>
<span class="sd">        </span>
<span class="sd">        cache_path= &#39;/home/&lt;user&gt;/smote_validation/&#39;</span>
<span class="sd">        </span>
<span class="sd">        sampler, classifier= model_selection(dataset,</span>
<span class="sd">                                             oversamplers,</span>
<span class="sd">                                             classifiers,</span>
<span class="sd">                                             cache_path,</span>
<span class="sd">                                             &#39;auc&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">score</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;auc&#39;</span><span class="p">,</span> <span class="s1">&#39;acc&#39;</span><span class="p">,</span> <span class="s1">&#39;gacc&#39;</span><span class="p">,</span> <span class="s1">&#39;f1&#39;</span><span class="p">,</span> <span class="s1">&#39;brier&#39;</span><span class="p">,</span> <span class="s1">&#39;p_top20&#39;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;score </span><span class="si">%s</span><span class="s2"> not supported&quot;</span> <span class="o">%</span> <span class="n">score</span><span class="p">)</span>
    
    <span class="n">results</span><span class="o">=</span> <span class="n">evaluate_oversamplers</span><span class="p">(</span><span class="n">datasets</span><span class="o">=</span> <span class="p">[</span><span class="n">dataset</span><span class="p">],</span>
                                   <span class="n">samplers</span><span class="o">=</span> <span class="n">samplers</span><span class="p">,</span>
                                   <span class="n">classifiers</span><span class="o">=</span> <span class="n">classifiers</span><span class="p">,</span>
                                   <span class="n">cache_path</span><span class="o">=</span> <span class="n">cache_path</span><span class="p">,</span>
                                   <span class="n">validator</span><span class="o">=</span> <span class="n">validator</span><span class="p">,</span>
                                   <span class="n">remove_sampling_cache</span><span class="o">=</span> <span class="n">remove_sampling_cache</span><span class="p">,</span>
                                   <span class="n">max_samp_par_comb</span><span class="o">=</span> <span class="n">max_samp_par_comb</span><span class="p">,</span>
                                   <span class="n">n_jobs</span><span class="o">=</span> <span class="n">n_jobs</span><span class="p">,</span>
                                   <span class="n">random_state</span><span class="o">=</span> <span class="n">random_state</span><span class="p">)</span>
    
    <span class="c1"># extracting the best performing classifier and oversampler parameters regarding AUC</span>
    <span class="n">highest_score</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="n">score</span><span class="p">]</span><span class="o">.</span><span class="n">idxmax</span><span class="p">()</span>
    <span class="n">cl_par_name</span><span class="o">=</span> <span class="s1">&#39;classifier_parameters_&#39;</span> <span class="o">+</span> <span class="n">score</span>
    <span class="n">samp_par_name</span><span class="o">=</span> <span class="s1">&#39;sampler_parameters_&#39;</span> <span class="o">+</span> <span class="n">score</span>
    <span class="n">cl</span><span class="p">,</span> <span class="n">cl_par</span><span class="p">,</span> <span class="n">samp</span><span class="p">,</span> <span class="n">samp_par</span><span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">highest_score</span><span class="p">][[</span><span class="s1">&#39;classifier&#39;</span><span class="p">,</span>
                                                           <span class="n">cl_par_name</span><span class="p">,</span>
                                                           <span class="s1">&#39;sampler&#39;</span><span class="p">,</span>
                                                           <span class="n">samp_par_name</span><span class="p">]]</span>
    
    <span class="c1"># instantiating the best performing oversampler and classifier objects</span>
    <span class="n">samp_obj</span><span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">samp</span><span class="p">)(</span><span class="o">**</span><span class="nb">eval</span><span class="p">(</span><span class="n">samp_par</span><span class="p">))</span>
    <span class="n">cl_obj</span><span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="n">cl</span><span class="p">)(</span><span class="o">**</span><span class="nb">eval</span><span class="p">(</span><span class="n">cl_par</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">samp_obj</span><span class="p">,</span> <span class="n">cl_obj</span></div>

<div class="viewcode-block" id="cross_validate"><a class="viewcode-back" href="../../model_selection.html#smote_variants.cross_validate">[docs]</a><span class="k">def</span> <span class="nf">cross_validate</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span>
                   <span class="n">sampler</span><span class="p">,</span>
                   <span class="n">classifier</span><span class="p">,</span>
                   <span class="n">validator</span><span class="o">=</span> <span class="n">RepeatedStratifiedKFold</span><span class="p">(</span><span class="n">n_splits</span><span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">n_repeats</span><span class="o">=</span> <span class="mi">3</span><span class="p">),</span>
                   <span class="n">scaler</span><span class="o">=</span> <span class="n">StandardScaler</span><span class="p">(),</span>
                   <span class="n">random_state</span><span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates oversampling techniques on various classifiers and a dataset</span>
<span class="sd">    and returns the oversampling and classifier objects giving the best performance</span>
<span class="sd">    </span>
<span class="sd">    Args:</span>
<span class="sd">        dataset (dict): a dataset is a dict with &#39;data&#39;, &#39;target&#39; and &#39;name&#39; keys</span>
<span class="sd">        samplers (list): list of oversampling classes/objects</span>
<span class="sd">        classifiers (list): list of classifier objects</span>
<span class="sd">        validator (obj): validator object</span>
<span class="sd">        scaler (obj): scaler object</span>
<span class="sd">        random_state (int/np.random.RandomState/None): initializer of the random state</span>
<span class="sd">        </span>
<span class="sd">    Returns:</span>
<span class="sd">        pd.DataFrame: the cross-validation scores</span>
<span class="sd">        </span>
<span class="sd">    Example::</span>
<span class="sd">        </span>
<span class="sd">        import smote_variants as sv</span>
<span class="sd">        import imbalanced_datasets as imbd</span>
<span class="sd">        </span>
<span class="sd">        from sklearn.neighbors import KNeighborsClassifier</span>
<span class="sd">        </span>
<span class="sd">        dataset= imbd.load_glass2()</span>
<span class="sd">        sampler= sv.SMOTE_ENN</span>
<span class="sd">        classifier= KNeighborsClassifier(n_neighbors= 3)</span>
<span class="sd">        </span>
<span class="sd">        sampler, classifier= model_selection(dataset,</span>
<span class="sd">                                             oversampler,</span>
<span class="sd">                                             classifier)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="n">class_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">])</span>
    <span class="n">binary_problem</span><span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">class_labels</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
    
    <span class="n">dataset_orig_target</span><span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">binary_problem</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;The problem is binary&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">min_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">maj_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">min_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">maj_label</span><span class="o">=</span> <span class="n">class_labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="n">min_ind</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">min_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">maj_ind</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">maj_label</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span> <span class="n">min_ind</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span> <span class="n">maj_ind</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;The problem is not binary&quot;</span><span class="p">)</span>
        <span class="n">label_indices</span><span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">class_labels</span><span class="p">:</span>
            <span class="n">label_indices</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">c</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">mapping</span><span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">class_labels</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">],</span> <span class="n">label_indices</span><span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">mapping</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span> <span class="n">c</span>
    
    <span class="n">runtimes</span><span class="o">=</span> <span class="p">[]</span>
    <span class="n">all_preds</span><span class="p">,</span> <span class="n">all_tests</span><span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
    
    <span class="k">for</span> <span class="n">train</span><span class="p">,</span> <span class="n">test</span> <span class="ow">in</span> <span class="n">validator</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]):</span>
        <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Executing fold&quot;</span><span class="p">)</span>
        <span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">train</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">][</span><span class="n">train</span><span class="p">]</span>
        <span class="n">X_test</span><span class="p">,</span> <span class="n">y_test</span><span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="n">test</span><span class="p">],</span> <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">][</span><span class="n">test</span><span class="p">]</span>
        
        <span class="n">begin</span><span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">X_samp</span><span class="p">,</span> <span class="n">y_samp</span><span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
        <span class="n">runtimes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">begin</span><span class="p">)</span>
        
        <span class="n">X_samp_trans</span><span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit_transform</span><span class="p">(</span><span class="n">X_samp</span><span class="p">)</span>
        <span class="n">nonzero_var_idx</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">scaler</span><span class="o">.</span><span class="n">var_</span> <span class="o">&gt;</span> <span class="mf">1e-8</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">X_test_trans</span><span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
        
        <span class="n">all_tests</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">y_test</span><span class="p">)</span>
        
        <span class="n">classifier</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_samp_trans</span><span class="p">[:,</span><span class="n">nonzero_var_idx</span><span class="p">],</span> <span class="n">y_samp</span><span class="p">)</span>
        <span class="n">all_preds</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">classifier</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test_trans</span><span class="p">[:,</span><span class="n">nonzero_var_idx</span><span class="p">]))</span>
    
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_tests</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">all_preds</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">all_preds</span><span class="p">)</span>
        <span class="n">all_tests</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">all_tests</span><span class="p">)</span>
    
    <span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">dataset_orig_target</span>
    
    <span class="n">_logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing the results&quot;</span><span class="p">)</span>
    
    <span class="n">results</span><span class="o">=</span> <span class="p">{}</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;runtime&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">runtimes</span><span class="p">)</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sampler&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">sampler</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;classifier&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">classifier</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sampler_parameters&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sampler</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;classifier_parameters&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">classifier</span><span class="o">.</span><span class="n">get_params</span><span class="p">())</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;db_size&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">])</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;db_n_attr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">results</span><span class="p">[</span><span class="s1">&#39;db_n_classes&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">class_labels</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">binary_problem</span><span class="p">:</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;imbalance_ratio&#39;</span><span class="p">]</span><span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">maj_label</span><span class="p">)</span><span class="o">/</span><span class="nb">sum</span><span class="p">(</span><span class="n">dataset</span><span class="p">[</span><span class="s1">&#39;target&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">min_label</span><span class="p">)</span>
        <span class="n">all_pred_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">all_preds</span><span class="p">)</span>
    
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">all_tests</span><span class="p">,</span> <span class="n">all_pred_labels</span><span class="p">),</span> <span class="p">(</span><span class="n">all_tests</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">all_tests</span><span class="p">,</span> <span class="n">all_pred_labels</span><span class="p">),</span> <span class="p">(</span><span class="n">all_tests</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">all_tests</span><span class="p">,</span> <span class="n">all_pred_labels</span><span class="p">)),</span> <span class="p">(</span><span class="n">all_tests</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">all_tests</span><span class="p">,</span> <span class="n">all_pred_labels</span><span class="p">)),</span> <span class="p">(</span><span class="n">all_tests</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;acc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sens&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ppv&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;npv&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fpr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fdr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ppv&#39;</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fnr&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sens&#39;</span><span class="p">]</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;bacc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span><span class="o">/</span><span class="mf">2.0</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;gacc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">/</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;f1&#39;</span><span class="p">]</span><span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;mcc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">])</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ltp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lfp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">])))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lfn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">])))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ltn&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">((</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fp&#39;</span><span class="p">])</span><span class="o">*</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;tn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;fn&#39;</span><span class="p">])))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lp&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ln&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;p&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">]))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;uc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ltp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lfp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lfn&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ltn&#39;</span><span class="p">])</span><span class="o">/</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;l&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;lp&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ln&#39;</span><span class="p">])</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;informedness&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;sens&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;spec&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;markedness&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;ppv&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;npv&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="mf">1.0</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;log_loss&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">log_loss</span><span class="p">(</span><span class="n">all_tests</span><span class="p">,</span> <span class="n">all_preds</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;auc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">roc_auc_score</span><span class="p">(</span><span class="n">all_tests</span><span class="p">,</span> <span class="n">all_preds</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">test_labels</span><span class="p">,</span> <span class="n">preds</span><span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">all_tests</span><span class="p">,</span> <span class="n">all_preds</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">key</span><span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="n">test_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">test_labels</span><span class="p">)</span>
        <span class="n">th</span><span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">test_labels</span><span class="p">))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;p_top20&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">test_labels</span><span class="p">[:</span><span class="n">th</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">th</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;brier&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">all_preds</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">all_tests</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">all_pred_labels</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="n">all_preds</span><span class="p">)</span>
        
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;acc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">accuracy_score</span><span class="p">(</span><span class="n">all_tests</span><span class="p">,</span> <span class="n">all_pred_labels</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;confusion_matrix&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">confusion_matrix</span><span class="p">(</span><span class="n">all_tests</span><span class="p">,</span> <span class="n">all_pred_labels</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;gacc&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">gmean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;confusion_matrix&#39;</span><span class="p">])</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;confusion_matrix&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">results</span><span class="p">[</span><span class="s1">&#39;class_label_mapping&#39;</span><span class="p">]</span><span class="o">=</span> <span class="n">mapping</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s1">&#39;confusion_matrix&#39;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">values</span><span class="p">()),</span> <span class="n">index</span><span class="o">=</span> <span class="n">results</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">columns</span><span class="o">=</span> <span class="p">[</span><span class="s1">&#39;value&#39;</span><span class="p">])</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, György Kovács

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
    

  

  <script type="text/javascript" src="../../_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>